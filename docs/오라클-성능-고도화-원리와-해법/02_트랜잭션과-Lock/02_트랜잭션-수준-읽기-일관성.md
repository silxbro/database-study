# 02. 트랜잭션 수준 읽기 일관성

<br/>

## (1) 트랜잭션 수준 읽기 일관성이란?
#### ✅ 트랜잭션 수준 읽기 일관성(Transaction-Level Read Consistency)은 트랜잭션이 시작된 시점을 기준으로 일관성 있게 데이터를 읽어들이는 것을 말한다
- 트랜잭션이 진행되는 동안 다른 트랜잭션에 의해 변경사항이 발생하더라도 이를 무시하고 계속해서 일관성 있는 데이터를 보고자 하는 업무요건이 있을 수 있다.
  물론 트랜잭션이 진행되는 동안 자신이 발생시킨 변경사항은 읽을 수 있어야 한다.
- 오라클은 완벽한 문장수준의 읽기 일관성을 보장하지만, 트랜잭션에 대해서는 기본적으로 보장하지 않는다. 다른 DBMS도 트랜잭션 수준의 읽기 일관성은 보장하지 않는다.
  트랜잭션 수준으로 읽기 일관성을 강화하려면 트랜잭션 고립화 수준을 높여 주어야 한다.

<br/>

## (2) 트랜잭션 고립화 수준
#### ✅ ANSI/ISO SQL standard(SQL92)에서 정의하고 있는 트랜잭션 고립화 수준(Transaction Isolation Level)은 아래 네 가지로 요약할 수 있다.
- **레벨 0 (= Read Uncommitted)**
  - 트랜잭션에서 처리 중인, 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용
  - Dirty Read, Non-Repeatable Read, Phantom Read 현상 발생
  - Oracle은 이 레벨을 지원하지 않음
- **레벨 1 (= Read Committed)**
  - Dirty Read 방지 : 트랜잭션이 커밋되어 확정된 데이터만 읽는 것을 허용
  - 대부분의 DBMS가 기본모드로 채택하고 있는 일관성 모드
  - Non-Repeatable Read, Phantom Read 현상은 여전히 발생
  - DB2, SQL Server, Sybase의 경우 읽기 공유 Lock을 이용해서 구현. 하나의 레코드를 읽을 때 Lock을 설정하고 해당 레코드를 빠져 나가는 순간 Lock 해제
  - Oracle은 Lock을 사용하지 않고 쿼리시작 시점의 Undo 데이터를 제공하는 방식으로 구현
- **레벨 2 (= Repeatable Read)**
  - 선행 트랜잭션이 읽은 데이터는 트랜잭션이 종료될 때까지 후행 트랜잭션이 갱신하거나 삭제하는 것을 불허함으로써 같은 데이터를 두 번 쿼리했을 때 일관성 있는 결과를 리턴
  - Phantom Read 현상은 여전히 발생
  - DB2, SQL Server의 경우 트랜잭션 고립화 수준을 Repeatable Read로 변경하면 읽은 데이터에 걸린 공유 Lock을 커밋할 때까지 유지하는 방식으로 구현
  - Oracle은 이 레벨을 명시적으로 지원하지 않지만 for upate 절을 이용해 구현가능. SQL Server 등에서도 for update 절을 사용할 수 있지만 커서를 명시적으로 선언할 때만 사용 가능함
- **레벨 3 (= Serializable)**
  - 선행 트랜잭션이 읽은 데이터를 후행 트랜잭션이 갱신하거나 삭제하지 못할 뿐만 아니라 중간에 새로운 레코드를 삽입하는 것도 막아줌
  - 완벽한 읽기 일관성 모드를 제공

#### ✅ DBMS에서 제공하는 트랜잭션 고립화 수준 조정기능을 이용해 트랜잭션 레벨 읽기 일관성을 확보하려면 아래 문장 하나만 수행해 주면 된다.
```
set transaction isoltaion level serializable;
```

#### ✅ 낮은 단계의 트랜잭션 고립화 수준을 사용할 때 발생하는 현상에는 다음 세 가지가 있다.
> Dirty Read (= Uncommitted Dependency)
>
> Non-Repeatable Read (= Inconsistent Analysis)
>
> Phantom Read

<br/>

## (3) Dirty Read (= Uncommitted Dependency)
#### ✅ Dirty Read는 아직 커밋되지 않은 수정 중인 데이터를 다른 트랜잭션이 읽을 수 있도록 허용할 때 발생한다
- 만약 Dirty Read를 허용하는 상황에서 아래 문장이 수행되는 도중에 다른 트랜잭션에 의해 특정 계좌의 잔고가 변경된다면 쿼리의 최종 결과 값이 비일관성(inconsistency) 상태에 놓이게 될 수 있다.
  왜냐하면, 그 트랜잭션이 어떤 이유에서건 롤백될 수 있기 때문이다.

  ```
  select sum(잔고) from 계좌;
  ```
#### ✅ 대부분 DBMS가 기본 트랜잭션 고립화 수준을 레벨 1(= Read Committed)로 설정, 즉 커밋된 데이터만 읽을 수 있도록 허용하고 있기 때문에 Dirty Read 현상은 발생하지 않는다
- SQL Server, Sybase 등은 이를 구현하기 위해 데이터를 읽을 때 공유 Lock을 사용한다.
  - 갱신 중인 레코드에는 배타적 Lock이 걸리는데, 이는 공유 Lock과 호환되지 않으므로 갱신 중인 레코드를 읽지 못한다.
  - Lock에 의한 동시성 저하가 자주 문제시되므로 쿼리에 옵션을 사용해서 Dirty Read를 허용하도록 프로그래밍하는 경우도 있다. 즉, 트랜잭션 고립화 수준을 레벨 0(=Read UnCommitted)으로 낮추는 것이다.
- 오라클은 다중 버전 읽기 일관성 모델을 채택함으로써 Lock을 사용하지 않고도 Dirty Read를 피해 일관성 있는 데이터 읽기가 가능하고, 따라서 레벨 0 수준으로 트랜잭션 고립화 수준을 낮추는 방법을
  아예 제공하지 않고 있다.

<br/>

## (4) Non-Repeatable Read (= Inconsistent Analysis)
#### ✅ 한 트랜잭션 내에서 같은 쿼리를 두 번 수행할 때, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 두 쿼리의 결과가 상이하게 나타나는 비일관성(Inconsistency)이 발생하는 것을 말한다
- Non-Repeatable Read 때문에 데이터가 불일치 상태에 놓이게 되는 사례를 살펴보자.

  |TX1||TX2|
      |:---|:---:|:---|
  |SELECT 당월주문금액 into :amt<br/>FROM 고객<br/>WHERE 고객번호 = 123;<br/><br/><br/><br/><br/><br/><br/><br/><br/>IF :amt >= 50000 THEN<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UPDATE 고객<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SET 등급 = 'A'<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE 고객번호 = 123;<br/>ELSE<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UPDATE 고객<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SET 등급 = 'B'<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE 고객번호 = 123;<br/>END IF;<br/><br/>COMMIT;| t1<br/><br/><br/>t2<br/><br/><br/><br/><br/><br/>t3<br/><br/>t4<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>t5 | <br/><br/>UPDATE 고객<br/>SET 당월주문금액 = 60000<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;, 등급 = 'A'<br/>WHERE 고객번호 = 123;<br/><br/><br/>COMMIT;<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>|

  - t1 시점에 123번 고객의 당월주문금액은 40,000원이었다고 가정하자. 즉, [1]번 쿼리를 통해 :amt 변수에 40000이 저장된다.
  - 두 트랜잭션이 수행을 종료하고 나면, TX2 트랜잭션에 의해 이 고객의 당월주문금액이 60,000원으로 변경되었음에도 y4 시점에 고객 등급이 'B'로 하향 조정되는 결과를 가져온다.
    Non-Repeatable Read 현상 때문에 TX2 트랜잭션의 등급 조정(B → A)이 상실되는 Lost Update가 발생한 것이다.
  - Non-Repeatable Read 현상을 방지하려면 TX1이 [1]번 문장을 수행할 때 for update 절을 추가해 줘어야 한다.
    그러면 123 고객 레코드에 Lock이 걸리므로 TX2 트랜잭션은 블로킹 됐다가 TX1이 커밋하는 t5 시점 이후에 진행을 계속한다.<br/>

- Non-Repeatable Read 사례를 하나 더 살펴보자.

  |TX1||TX2|
      |:---|:---:|:---|
  |SELECT 잔고 into :balance<br/>FROM 계좌<br/>WHERE 계좌번호 = 123;<br/><br/><br/><br/><br/><br/><br/>UPDATE 계좌<br/>SET 잔고 = 잔고 - 10000<br/>WHERE 계좌번호 = 123<br/>AND 잔고 >= 10000;<br/><br/>IF sql%rowcount = 0 THEN<br/>alert( '잔고가 부족합니다' );<br/>END IF;<br/><br/>COMMIT;| t1<br/><br/><br/>t2<br/><br/><br/><br/>t3<br/><br/>t4<br/><br/><br/><br/><br/>t5<br/><br/><br/><br/>t6| <br/><br/><br/>UPDATE 계좌<br/>SET 잔고 = 잔고 - 50000<br/>WHERE 계좌번호 = 123;<br/><br/>COMMIT;<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>|

  - t1 시점에 123번 계좌번호의 잔고는 55,000원이었다고 가정하자.
    [1]번 쿼리를 통해 자신의 계좌에 55,000원이 남아 있음을 확인하고 t4 시점에 10,000원을 인출하려고 시도했으나 TX2 트랜잭션에 의해 이 계좌의 잔고가 5,000원으로 변경되었다.
    따라서, 잔고가 충분한 것을 확인하고 인출을 시도했음에도 불구하고 잔고가 부족하다는 메시지를 받게 된다.
  - TX1 트랜잭션이 [1]번 쿼리에서 읽은 값을 이용해 [2]번에서 값을 갱신하는 데 사용하지는 않았으므로 데이터가 잘못 갱신되는 문제는 발생하지 않았지만, 예금 인출을 시도한 고객은 영문도 모르고 순간
    당황하게 된다. 만약, TX1의 [2]번 update가 [1]번 쿼리에서 읽은 값(:balance)을 이용하도록 아래와 같이 구현했다면 TX2의 갱신이 사라지는 결과를 가져올 수도 있다.

    ```
    UPDATE 계좌 SET 잔고 = :balance - 10000
    WHERE  계좌번호 = 123
    AND    :balance >= 10000
    ```

<br/>

## (5) Phantom Read
#### ✅ 한 트랜잭션 안에서 일정범위의 레코드들을 두 번 이상 읽을 때, 첫 번째 쿼리에서 없던 유령(Phantom) 레코드가 두 번째 쿼리에서 나타나는 현상을 말한다
- Phantom Read 현상에 의해 데이터가 불일치 상태에 놓이게 되는 사례를 살펴보자.

  |TX1||TX2|
    |:---|:---:|:---|
  |INSERT INTO 지역별고객<br/>SELECT 지역, COUNT(\*)<br/>FROM 고객<br/>GROUP BY 지역;<br/><br/><br/><br/><br/><br/><br/>INSERT INTO 연령대별고객<br/>SELECT 연령대, COUNT(*)<br/>FROM 고객<br/>GROUP BY 연령대;<br/><br/>COMMIT;| t1<br/><br/><br/><br/>t2<br/><br/><br/><br/>t3<br/><br/>t4<br/><br/><br/><br/><br/>t5|<br/><br/><br/>INSERT INTO 고객<br/>(고객번호, 이름, 지역, 연령대, ...)<br/>VALUES( :a, :b, :c, :d, ...);<br/><br/>COMMIT;<br/><br/><br/><br/><br/><br/><br/>|

  - TX1 트랜잭션이 지역별고객과 연령대별고객을 연속해서 집계하는 도중에 새로운 고객이 TX2 트랜잭션에 의해 등록되었다.
    그 결과, 지역별고객과 연령대별고객 두 집계 테이블을 통해 총고객수를 조회하면 서로 결과 값이 다른 불일치 상태에 놓이게 된다.
  - 이런 Phantom Read 현상을 방지하려면 TX1이 [1]번 문장을 수행하기 전에 아래 문장을 통해 트랜잭션 고립화 수준을 레벨 3으로 올려주어야 한다.

    ```
    set transaction isolation level serializable;
    ```

    고립화 수준을 레벨 3으로 높이면 SQL Server에서는 Lock을 통해 t2 시점에 새로운 고객이 추가되는 것을 막아 버린다.

    - 따라서 고립화 수준을 높이면 데이터 일관성은 확보되지만 동시성이 현저히 저하되는 결과를 초래한다.
      반면, 오라클은 Lock을 전혀 사용하지 않은 상태에서 [1]번과 [2]번 쿼리 모두 SCN 확인 과정을 통해 t1 시점에 존재했던 고객만을 대상으로 집계를 수행하므로 동시성을 저하시키지 않으면서 일관성을 유지한다.

- Phantom Read에 의해 데이터 일관성이 훼손되는 사례를 하나 더 살펴보자.

  |TX1||TX2|
    |:---|:---:|:---|
  |INSERT INTO 로그백업&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>SELECT * FROM 로그;<br/><br/><br/><br/><br/><br/><br/>DELETE FROM 로그;<br/><br/>COMMIT;| t1<br/><br/><br/>t2<br/><br/><br/>t3<br/><br/>t4<br/><br/>t5|<br/><br/>INSERT INTO 로그( 일시, ID, ... )<br/>VALUES (SYSDATE, 'A0001', ...);<br/><br/>COMMIT;<br/><br/><br/><br/>|

  - TX1 트랜잭션이 로그 테이블을 로그백업 테이블로 백업하고, 전체 로그 데이터를 지운 후에 커밋을 수행하였다.
    TX1의 [1] ~ [3] 세 개 명령을 하나의 트랜잭션으로 일관성 있게 처리하려면, t1 시점에 존재했던 로그 데이터만 백업하고 지워야 한다.
    하지만 기본 트랜잭션 고립화 수준(레벨 1)에서는 TX2 트랜잭션에 의해 t2 ~ t3 시점에 추가된 로그 데이터까지 TX1 트랜잭션에 의해 지워진다.
  - TX1이 [1]번 문장을 수행하기 전에 트랜잭션 고립화 수준을 레벨 3으로 올려주면 이를 방지할 수 있다. 그러면 SQL Server에서는 Lock을 통해 t2 시점에 새로운 로그가 추가되는 것을 막아 버린다.
    오라클은 TX1 트랜잭션이 t4 시점에 delete 문장을 수행하더라도 t1 시점에 존재했던 레코드만 찾아서 지우기 때문에 Lock을 사용하지 않고도 TX2 트랜잭션에 의해 새로 추가된 로그 데이터를 안전하게 보호한다.
  - 물론 트랜잭션 고립화 수준을 상향 조정하지 않더라도 TX1의 [1]번과 [2]번 문장에 '일시' 조건을 추가해 줌으로써 일관성 있게 트랜잭션을 처리할 수 있다.

<br/>

지금까지 낮은 단계의 트랜잭션 고립화 수준에서 어떤 문제들이 발생할 수 있는지, 그리고 트랜잭션 내에서 일관성 있게 데이터를 조회, 추가, 수정, 삭제하기 위해 트랜잭션 고립화 수준을 조정하는 방법에 대해 살펴보았다.

트랜잭션 고립화 수준을 높이면 일관성(Consistency)은 향상되지만, 더 넓은 범위의 Lock을 더 오랫동안 유지하는 방식을 사용하므로 동시성(Concurrency)은 저하된다.
하지만 **오라클은 트랜잭션 고립화 수준을 높이더라도 Lock을 사용하지 않으므로 동시성이 저하되지는 않는다.**

#### [SERIALIZABLE_ABORTS]
다른 DBMS는 트랜잭션 고립화 수준을 구현하기 위해 Lock을 이용하지만, 오라클은 for update 절을 사용하지 않는 한 절대 select 문에 Lock을 사용하지 않기 때문에 레벨을 상향 조정하더라도
이전과 동일한 동시성을 보장한다.

높은 일관성 수준에서도 높은 동시성을 제공할 수 있는 이유는, Undo 데이터를 활용하기 때문이다.
그렇지만 세상만사에 공짜는 없는 법이어서 만일 트랜잭션 레벨에서 일관성 있는 데이터를 제공할 수 없는 상황이 발생하면 다른 DBMS에는 없는 아래와 같은 에러를 던지게 된다.

|TXA||TXB|
|:---|:---:|:---|
|set transaction isolation<br/>level serializable;<br/><br/><br/><br/><br/><br/>SELECT 잔고 FROM 계좌<br/>WHERE 고객번호 = 5;<br/><br/>UPDATE 계좌<br/>SET 잔고 = 잔고 + 500<br/>WHERE 고객번호 = 5;<br/><br/>ERROR at line 1:<br/>ORA-08177: can`t serialize<br/>access for this transaction|t1<br/><br/>t2<br/><br/><br/><br/>t3<br/>t4<br/><br/><br/>t5<br/><br/><br/><br/><br/><br/><br/>|<br/><br/>UPDATE 계좌<br/>SET 잔고 = 잔고 + 1000<br/>WHERE 고객번호 = 5;<br/><br/>COMMIT;<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>|

5번 고객의 최초 잔고가 1,000원인 상태에서 만약 t1 시점에 트랜잭션 고립화 수준을 조정하지 않고 트랜잭션을 진행한다면 두 트랜잭션이 완료된 후 최종 잔고는 2,500원이 될 것이다.

위처럼 트랜잭션 고립화 수준을 Serializable로 바꾸고 나서 트랜잭션을 수행하면 이제는 트랜잭션이 시작한 시점, 즉 t1 시점을 기준으로 값을 읽어야 한다.
t2 ~ t3 시점에 값이 변경되더라도 t4 시점의 select문은 Undo 데이터를 이용해 t1 시점의 데이터를 재현해 내면 되므로 전혀 문제가 없다.

하지만 t5 시점의 update 문은 사정이 다르다.
5번 고객의 잔고가 이미 2,000원으로 변경된 상태에서 트랜잭션 A가 t1 시점의 값을 기준으로 update를 수행하면, 갱신이 완료된 시점에는 잔고가 1,500원이 된다.
Lost Update가 발생하는 것이며, 오라클은 이를 방지하기 위해 ORA-08177 에러를 던진다.

Undo 데이터를 활용함으로써 높은 수준의 동시성과 읽기 일관성을 유지하는 대신 다른 DBMS에 없는 Snapshot too old(ORA-01555)를 얻게 된 것과 같은 현상이라고 이해하면 된다.

참고로, v$sql에서 serializable_aborts > 0인 레코드를 조회하면 이 에러를 만났던 SQL들을 확인할 수 있다.