# 01. 인덱스 구조

<br/>

## (1) 범위 스캔
인덱스 구조를 설명하기에 앞서 "범위(Range)" 스캔의 의미를 새겨 보자.

인덱스는 대용량 테이블에서 필요한 데이터만 빠르고 효율적으로 액세스할 목적으로 사용하는 오브젝트다.
테이블은 처음부터 끝까지 모든 레코드를 읽어야 완전한 결과집합을 얻을 수 있지만, 인덱스는 키 컬럼 순으로 정렬돼 있기 때문에 특정 위치에서 스캔을 시작해 검색 조건에 일치하지 않는 값을 만나는 순간
멈출 수 있다. 이것이 범위 스캔(Range Scan)이 의미하는 바다.

테이블도 범위 스캔이 가능한 경우가 있기는 하다. IOT(index-organized table)는 특정 컬럼 순으로 정렬 상태를 유지하며 값을 입력하므로 범위 스캔이 가능하다.
이를 제외한다면 일반적인 힙 구조 테이블(heap-organized table)에서 범위 스캔은 있을 수 없다.
정렬 상태가 유지되도록 사용자가 아무리 주의 깊게 데이터를 입력한들, 옵티마이저가 그것을 신뢰해 Table Range Scan 같은 실행계획을 수립하진 않는다.

<br/>

## (2) 인덱스 기본 구조
여러 종류의 인덱스 중에서 가장 일반적으로 사용되는 구조는 B*tree 인덱스 구조이다.

루트(Root)를 포함한 브랜치(Branch) 블록에 저장된 엔트리에는 하위 노드 블록을 찾아가기 위한 DBA(Data Block Address) 정보를 갖고 있고, 최말단 리프(Leaf) 블록에는 인덱스 키 컬럼과 함께
해당 테이블 레코드를 찾아가기 위한 주소정보(rowid)를 갖는다. 리프 블록은 항상 키 컬럼 순으로 정렬돼 있기 때문에 '범위 스캔'이 가능하다고 앞서 설명하였다.
키 값이 같을 때는 rowid 순으로 정렬된다는 사실도 기억하기 바란다.

- ### [LeftMost Child]

  브랜치 노드의 각 엔트리는 키 값과 하위 노드를 가리키는 블록 주소를 갖는다. 그런데 키 값을 갖지 않는 특별한 엔트리가 하나 있는데, 각 브랜치 노드의 첫 번째 엔트리가 그렇다.
  이를 'lmc(LeftMost Child)'라고 부르기로 하자.

  다른 엔트리는 자신의 키 값과 같거나 큰 값을 담은 자식 노드 블록을 가리키는 반면, lmc는 명시적인 키 값을 갖지 않더라도 '키 값을 가진 첫 번째 엔트리보다 작은 값'의 의미를 갖는다.
  따라서 그 브랜치 블록의 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킨다.

값이 null인지 여부에 상관없이 모든 레코드를 인덱스에 저장하는 DBMS가 있는가 하면 오라클은 인덱스 구성 컬럼이 모두 null인 레코드는 저장하지 않는다.
그리고 (인덱스 구성 컬럼이 모두 null인 경우를 제외하면) 인덱스와 테이블 레코드 간에는 서로 1:1 대응 관계를 갖는다.
참고로, 뒤에서 다시 설명하겠지만 클러스터 인덱스(Cluster Index)는 1:M 관계를 갖는다.

브랜치에 저장된 레코드 개수는 바로 하위 레벨 블록 개수와 일치한다는 점도 기억할 필요가 있다.
- 가장 왼쪽 끝 자식 노드를 가리키는 lmc는 키 값을 갖지 않은 채 다른 엔트리와 별도로 저장되지만, 이것 역시 하나의 레코드로 간주하기로 하자.

인덱스 리프 노드상의 레코드와 테이블 레코드 간에는 1:1 관계라고 했는데, 값도 서로 일치한다. 따라서 테이블 레코드에서 값이 갱신되면 리프 노드 인덱스 키 값도 같이 갱신(delete & insert)된다.

반면, 리프 노드상의 엔트리 키 값이 갱신되더라도 브랜치 노드까지 값이 바뀌지는 않는다.
브랜치 블록에 놓인 엔트리는 자신의 키 값과 같거나 큰 값을 담는 하위 노드 블록을 포인팅하는 것으로서, 그 키 값은 자식 노드가 갖는 값의 범위를 나타내기 때문이다.
따라서 키 값이 하위 노드의 첫 번째 레코드와 정확히 일치하지 않는다.

참고로, 브랜치 노드는 인덱스 분할(Split)에 의해 새로운 블록이 추가되거나 삭제(다른 브랜치의 자식 노드로 이동)될 때만 갱신된다.

지금까지 설명한 내용을 요악하면 다음과 같다.
- 리프 노드상의 인덱스 레코드와 테이블 레코드 간에는 1:1 관계
- 리프 노드상의 키 값과 테이블 레코드 키 값은 서로 일치
- 브랜치 노드상의 레코드 개수는 하위 레벨 블록 개수와 일치
- 브랜치 노드상의 키 값은 하위 노드가 갖는 값의 범위를 의미

이런 인덱스 구조와 특징을 정확히 이해해야만 인덱스 탐색 과정도 쉽게 이해할 수 있다.

<br/>

## (3) 인덱스 탐색
인덱스 탐색 과정을 수직적 탐색과 수평적 탐색으로 구분해 설명할 수 있다.
수평적 탐색은 앞서 강조했던 범위 스캔(Range Scan)을 말하는 것이며, 리프 블록을 인덱스 레코드 간 논리적 순서에 따라 좌에서 우, 또는 우에서 좌로 스캔하기 때문에 '수평적'이라고 표현한다.

수직적 탐색은 **수평적 탐색을 위한 시작 지점을 찾는 과정**이라고 할 수 있으며, 루트에서 리프 블록까지 아래쪽으로 진행하기 때문에 '수직적'이다.

### [브랜치 블록 스캔]
브랜치 블록을 스캔할 때는 뒤에서부터 스캔하는 방식이 유리하다.
뒤에서부터 스캔할 때는 찾고자 하는 값보다 작은 첫 번째 레코드를 만나는 순간 바로 하위 블록으로 내려가면 되지만, 앞에서부터 스캔할 때는 찾고자 하는 값보다 크거나 같은 첫 번째 레코드를 만나는 순간
멈춰서 한 칸 뒤로 이동해야 하기 때문이다.

하지만 오라클이 실제로 뒤쪽부터 스캔하는지는 필자도 알 수가 없다.
어쩌면 값을 거꾸로 입력해 두고서 앞쪽부터 스캔할지도 모를 일이지만, 앞으로 인덱스 스캔 과정을 설명할 때는 뒤쪽부터 스캔한다고 가정하기로 하자.

브랜치 블록을 따라 수직적 탐색을 진행할 때는 찾고자 하는 값보다 키 값이 작은 엔트리를 따라 내려간다는 사실도 기억할 필요가 있다. 중복이 많은 인덱스를 탐색해 내려가다 보면 그 이유를 자연스럽게 이해할 수 있다.

만약 같은 값을 따라 내려간다면, 이전 브랜치 블록에 위치한 중복값을 놓치게 되기 때문이다.

<br/>

## (4) ROWID 포맷
rowid에는 데이터파일 번호, 블록 번호, 로우 번호 같은 테이블 레코드의 물리적 위치정보를 포함한다.
테이블 레코드를 찾아가는 데 필요한 주소 정보이므로 테이블 자체에 저장되는 것은 아니라 인덱스에 저장된다. 필요하면 rowid를 출력해 볼 수 있지만 그 값이 테이블에 실제 저장돼 있지는 않다.
즉, pseudo 컬럼이다.

그럼 인덱스를 거치지 않는 쿼리에서 rowid를 요구할 때면 어떻게 그 값을 출력할까?
오브젝트 및 데이터파일 번호, 그리고 그 파일 내에서의 상대적인 블록 번호가 데이터 블록 헤더에 저장돼 있기 때문에 전혀 어렵지 않다.
레코드를 읽는 시점에, 현재 도달한 블록 헤더와 각 레코드에 할당된 슬롯 번호를 이용해 충분히 가공해 낼 수 있는 것이다.

그러면 인덱스에 저장되는 rowid는 얼마만큼의 공간을 차지할까? 오라클 7 버전까지 rowid는 내부적으로 6 바이트 크기를 차지하며, 파일번호, 블록번호, 로우 번호로 구성된다.

그러다가 오라클 8 부터는 rowid 크기를 10 바이트로 증가시켰다.
데이터베이스에 저장해야 할 데이터량이 점차 증가해 더 많은 데이터 파일을 관리할 필요가 생겼고, 파티션 같은 기능을 지원하기 위해 오브젝트 번호까지 저장할 필요가 생겼기 때문이다.
rowid를 10바이트로 늘림으로써 오라클은 tera-byte를 넘어 peta-byte 단위의 데이터를 저장할 수 있게 되었다.

하지만, 항상 10 바이트로 저장하는 것은 아니어서 테이블과 인덱스 유형에 따라 여전히 6 바이트를 사용하기도 한다. 예를 들어, 아래 경우는 rowid가 기존처럼 6 바이트 공간을 차지한다.
- 파티션되지 않은 일반 테이블에 생성한 인덱스
- 파티션된 테이블에 생성한 로컬 파티션(Local Partitioned) 인덱스

반면, 아래 경우는 10 바이트를 차지하며, 이런 사실은 인덱스 블록 덤프를 통해 쉽게 확인할 수 있다.
- 파티션 테이블에 생성한 글로벌 파티션(Global Partitioned) 인덱스
- 파티션 테이블에 생성한 비파티션(Non Partitioned) 인덱스

오라클 8부터 내부적으로 rowid 사이즈가 달라지면서 외부로 출력되는 rowid 포맷되 달라졌고, 이렇게 달라진 새로운 rowid 포맷을 '확장(Extended) rowid 포맷'이라고 부른다.
반면, 이전에 사용되던 포맷은 이제 '제한(Restricted) rowid 포맷'이라고 부르게 되었다. 그리고 내부적으로 몇 바이트로 저장되든 애플리케이션에서 출력해 보면 둘 다 18자리인데, 구성 내용은 조금 다르다.

오라클 7 버전까지 사용하던 '제한 rowid 포맷'은 아래 3개의 구성요소로 이루어진다.
- 데이터파일 번호(4자리)
    - 로우가 속한 데이터파일 번호로서, 데이터베이스 내에서 유일한 값임

- 블록 번호(8자리)
    - 해당 로우가 저장된 데이터 블록 번호이며, (테이블스페이스가 아니라) 데이터파일 내에서의 상대적 번호임

- 로우 번호(4자리)
    - 블록 내에서 각 로우에 붙여진 일련번호로서, 0부터 시작됨

각 구성요소의 자리수를 더하면 16자리이지만 구분자(delimiter)로 사용하는 '.(dot)' 기호를 포함해 18자리 문자열로 출력되며, 순서는 블록.로우.데이터파일 순이다.
```
SQL> select rowid, empno, ename from emp;

ROWID              EMPNO ENAME
------------------ ----- -----------
00000DD5.0000.0001  7369 SMITH
00000DD5.0001.0001  7499 ALLEN
00000DD5.0002.0001  7521 WARD
00000DD5.0003.0001  7566 JONES
...

14 개의 행이 선택되었습니다.
```

오라클 8 버전부터 사용되기 시작한 '확장 rowid 포맷'은 제한 rowid 포맷에 데이터 오브젝트 번호를 더해 4개의 구성요소로 이루어진다.
- 데이터 오브젝트 번호(6자리)
    - 데이터베이스 세그먼트를 식별하기 위해 사용되는 데이터 오브젝트 번호

- 데이터파일 번호(3자리)
    - 로우가 속한 데이터파일 번호(테이블스페이스 내에서의 상대적인 파일 번호)

- 블록 번호(6자리)
    - 해당 로우가 저장된 데이터 블록 번호이며, (테이블스페이스가 아니라) 데이터파일 내에서의 상대적 번호임

- 로우 번호(3자리)
    - 블록 내에서 각 로우에 붙여진 일련번호로서, 0부터 시작됨

애플리케이션에 출력할 때는 별도의 구분자 없이 연속된 18자리 문자열 포맷을 사용하며, 순서는 (데이터 오브젝트)(데이터파일)(블록)(로우) 순이다.
오라클 8 이상에서 여전히 6 바이트 rowid를 사용할 수 있다고 했지만, 출력되는 포맷은 10 바이트 rowid의 그것과 같다.
```
SQL> select rowid, empno, ename from emp;

ROWID              EMPNO ENAME
------------------ ----- -----------
AAAM6PAAEAAAE2cAAA  7369 SMITH
AAAM6PAAEAAAE2cAAB  7499 ALLEN
AAAM6PAAEAAAE2cAAC  7521 WARD
AAAM6PAAEAAAE2cAAD  7566 JONES
...

14 개의 행이 선택되었습니다.
```

출력된 확장 rowid를 자릿수만큼 잘라서 디코딩(Decoding)하면 각 구성요소에 대한 정보를 얻어낼 수 있지만, 아래와 같이 dbms_rowid 패키지를 사용하면 훨씬 쉽다.
확장 rowid 포맷을 제한 rowid 포맷으로 바꿔서 표현해 주는 기능도 있다.
```
SQL> select rowid extended_format
  2       , dbms_rowid.rowid_to_restricted(rowid, 0) restricted_format
  3       , dbms_rowid.rowid_object(rowid) object
  4       , dbms_rowid.rowid_relative_fno(rowid) file_no
  5       , dbms_rowid.rowid_block_number(rowid) block_no
  6       , dbms_rowid.rowid_row_number(rowid) row_number
  7  from   emp e
  8  where  empno = 7369;

EXTENDED_FORMAT    RESTRICTED_FORMAT  OBJECT FILE_NO BLOCK_NO ROW_NUMBER
------------------ ------------------ ------ ------- -------- ----------
AAAM6PAAEAAAE2cAAA 00004D9C.0000.0004  52879       4    19868          0
```