# 10. 대기 이벤트

<br/>

## (1) 대기 이벤트란?

#### ✅ 오라클 프로세스가 다른 프로세스가 일을 마칠 때까지 기다리는, 즉 일을 계속 진행할 수 있는 조건이 충족될 때까지 수면(sleep) 상태에 빠지는데, 이런 현상이 발생하는 것을 '대기 이벤트(Wait Event)'라고 부른다
- 대기 이벤트가 발생할 때마다 오라클은 그 상태정보를 파일 또는 SGA 메모리 내에 저장해 둔다.
- 대기 이벤트는 원래 오라클 개발자들이 디버깅 용도로 개발한 것이라고 한다.
  오라클 개발자들도 공유 자원에 대한 경합이나 기타 원인에 의한 대기가 발생할 때마다 관련 로그를 생성하도록 커널 코드에 기능을 추가했던 것이고, 그것이 오늘에 이르러 OWI(Oracle Wait Interface)
  라는 이름을 덧입으면서 성능관리 분야에 일대 변혁을 가져오게 되었다.
- 참고로, 오라클은 대기 이벤트(Wait Event)라고 부르지만 SQL Server에서는 '대기 유형(Wait Type)'이라고 부른다.

#### ✅ 대기 이벤트를 시스템 커널 레벨에서 설명하면, 프로세스가 할 일을 모두 마쳤거나 다른 프로세스를 기다려야 하는 상황에서 CPU를 쥔 채 대기하면 불필요하게 CPU 자원을 낭비하는 것이므로 CPU를 OS에 반환하고 수면(sleep) 상태로 빠지는 것을 말한다
- 수면에 빠진다는 것은 프로세스가 wait queue로 옮겨지는 것을 말하며, wait queue에 놓인 프로세스에게는 CPU를 할당해 줄 필요가 없으므로 OS는 해당 프로세스를 스케줄링 대상에서 제외시킨다.
- 선행 프로세스가 일을 마치면 OS에게 그 사실을 알려 자신을 기다리던 수면 상태의 프로세스를 깨우도록 신호를 보낸다(interrupted).
  그러면 OS는 그 프로세스를 runnable queue에 옮김으로써 가능한 한 빨리 CPU를 할당 받아 일을 재개할 수 있도록 스케줄링한다.


아래는 유닉스에서 vmstat 유틸리티를 통해 시스템 상황을 모니터링한 것이다.
```
Virtual Memory Statistics: (pagesize = 8192)
  process  memory           pages                               intr       cpu
  r  w  u  act  free  wire  fault  cow  zero  react  pin  pout  in  sy  cs  us  sy  id
  ...
  ...
  (생략)
```
- 맨 왼쪽에 보이는 'r'은 현재 일을 수행 중이거나 runnable queue에서 CPU 리소스를 기다리는 프로세스 개수다.
  이 수치가 CPU 개수를 초과하고 CPU 사용률이 100%에 근접한다면 CPU 병목현상이 발생한 것으로서, 할 일이 산적해 있는데 프로세스들이 빨리 빨리 CPU를 할당 받지 못해 runnable queue에서
  오래 대기하고 있음을 의미한다.
- 'w'는 wait queue에 놓인 프로세스 개수를 의미한다. 즉, Sleep 상태의 프로세스 개수로서 이 값이 큰 것도 병목일 수 있다.
  특히, 오라클 입장에서는 대기 이벤트가 많이 발생한 것이므로 어떤 종류의 대기 이벤트가 발생 중인지 뷰를 통해 확인해 봐야 한다.
  참고로, 위 vmstat 결과 화면에는 idle cpu %(맨 오른쪽)가 낮을 뿐 아니라 paging(pin, pout)도 많이 발생하고 있어 시스템 부하가 매우 극심한 상황임을 알 수 있다.

<br/>

## (2) 대기 이벤트는 언제 발생할까?
#### ✅ 다른 프로세스가 일을 끝마치기를 기다릴 때 발생하는 대기 이벤트가 지속적으로 많이 발생하면 데이터베이스에 병목이 있음을 알리는 신호지만 모든 대기 이벤트가 그렇지는 않다
- 예를 들어, SQL*Net message from client와 SQL*Net more data from client 이벤트는 서버 프로세스가 사용자의 명령이나 신호를 기다릴 때 나타나므로 병목이 발생했다고 볼 수 없다.
- 그 외에도 pmon timer, smon timer, px idle 대기 등은 서버 프로세스가 할 일이 없기 때문에 발생하는 idle 대기 이벤트이기 때문에 데이터베이스 튜닝 시 무시해도 된다.

#### ✅ 대기 이벤트가 발생하게 되는 상황을 아래와 같이 크게 3가지로 요약할 수 있다
- (1) 자신이 필요로 하는 특정 리소스가 다른 프로세스에 의해 사용 중일 때
    - 자신이 읽으려는 버퍼에 다른 프로세스가 쓰기 작업을 진행 중이라면 선행 프로세스가 일을 마칠 때까지 기다려야 한다.
    - buffer busy waits, latch free, enqueue 관련 대기 이벤트 등이 여기에 속한다.
- (2) 다른 프로세스에 의해 선행작업이 완료되기를 기다릴 때
    - 예를 들어, DBWR가 Dirty 버퍼를 디스크에 기록할 때는 먼저 LGWR가 로그 버퍼에 있는 Redo entry를 Redo Log 파일에 기록하는 작업이 선행되어야 한다.
      따라서 DBWR는 LGWR를 깨워 로그 버퍼를 비우라는 신호(signal, post)를 보내고 LGWR가 일을 마칠 때까지 수면 상태에서 휴식을 취한다.
      LGWR가 일을 마치면 DBWR를 깨우고 자신은 다시 대기 상태로 빠진다.
    - write complete waits, checkpoint completed, log file sync, log file switch 이벤트 등이 여기에 속한다.
- (3) 할 일이 없을 때(→ idle 대기 이벤트)
    - 예를 들어, 서버 프로세스는 쿼리 결과를 사용자에게 전송하는 동안 Array 단위로 일을 처리하는데, Array 크기만큼 데이터를 전송하면 다음 Fetch Call을 받을 때까지 기다린다.
      쿼리 결과집합을 모두 전송(End Or Fetch)하고 나서도 다음 Parse Call 또는 Execute Call을 받을 때까지 기다린다.
    - 또 다른 예로서, 병렬 쿼리를 수행하면 자신이 맡은 일을 먼저 끝마치는 병렬 Slave 프로세스가 생기는데 그럴 때면 다른 Slave 들이 일을 마칠 때까지 대기 상태에서 기다린다.
    - SQL*Net message from client, PX Deq: Execution Msg 등이 여기에 속한다.

<br/>

## (3) 대기 이벤트는 언제 사라질까?
#### ✅ 선행 프로세스가 자신을 흔들어 깨우지 않더라도 타이머에 설정된 시간이 도래(timeout)할 때마다 한번ㅆ기 깨어나 자신이 기다리던 리소스가 사용 가능해졌거나 해야 할 일이 생겼는지 확인한다
- 타임아웃(timeout) 설정 값은 대기 이벤트마다 모두 다르다.
    - 예를 들어, 앞에서 설명한 DBWR와 LGWR간 상호작용에 의한 대기 이벤트 발생 시 타임아웃은 둘 다 3초로 설정된다.
      커밋할 때마다 LGWR를 깨워 Redo 버퍼를 비우도록 할 때 발생하는 log file sync 대기 이벤트의 타임아웃은 1초, buffer busy wait 대기 이벤트도 1초다.
- enqueue 관련 Lock 대기 이벤트의 타임아웃은 3초다. 알람(timeout)에 의해 깨어났는데 리소스가 아직 사용 중이거나 선행 프로세스가 일을 마치지 못했다면 다시 수면 상태로 빠진다.
- 대기가 자주 발생하는 것도 문제지만 타임아웃이 자주 발생한다면 대기 이벤트에 의한 지연(latency) 시간이 길어지는 것이므로 더 큰 적신호로 받아 들여야 한다.

#### ✅ 대기 중이던 프로세스가 활동을 재개하는 시점은 다음과 같다
- (1) 대기 상태에 빠진 프로세스가 기다리던 리소스가 사용 가능해 지거나
- (2) 작업을 계속 진행하기 위한 선행작업이 완료되거나
- (3) 해야 할 일이 생겼을 때

<br/>

## (4) 래치와 대기 이벤트 개념 명확화
래치와 대기 이벤트는 구별되어야 한다.

#### ✅ 래치를 얻는 과정 자체가 경합을 의미하지는 않는다
- 공유된 자원을 읽으려면 래치를 얻는 것이 당연한 일이므로 v$latch 뷰에서 gets 횟수가 증가한다고 해서 문제될 것은 없다. 그저 공유자원에 대한 접근 요청이 많았던 것으로 이해하면 된다.
  다만, 그 과정에서 다른 프로세스와 경합이 발생하는지를 관심 있게 살펴봐야 하며, 만약 그렇다면 시스템의 동시성이 저하되므로 문제다.
- v$latch 뷰를 조회해 보면, 각 래치 종류별로 gets, misses, spin_gets, sleeps 항목들이 집계돼 있는데, 간단히 살펴보자.
  참고로, 여기서는 willing-to-wait 모드 래치 요청에 대해서만 설명하며, immediate(=no-wait) 모드 래치 요청을 포함해 래치에 대한 좀더 깊이 있는 학습을 원한다며녀 오라클 매뉴얼이나
  OWI 전문서적을 참고하기 바란다.
    - **gets** : 래치 요청 횟수를 말한다.
    - **misses** : 래치를 요청했는데 다른 프로세스에 의해 자원이 사용 중이어서 첫 번째 시도에서 곧바로 래치를 얻지 못한 횟수다.
        - 래치 miss를 만난 프로세스는, 이후 spin 과정에서 래치 획득에 성공하거나(spin_gets) 정해진 횟수만큼의 spin 후에도 래치획득에 실패해 대기 상태(sleep) 상태에 들어가는, 둘 중 하나의 길을 걷게 된다.
        - gets에서 misses 횟수를 빼면 다른 프로세스의 래치 해제를 기다리지 않고 곧바로 래치 획득에 성공한 횟수(simple_gets)가 구해진다.

          ```
          simple_gets = gets - misses
          ```
    - **spin_gets** : 래치를 요청한 첫 번째 시도에서 곧바로 래치를 얻지는 못했지만 이후 spin하는 과정에서 래치 획득에 성공한 횟수다.
        - spin: CPU를 점유한 상태로, 해당 리소스에 대한 래치가 해제될 때까지 액세스 시도를 반복하는 것을 말한다.
        - misses에서 sleeps을 뺀 횟수와 일치한다. 즉, 첫 번째 시도에서 래치를 얻지는 못했지만 다행히 Sleep 전에 래치를 얻게 되는 경우다.
    - **sleeps** : 래치를 요청했는데 자원이 사용 중이어서 곧바로 래치를 얻지 못했고 정해진 횟수만큼 계속 spin 했는데도 결국 래치를 얻지 못해 대기 상태로 빠진 횟수다.
        - 이때 latch free 대기 이벤트가 발생한다. 잠시 후에 깨어나 다시 spin을 했는데도 래치 획득에 실패하면 또다시 latch free 대기 상태로 빠지게 된다.
        - 래치는 Lock처럼 큐잉(queueing) 메커니즘이 작동하지 않기 때문에 래치 획득에 성공할 때까지 반복적인 액세스 시도가 있을 뿐, 우선권을 부여 받지는 못한다.
          따라서 가장 먼저 래치를 요구했던 프로세스가 가장 늦게 래치를 얻을 수도 있다.
        - 오라클 9i까지는 모든 래치에 대한 대기 이벤트를 latch free 하나로 통합해서 보여주었기 때문에 분석이 쉽지 않았는데, 10g부터는 이를 세분화해 자주 발생ㅇ하는 래치에 대해서는
          예를 들면, 'latch: cache buffers chains', 'latch: library cache lock'처럼 별도의 이벤트 명을 부여했다.
          상대적으로 중요도가 떨어지는 래치에 대한 대기 이벤트는 기존 latch free 이벤트로 집계된다.