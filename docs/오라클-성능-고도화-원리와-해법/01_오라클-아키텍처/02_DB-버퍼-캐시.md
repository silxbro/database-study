# 02. DB 버퍼 캐시
빠른 데이터 입출력을 위해 SGA 공유 메모리를 이용한다고 설명헀는데, 좀 더 구체적으로 말해 사용자가 입력한 데이터를 데이터파일에 저장하고 이를 다시 읽는 과정에서 거쳐 가는 캐시 영역은
SGA 구성요소 중 하나인 **DB 버퍼 캐시**(DB Buffer Cache)다.

## (1) 블록 단위 I/O
#### ✅ 오라클에서 I/O는 블록(Block) 단위로 이루어진다
- 메모리 버퍼 캐시에서 버퍼 블록을 액세스할 때뿐만 아니라 데이터파일에 저장된 데이터 블록을 DB 버퍼 캐시로 적재하거나 캐시에서 변경된 블록을 다시 데이터파일에 저장할 때도 블록 단위로 처리한다.
- 데이터파일에서 버퍼 캐시로 블록을 적재할 때, 인덱스를 경유한 테이블 액세스 시에는 한 번에 한 블록씩(single block read) 읽어들인다.
- Full Scan 시에는 성능 향상을 위해 한 번에 여러 개 블록(multiblock read)을 읽어들인다.
- DBWR 프로세스는 버퍼 캐시로부터 변경된 블록(Dirty 버퍼 블록)을 주기적으로 데이터파일에 기록하는 작업을 수행하는데, 이때도 성능향상을 위해 한 번에 여러 블록을 처리한다.
- 다른 DBMS에서는 블록(Block) 대신 주로 페이지(page)라는 용어를 사용한다.
#### ✅ 블록 단위로 읽는다는 의미는, 하나의 레코드에서 하나의 컬럼만을 읽고자 하더라도 레코드가 속한 블록 전체를 읽게 됨을 의미한다
- 데이터베이스 I/O 성능과 튜닝 원리를 이해하는 데 있어 아주 중요한 의미를 갖는다.
- SQL 성능을 좌우하는 가장 중요한 성능지표는 액세스하는 블록 개수이며, 옵티마이저의 판단에 가장 큰 영향을 미치는 것도 액세스해야 할 블록 개수다.
    - 옵티마이저가 인덱스를 이용해 테이블을 액세스할지 아니면 Full Table Scan 할지를 결정하는 데 있어 가장 중요한 판단 기준은, 읽어야 할 레코드 수가 아니라 블록 개수다.

## (2) 버퍼 캐시 구조
#### ✅ DB 버퍼 캐시는 해시 테이블 구조로 관리된다
- SGA 내에는 수없이 많은 자료구조(Data Structure)가 사용되고 있으며 그 중 가장 많이 사용되는 것이 **해시 테이블**(또는 **해시 맵**)이다.
- 해싱(Hashing) 알고리즘을 설명할 때 흔히 주소록에 비유하곤 하는데, 고객의 주소와 전화번호를 관리하는 주소록에서 성씨가 같은 고객은 같은 페이지(=**해시 버킷**)에 묶어서 관리한다.
- 고객정보가 입수되는 시점이 다르므로 같은 성씨 안에서는 대개 정렬된 상태를 유지하지 않는다. 이 때문에 해시 버킷 내에서는 **스캔 방식**으로 값을 찾는다.
  그렇더라도 키 값을 해시 값으로 변환해 해시 버킷을 찾아가는 속도가 워낙 빨라서 각 버킷에 기록되는 엔트리 개수를 일정 수준으로 유지할 수만 있다면 해싱에 의한 검색 속도가 가장 빠르다고 알려져 있다.
#### ✅ 찾고자 하는 데이터 블록 주소를 해시 값으로 변환해서 해당 해시 버킷에서 체인을 따라 스캔하다가 거기서 찾아지면 바로 읽고, 찾지 못하면 디스크에서 읽어 해시 체인에 연결한 후 읽는다
- DB 버퍼 캐시 내에서 데이터 블록을 해싱하기 위해 사용되는 키 값은 데이터 블록 주소(DBA, Data Block Address)다.
- 해시 함수에 데이터 블록 주소를 입력해 리턴받은 해시 값이 같은 블록들을 같은 해시 버킷(Bucket)에 연결 리스트(Linked List) 구조로 연결하는 것이다.
  각각의 연결 리스트를 **해시 체인**(Hash Chain)이라고 한다.
    - 해시함수를 구현하는 기법에 여러 가지가 있지만 가장 쉬운 나눗셈 법을 예로 들면, 키 값을 해시 버킷 개수로 나누었을 때의 나머지 값을 리턴한다.
- 자신만 읽고 버리는 게 아니라 다른 사용자들도 사용할 수 있도록 캐싱해 두는 것이다.
#### ✅ 버퍼 헤더(Buffer Header)만 해시 체인에 연결되며, 실제의 데이터 값이 필요해지면 버퍼 헤더에 있는 포인터를 이용해 다시 버퍼 블록을 찾아가는 구조이다

## (3) 캐시 버퍼 체인
#### ✅ 각 해시 체인은 래치(Latch)에 의해 보호된다
- DB 버퍼 캐시는 공유 메모리 영역인 SGA 내에 존재하므로 여러 프로세스에 의한 동시 액세스가 일어날 가능성이 크다.
  따라서 같은 리소스에 대한 액세스를 반드시 **직렬화**(serialization)해야 하고, 이를 위해 구현된 일종의 Lock 메커니즘을 래치(Latch)라고 부른다.
- 래치를 획득한 프로세스만이 그 래치에 의해 보호되는 자료구조로의 진입이 허용된다.
    - 예를 들어, 두 개 이상의 프로세스가 같은 해시 체인으로 진입해 새로운 버퍼 블록을 연결하고 해제하는 작업을 동시에 진행한다면 문제가 발생할 수 있고, 이를 방지하기 위해 사용하는 것이
      cache buffers chains 래치다. 이 외에도 래치 종류는 9i 기준으로 241개, 10g 기준으로 394개, 11g 기준 496개나 된다(같은 버전이라도 Release에 따라 개수에 차이가 있다).
- 래치는 데이터 자체를 보호하는 게 아니라 SGA에 공유돼 있는 **자료구조**를 보호하는 것이며, 그중 cache bufferes chains 래치는 버퍼 캐시에 연결된 체인구조를 보호한다.
  즉, 해시 체인을 스캔하거나 거기에 블록을 추가, 제거할 때 래치가 요구된다.
#### ✅ 하나의 래치가 여러 개 해시 체인을 동시에 관리한다
- 예를 들어, 현재 시스템에는 해시 버킷 개수가 2,097,152개(하나의 해시 버킷과 해시 체인은 1:1 관계)이고, 해시 체인을 관리하는 래치 개수는 65,536개이다.
  따라서 하나의 래치가 32개의 버킷을 관리하고 있음을 알 수 있으며, 이는 버퍼 캐시 크기와 버전에 따라 달라진다.
    - 해시 버킷과 래치 개수는 각각 _db_block_hash_buckets과 _db_block_hash_latches 파라미터 값을 통해 확인 가능하다.
#### ✅ 하나의 체인에는 하나의 버퍼만 달리는 것을 목표로 삼아야 한다
- 그래야 목표한 해시 체인을 찾고서 추가적으로 스캔하는 비용을 최소화할 수 있다.
- 해시 버킷 개수가 충분히 많아야 한다.
    - 현재 시스템에서도 블록 버퍼가 836,684개(_db_block_buffers)이므로 해시 버킷 개수가 2.5배 가량 많다.
#### ✅ 오라클 9i부터 읽기전용 작업일 때는 cache buffers chains 래치를 Share 모드로 획득할 수 있다고 한다
- 읽기전용 작업이란 select문을 의미하는 것이 아니라 해시 체인을 스캔하면서 필요한 블록을 찾는 작업을 말한다.
    - 9i 이후 버전에서 Share 모드 래치를 사용하는 것과 상관없이, select 문장을 동시에 수행하면 여전이 cache buffers chains 래치 경합이 발견된다.

## (4) 캐시 버퍼 LRU 체인
#### ✅ 버퍼 캐시는 사용빈도가 높은 데이터 블록들 위주로 구성될 수 있도록 LRU(least recently used) 알고리즘을 사용해 관리된다
- 버퍼 헤더는 해시 체인 뿐 아니라 LRU 체인에 의해서도 연결돼 있다.
- DB 버퍼 캐시는 한번 읽은 데이터 블록을 캐싱해 두는 메모리 공간이지만 메모리는 유한한 자원이어서 모든 데이터를 캐싱할 수 없다.
- 모든 버퍼 블록 헤더를 LRU 체인에 연결해 사용빈도 순으로 위치를 옮겨가다가, Free 버퍼가 필요해질 때마다 액세스 빈도가 낮은 데이터 블록들을 우선하여 밀어냄으로써 자주 액세스되는 블록들이
  캐시에 더 오래 남아 있도록 관리한다.
#### ✅ LRU 리스트에는 내부적으로 두 개의 리스트를 갖는다.
#### - Dirty 리스트 : 캐시 내에서 변경됐지만, 아직 디스크에 기록되지 않은 Dirty 버퍼 블록들을 관리하며, 'LRUW(LRU Write) 리스트'라고도 한다.
#### - LRU 리스트 : 아직 Dirty 리스트로 옮겨지지 않은 나머지 버퍼 블록들을 관리한다.
- 모든 버퍼 블록은 이 둘 중 하나에 반드시 속하지만 읽기 또는 쓰기 작업을 위해 액세스되는 동안에는 리스트에서 잠시 풀려나왔다가 다시 원래의 리스트로 연결되거나,
  최초 변경이 발생하였을 때는 Dirty 리스트로 옮겨간다.
- LRU 리스트를 보호하기 위해 사용하는 래치를 cache bufferes lru chain 래치라고 한다.

#### ✅ 버퍼 상태
모든 캐시 버퍼는 아래 세 가지 중 하나의 상태에 놓이게 된다.
- **Free 버퍼**
    - 인스턴스 기동 후 아직 데이터가 읽히지 않아 비어 있는 상태(Clean 버퍼)이거나, 데이터가 담겼지만 데이터파일과 서로 동기화돼 있는 상태여서 언제든지 덮어 써도 무방한 버퍼 블록을 말한다.
      오라클이 데이터 파일로부터 새로운 데이터 블록을 로딩하려면 먼저 Free 버퍼를 확보해야 한다. Free 상태인 버퍼에 변경이 발생하면 그 순간 Dirty 버퍼로 상태가 바뀐다.
- **Dirty 버퍼**
    - 버퍼에 캐시된 이후 변경이 발생했지만, 아직 디스크에 기록되지 않아 데이터 파일 블록과 동기화가 필요한 버퍼 블록을 말한다.
      이 버퍼 블록들이 다른 데이터 블록을 위해 재사용되려면 디스크에 먼저 기록되어야 하며, 디스크에 기록되는 순간 Free 버퍼로 상태가 바뀐다.
- **Pinned 버퍼**
    - 읽기 또는 쓰기 작업을 위해 현재 액세스되고 있는 버퍼 블록을 말한다.