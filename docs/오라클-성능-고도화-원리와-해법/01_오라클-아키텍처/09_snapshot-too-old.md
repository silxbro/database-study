# 09. snapshot too old

snapshot too old(ORA-01555)에 대한 정보를 조회해 보면 그 발생원인을 여러 가지로 나누어 설명하고 있는데, 요약하면 두 가지로 정리할 수 있다(Undo 세그먼트가 손상되는 등의 물리적인 원인은 제외).
- 첫째, 데이터를 읽어 내려가다가 쿼리 SCN 이후에 변경된 블록을 만나(이미 앞서 읽었던 블록을 다시 방문하는 경우일 수도 있음) 과거 시점으로 롤백한 'Read Consistent' 이미지를 얻으려고 하는데,
  Undo 블록이 다른 트랜잭션에 의해 이미 재사용돼 필요한 Undo 정보를 얻을 수 없는 경우다. 프로그램 코딩 패턴에 문제가 없다면 Undo 세그먼트가 너무 작다는 신호일 수 있다.
- 둘째, 커밋된 트랜잭션 테이블 슬롯이 다른 트랜잭션에 의해 재사용돼 커밋 정보를 확인할 수 없는 경우로서, Undo 세그먼트 개수가 적다는 신호일 수 있다.

<br/>

## (1) Undo 실패
Undo 블록을 찾을 수 없어 에러가 발생하는 경우부터 살펴보자. 고객별 미납금액을 계산하는 아래 쿼리가 1시간쯤 걸린다고 가정하자.
```
SELECT /*+ ordered use_n1(b) */ A.고객ID
    , NVL(SUM(과금액), 0) 과금액
    , NVL(SUM(수금액), 0) 수금액
    , NVL(SUM(과금액), 0) - NVL(SUM(수금액), 0) 미납액
FROM   과금 A, 수납 B
WHERE  A.과금년월 = :과금년월
AND    A.과금유형 = :과금유형
AND    A.고객ID  = B.고객ID(+)
AND    A.과금년월 = B.수납년월(+)
GROUP BY A.고객ID
```
- (1) SCN 123 시점에 이 쿼리가 시작되었다.
- (2) 쿼리가 진행되는 동안 은행으로부터 고객의 입금내역을 전송받아 일괄 처리하는 배치 프로그램이 수행되었는데, 프로그램은 각 건별로 커밋하도록 작성되었다.
  이 프로그램이 돌기 시작한지 얼마 지나지 않아 홍길동 고객의 수납액을 10,000원에서 20,000원으로 변경하고 나서 커밋하였다. 이때, 블록 SCN은 129로 변경되었다.
- (3) 시간이 흘러 홍길동 고객의 수납액 변경내역(수납액 10,000 → 20,000)을 담은 Undo 블록이 다른 트랜잭션에 의해 재사용되었다.
- (4) 위 쿼리를 수행 중인 프로세스가 홍길동 고객의 수납액이 담긴 블록에 도달했을 때, 블록 SCN이 자신의 쿼리 SCN보다 큰 129임을 확인하고, 변경된 undo 레코드를 찾으려고 ITL 엔트리에 기록된
  UBA를 읽어 Undo 세그먼트 블록을 찾아간다.
- (5) 하지만 Undo 블록은 이미 다른 트랜잭션에 의해 재사용된 상태이므로 ORA-01555 에러를 발생시키며 진행을 멈춘다.

쿼리문에 ordered와 use_nl 힌트를 사용한 것에 주목하자.
대량의 데이터를 기준(driving 테이블. 여기서는 과금 테이블)으로 Nested Loop 조인을 하며 쿼리 수행시간이 오래 걸릴 뿐 아니라 inner 테이블(여기서는 수납 테이블)에 대해 같은 블록을 반복해서 방문할 가능성이 커진다.

여러 세션에서 동시에 트랜잭션이 몰리지 않더라도 아래와 같은 프로그램이 한 세션에서 독립적으로 수행되는 도중에 Snapshot too old 에러가 발생할 수도 있다.
```
for C in (select /*+ ordered use_nl(b) */ A.고객ID, A.입금액, B.수납액
          from    은행입금 A, 수납 B
          where   A.입금일자 = trunc(sysdate)
          and     B.수납년월(+) = to_char(sysdate, 'yyyymm')
          and     B.고객ID(+) = A.고객ID )
loop
   if C.수납액 IS NULL then
     insert into 수납(고객ID, 수납년월, 수납액)
          values (C.고객ID, to_char(sysdate, 'yyyymm'), C.입금액)  ;
   else
     update 수납 set 수납액 = 수납액 + C.입금액
     where  고객ID = C.고객ID
     and    수납년월 = to_char(sysdate, 'yyyymm') ;
   end if;
   commit;
end loop;
```
- (1) SCN 100 시점에 커서 C를 오픈한다.
- (2) 11 ~ 13번 라인 update 문에 의해 홍길동 고객의 수납액이 변경되고 15번 라인에서 커밋된다. 이때, 변경된 레코드가 담긴 500번 블록 SCN이 120으로 변경되었다.
  프로그램 내에서 커밋을 반복하기 때문에 위 insert문과 update문은 모두 개별 트랜잭션으로 처리된다.
- (3) 트랜잭션이 반복되다가 홍길동 고객의 수납액 Before Image가 담긴 Undo 블록이 다른 트랜잭션에 의해 재사용되었다. 물론 이 트랜잭션도 위 프로그램 내에서 수행된 update 또는 insert 문일 것이다.
- (4) 커서 C가 Fetch하다가 고객 홍길동의 수납정보와 같이 500번 블록에 저장된 김철수 수납정보에 도달한다.
  커서 C가 Nested Loop 방식으로 수행된다면 쿼리 수행 도중 같은 블록을 여러 차례 재방문하는 일은 흔히 발생한다.
  500번 블록 SCN이 120임을 확인하고 자신의 쿼리 SCN 100 시점으로 롤백하려고 Undo 블록을 찾아간다.
- (5) 하지만 Undo 블록은 이미 앞선 트랜잭션에 의해 재사용된 상태이므로 ORA-01555 에러를 발생시키며 진행을 멈춘다.

위와 같은 코딩 패턴을 'fetch across commit'이라고 한다. 명시적으로 커서를 열어 로우를 하나씩 Fetch 하면서 값을 변경하고 루프 내에서 계속해서 커밋을 날리는 방식이다.
ANSI 표준에 따르면 열려 있떤 커서는 커밋하는 시점에 무효화되어야 하므로 사용자는 계속해서 Fetch를 해서는 안 된다.
오라클은 ANSI 표준에도 불구하고 사용자가 fetch across commit을 할 수 있도록 허용하고 있지만, 그렇게 할 경우 에러가 발생할 수 있다는 사실을 인지한 상태에서 프로그램을 작성해야 한다.

<br/>

## (2) 블록 클린아웃 실패
트랜잭션 테이블 슬롯이 재사용돼 에러가 발생하는 경우를 살펴보자.

대량 업데이트 후에 커밋된 트랜잭션은 변경했던 블록들을 모두 클린아웃하지 않은 상태에서 자신이 사용하던 트랜잭션 테이블 슬롯을 Free 상태로 변경하고 트랜잭션을 완료한다.
이때부터 그 트랜잭션 테이블 슬롯은 다른 트랜잭션에 의해 재사용될 수 있다.
시간이 흘러 그 변경된 블록들이 읽혀야 하는 시점에 Delayed 블록 클린아웃을 위해 트랜잭션 테이블 슬롯을 찾아갔는데, **해당 슬롯이 다른 트랜잭션에 의해 이미 재사용되고 없다면 정상적인 블록 클린아웃과
일관성 모드(Consistent Mode) 읽기가 불가능해질 수 있다.**

오라클은 일반 데이터 블록과 마찬가지로 Undo 세그먼트 헤더 블록을 갱신한 내용도 Undo 레코드로서 기록한다.
따라서 트랜잭션 테이블 슬롯이 덮어 쓰인 것을 발견하면 **우선 Undo 세그먼트 헤더 블록에 가해진 변경사항을 롤백하려고 시도한다.**
다행히 찾고자 하는 트랜잭션에 대한 커밋 정보가 Undo 블록에 남아있다면 현재 읽고자 하는 블록의 정확한 커밋 SCN을 가지고 블록 클린아웃을 수행할 수 있다.

하지만 Undo 레코드를 뒤졌는데 그마저도 덮어 쓰이고 없는 상태라면 어떻게 해야 할까?

Delayed 블록 클린아웃에 의한 Snapshot too old 문제를 잘못 이해하면 이 처리 프로세스에 치명적인 결함이 있다고 오해하기 쉽다.
클린아웃에 필요한 트랜잭션 테이블과 Undo 정보는 언젠가 필연적으로 덮어 쓰이기 마련인데, 갱신 후에 오랫동안 읽히지 않았던 블록이 언젠가 읽히면서 예외 없이 Snapshot too old가 발생한다고 생각할 수 있는 것이다.
하지만 블록 클린아웃에 의한 Snapshot too old 에러는 거의 발생하지 않는다.

트랜잭션 슬롯이 필요해지면 커밋 SCN이 가장 낮은 트랜잭션 슬롯부터 재사용하는데, 그 슬롯에 기록돼 있던 커밋 SCN을 Undo 세그먼트 헤더에 '최저 커밋 SCN(low commit SCN)'으로서 기록해 둔다.
트랜잭션 슬롯이 재사용되고 나면 그 슬롯을 사용하던 이전 트랜잭션의 정확한 커밋 SCN을 확인하는 것이 불가능해 지지만 Undo 세그먼트 헤더에 기록돼 있는 '최저 커밋 SCN' 이전에 커밋 되었다는 사실만큼은
짐작할 수 있다.
따라서 아직 클린아웃되지 않은 블록을 클린아웃하려고 ITL이 가리키는 트랜잭션 테이블 슬롯을 찾아갔을 때 커밋 정보가 이미 지워지고 없으면, Undo 세그먼트 헤더에 있는 '최저 커밋 SCN'을
블록 ITL 엔트리에 커밋 SCN으로서 기록('추정된 커밋 SCN'임을 표시하기 위해 ITL 슬롯 커밋 Flag에 C--- 대신 C-U-라고 기록)함으로써 블록 클린아웃을 마무리하고, 블록 SCN도 변경한다.

문제는 클린아웃 시점에 일관성(Consistent) 모드 읽기가 가능한지 여부일 텐데, 쿼리가 진행되는 동안에 많은 트랜잭션이 한꺼번에 몰리지만 않는다면 '최저 커밋 SCN'이 갑자기 많이 증가하지는 않을 것이므로
'최저 커밋 SCN'에 의해 추정된 블록 SCN은 대개 쿼리 SCN보다 작다. 따라서 쿼리가 시작된 이후에 해당 블록에 변경이 가해지지 않았음이 확인되므로 정상적인 일관성 모드 읽기도 가능하다.

결론적으로 Delayed 블록 클린아웃에 의해 Snapshot too old가 발생하는 원인은, '최저 커밋 SCN'이 쿼리 SCN보다 높아질 정도로 갑자기 트랜잭션이 몰리는 데에 있으며,
이때는 추정에 의한 블록 SCN이 쿼리 SCN보다 높아지게 된다.
실제로 이 에러를 발생시킨 블록은 훨씬 오래전 시점(1년 또는 10년 전)에 커밋된 것일 수 있지만 이를 확인할 방법이 없으며, 그동안 한 번도 읽히지 않다가 불행하게도 트랜잭션이 몰리는 시점에 읽히다 보니
문제를 유발하게 되는 것이다.

<br/>

## (3) Snapshot too old 회피 방법
Snapshot too old 에러를 만나면 난감하기 그지없다. 사실상 이 에러는 재현이 어려워 문제의 발생 원인을 찾는 것부터 쉽지 않다.
같은 환경에서 같은 프로그램을 돌려도 어떤 때는 에러가 발생하고 어떤 때는 발생하지 않는다. 잘 알려진 조치방법들도 확률을 낮출 뿐이며 그 가능성을 0%로 만드는 것은 아니다.
Undo 메커니즘을 도입한 배경으로 거슬러 올라가면 결국 Lock에 의한 동시성 저하를 방지하려는 것인데, 동시성을 높인 대신 얻은 부작용(side effect) 정도로 이해해야 할 것이다.

과거 버전에서는 Undo 세그먼트를 수동으로 관리했기 때문에 Snapshot too old 에러 발생을 최소화하기 위해 시스템과 애플리케이션 특성에 맞는 Undo 튜닝을 DB 관리자가 직접 해야만 했다.
9i부터는 AUM(Automatic Undo Management)이 도입돼 트랜잭션 발생 상황에 따라 Undo 세그먼트 크기와 개수를 오라클이 동적으로 자동 조절해 주기 때문에 DBA의 수고가 많이 줄었고
Snapshot too old 에러가 발생할 가능성도 확실히 줄었다.
DBA가 할 일이라고는 커밋된 Undo 정보가 충분히 오랫동안 보존될 수 있을 정도(가장 오랜 시간 수행되는 쿼리 기준으로 판단)의 큰 Undo Space를 준비해 주는 것이 고작이다.
9i에서 도입된 undo_retention 기능까지도 10g부터는 오라클이 알아서 스스로 튜닝해 주고 있다.

컨설팅을 하다 보면 AUM이 못 미더워 여전히 8i에서처럼 수동 방식으로 Undo를 관리하는 DBA를 가끔 만난다.
그리고 실제 DB를 운영하다 보면 여전히 다양한 이유 때문에 Undo와 관련한 성능 저하 및 장애 상황이 발생하기도 한다(이 중 상당수는 버그임).
하지만 과거에 DBA들이 Snapshot too old 방지를 위해 Undo 개수와 크기를 조정하는 등의 방법들은 거의 불필요한 것이 돼 버렸다.

그런데 AUM 하에서 충분한 크기의 Undo Space를 할당하는 것만으로 Snapshot too old 에러가 완전히 해결된 것은 아니다.
DB 관리자 측면에서의 Undo 튜닝 노력은 많이 해소되었지만, 애플리케이션 구현 측면에서의 노력은 여전히 필요하다. 이 에러가 종종 발생한다면 프로그램 로직을 분석해서 가능성 있는 부분들을 고쳐 주어야 한다.
이를 위해 지금까지 설명한 오라클만의 독특한 읽기 일관성 모델과 Undo 메커니즘을 이해하는 것이 필수적이다.

Snapshot too old 에러 발생 가능성을 줄이기 위한 애플리케이션 측면에서의 솔루션들을 몇 가지 소개하겠다.

- (1) 불필요하게 커밋을 자주 수행하지 않는다.
- (2) fetch across commit 형태의 프로그램 작성을 피해 다른 방식으로 구현한다. ANSI 표준에 따르면 커밋 이전에 열려 있던 커서는 더는 Fetch하면 안 된다.
  다른 방식으로 구현하기 어렵다면 커밋 횟수를 줄여본다.
- (3) 트랜잭션이 몰리는 시간대에 오래 걸리는 쿼리가 같이 수행되지 않도록 시간을 조정한다.
- (4) 큰 테이블을 일정 범위로 나누어 읽고 단계적으로 실행할 수 있도록 코딩한다. Snapshot too old 발생 가능성을 줄일 뿐 아니라 문제가 발생했을 때 특정 부분부터 다시 시작할 수도 있어 유리하다.
  물론 그렇게 해도 읽기 일관성에 문제가 없을 때에만 적용해야 한다.
- (5) 오랜 시간에 걸쳐 같은 블록을 여러 번 방문하는 Nested Loop 형태의 조인문 또는 인덱스를 경유한 테이블 액세스를 수반하는 프로그램이 있는지 체크하고, 이를 회피할 수 있는 방법
  (조인 메소드 변경, Full Table Scan 등)을 찾는다.
- (6) 소트 부하를 감수하더라도 order by 등을 강제로 삽입해 소트연산이 발생하도록 한다.
  많은 데이터를 오랜 시간에 걸쳐 Fetch 하는 동안 Undo 정보를 지속적으로 참조하기 때문에 문제가 발생하는 것이므로, 서버 내에서 빠르게 데이터를 읽어 Temp 세그먼트에 저장하는 데에만 성공하면
  이후에는 같은 블록을 아무리 재방문하더라도 더는 에러가 발생할까 걱정하지 않아도 된다.
- (7) 만약 delayed 블록 클린아웃에 의해 Snapshot too old가 발생하는 것으로 의심되면 대량 업데이트 후에 곧바로 해당 테이블에 대해 Full Scan 하도록 쿼리를 날리는 것도 하나의 해결방법이 될 수 있다.

  ```
  select /*+ full(t) */ count(*) from table_name t
  ```

  만약 인덱스 블록에서 문제가 발생한다고 판단되면 인덱스 리프 블록을 모두 스캔하도록 쿼리한다. 예를 들어, index_column이 숫자형 컬럼이고 0보다 큰 값을 갖는다면 대량 업데이트 후에 아래와 같은 쿼리를 날린다.

  ```
  select count(*) from table_name where index_column > 0
  ```