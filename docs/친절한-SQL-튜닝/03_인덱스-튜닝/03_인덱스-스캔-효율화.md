# 3.3 | 인덱스 스캔 효율화

IOT, 클러스터, 파티션은 테이블 랜덤 액세스를 최소화하는 데 매우 효과적인 저장 구조이지만, 운영 시스템 환경에서 이를 적용하려면 성능 검증을 위해 많은 테스트를 진행해야 하므로 어려움이 따른다.
시스템 개발 단계에서 물리 설계가 중요한 이유다.

운영 환경에서 가능한 일반적인 튜닝 기법은 인덱스 컬럼 추가다. 테이블 랜덤 액세스 최소화가 SQL 성능에 미치는 영향이 매우 크지만, 튜닝 기법은 의외로 단순하다고 느낄 것이다.

반면, 지금부터 학습할 인덱스 스캔 효율화는 튜닝 요소가 매우 다양하다. 인덱스 설계 공식을 이루는 주요 원리도 인덱스 스캔 효율화에서 비롯된다.
인덱스 튜닝에 흥미를 느낄만한 요소가 많고, SQL 작성할 때 주의할 내용을 많이 포함하므로 꼼꼼히 학습하기 바란다.

<br/>

## (1) 인덱스 탐색
인덱스 수직적 탐색과 수평적 탐색에 대해서는 이미 다뤘지만, 인덱스 스캔 효율화 튜닝을 이해하려면, 인덱스 탐색 과정을 좀 더 깊이 있게 다룰 필요가 있다. [그림 3-19] 인덱스를 통해 살펴보자.

루트 블록에 (C1, C2) 컬럼이 각각 (A, 3), (B, 3), (C, 2)인 세 개 레코드가 있다. 따로 표시하진 않았지만, 각 레코드는 하위 노드를 가리키는 블록 주소를 갖는다.
자신이 가리키는 주소(화살표)로 찾아간 블록에는 자신의 키 값보다 크거나 같은 값을 갖는 레코드가 저장돼 있음을 의미한다.

루트 블록에는 키 값을 갖지 않는 특별한 레코드가 하나 있다. 가장 왼쪽에 있는 'LMC(Leftmost Child)' 레코드다. LMC는 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킨다.
LMC가 가리키는 주소로 찾아간 블록에는 '키값을 가진 첫 번째 레코드보다 작거나 같은 값'을 갖는 레코드가 저장돼 있다.

그럼, 이 인덱스에서 아래 여섯 개 조건절을 처리할 때, 리프 블록 어느 지점에서 스캔을 시작하고 어느 지점에서 멈추는지를 각각 화살표로 그려보자.
```
< 조건절 1 >
WHERE C1 = 'B'

< 조건절 2 >
WHERE C1 = 'B'
AND   C2 = 3

< 조건절 3 >
WHERE C1 = 'B'
AND   C2 >= 3

< 조건절 4 >
WHERE C1 = 'B'
AND   C2 <= 3

< 조건절 5 >
WHERE C1 = 'B'
AND   C2 BETWEEN 2 AND 3

< 조건절 6 >
WHERE C1 BETWEEN 'A' AND 'C'
AND   C2 BETWEEN 2 AND 3
```
- 조건절 1의 스캔 시작점과 끝점을 찾아보자. 수직적 탐색을 통해 C1 = 'B'인 첫 번째 레코드를 찾고, 'C'를 만나는 순간 스캔을 멈춘다.
  주의할 점은, 루트 블록 스캔 과정에 C1 = 'B'인 레코드를 찾았을 때 그것이 가리키는 리프 블록 3으로 내려가면 안 된다. 그 직전(C1 = 'A') 레코드가 가리키는 리프 블록 2로 내려가야 한다.
  C1 = 'B'인 레코드가 가리키는 리프 블록 3으로 내려가도 조건을 만족하는 데이터를 만날 수 있지만, 거기가 스캔 시작점은 아니다. 다시 강조하지만, 수직적 탐색은 스캔 시작점을 찾는 과정이다.

- 조건절 2의 스캔 시작점과 끝점을 찾아보자. 수직적 탐색을 통해 C1 = 'B'이고 C2 = 3인 첫 번째 레코드를 찾고, C1 = 'B'인 레코드 중에서 C2 = 4인 레코드를 만나는 순간 스캔을 멈춘다.
  C1과 C2 조건절 모두 스캔 시작과 끝 지점을 결정하는 데 중요한 역할을 했다. 즉, 스캔량을 줄이는 데 역할을 했다.
  여기서도 루트 블록 스캔 과정에 C1 = 'B'이고 C2 = 3인 레코드를 찾았다고 거기서 가리키는 리프 블록 3으로 내려가면 안 된다. 그 직전 레코드가 가리키는 리프 블록 2로 내려가야 한다.

- 조건절 3의 스캔 시작점과 끝점을 찾아보자. 수직적 탐색을 통해 C1 = 'B'이고 C2 >= 3인 첫 번째 레코드를 찾고, C1 = 'C'인 레코드를 만날 때까지 스캔하다가 멈춘다.
  C2 >= 3 조건절이 스캔을 멈추는 데는 역할을 전혀 못 하지만, 이 조건절로 인해 조건절 1과 스캔 시작점이 달라진 데 주목하자.
  부등호 조건이지만 수직적 탐색 과정에 사용됨으로써 스캔 시작점을 결정하는 데 중요한 역할을 했다. 즉, 스캔량을 줄이는 데 역할을 했다.

- 조건절 4의 스캔 시작점과 끝점을 찾아보자. 수직적 탐색을 통해 C1 = 'B'인 첫 번째 레코드를 찾고, 거기서부터 스캔하다가 C2 > 3인 첫 번째 레코드를 만나는 순간 스캔을 멈춘다.
  C2 <= 3 조건절은 수직적 탐색 과정에 전혀 쓰이질 않았다. 스캔 시작점을 결정하는 데 전혀 역할을 못했지만, 스캔을 멈추는 데는 중요한 역할을 했다. 즉, 스캔량을 줄이는 역할을 했다.

- 조건절 5의 스캔 시작점과 끝점을 찾아보자. 수직적 탐색을 통해 C1 = 'B'이고 C2 >= 2인 첫 번째 레코드를 찾고, C2 > 3인 첫 번째 레코드를 만나는 순간 스캔을 멈춘다.
  여기서는 C1과 C2 조건절 모두 스캔 시작과 끝 지점을 결정하는 데 중요한 역할을 했다. 즉, 스캔량을 줄이는 역할을 했다.

- 조건절 6의 스캔 시작점과 끝점을 찾아보자. 수직적 탐색을 통해 C1 >= 'A'이고 C2 >= 2인 첫 번째 레코드에서 스캔을 시작하고, C1 = 'C'이고 C2 = 3인 레코드보다 값이 큰 레코드
  (두 컬럼 모두 한 자릿수라고 할 때, C1 || C2 > 'C3'인 레코드)를 만나는 순간 스캔을 멈춘다. C1 조건절은 스캔 시작과 끝 지점을 결정하는 데 중요한 역할을 했지만, C2는 그렇지 못하다.
  맨 앞 C1 = 'A'인 구간과 맨 뒤 C1 = 'C' 구간에서는 어느 정도 역할을 했지만, 중간 C1 = 'B' 구간에서는 전혀 역할을 못했다. 즉, C2는 스캔량을 줄이는 데 거의 역할을 못 했다.

<br/>

## (2) 인덱스 스캔 효율성
[그림 3-26]과 같은 용어사전이 있다. 용어사전이므로 당연히 가나다 순으로 정렬된 상태다. 앞뒤로 훨씬 더 많은 용어가 있지만, '성능'과 관련된 용어만 보여주고 있다.

- <질문 1> 그림 3-26에서 '성능검'으로 시작하는 용어를 검색하고자 할 때 어디서 스캔을 시작하고 어디서 멈출까?
  - '성능검'으로 시작하는 용어를 검색할 때는 '성능검사'에서 스캔을 시작한다. 가나다 순으로 정렬돼 있으므로 바로 이 지점으로 찾아갈 수 있다.
    가나다 순으로 정렬돼 있으므로 끝까지 안 읽고 멈출 수도 있다. 용어가 '성능계수'인 지점에서 멈추면 된다. '성능검'으로 시작하는 용어가 더 없음을 확인하려니 '성능계수'까지 읽은 것이다.
    두 건을 얻기 위해 총 세 건을 읽었다.

- <질문 2> 이번에는 '성능'으로 시작하고 네 번째 문자가 '선'인 용어를 검색해 보자. 어디서 스캔을 시작하고 어디서 멈출까?
  - '성능'으로 시작하고 네 번째 문자가 '선'인 용어를 검색할 때는 '성능'으로 시작하는 용어를 모두 스캔한다. 결과는 똑같이 두 건이지만, <질문 1>의 경우보다 훨씬 더 많은 용어를 스캔해야만 한다.

이번에는 각 문자를 잘라서 테이블 컬럼에 각각 저장하고, C1 + C2 + C3 + C4 순으로 인덱스를 생성해 보자.

- <질문 3> 이 테이블에서 '성능검'으로 시작하는 레코드를 검색하려면, 아래와 같은 조건절을 사용한다. 이 조건절에 위 인덱스를 사용한다면, 어디서 스캔을 시작하고 어디서 멈출까?

  ```
  where c1 = '성'
  and   c2 = '능'
  and   c3 = '검'
  ```

  - '성능검'으로 시작하는 레코드를 검색할 때는 인덱스 수직적 탐색을 통해 '성능검사' 레코드로 찾아간다. 거기서 스캔을 시작해 '성능계수'까지 총 세 개 레코드를 스캔하고 멈춘다.
    두 건을 얻기 위해 세 건을 스캔했다.

- <질문 4> '성능'으로 시작하고 네 번째 컬럼이 '선'인 레코드를 검색하려면, 아래와 같은 조건절을 사용한다. 이 조건절에 위 인덱스를 사용한다면, 어디서 스캔을 시작하고 어디서 멈출까?

  ```
  where c1 = '성'
  and   c2 = '능'
  and   c4 = '선'
  ```

  - '성능'으로 시작하고 네 번째 컬럼이 '선'인 레코드를 검색할 때는 '성능'으로 시작하는 레코드를 모두 스캔한다. 결과는 똑같이 두 건이지만, <질문 3>의 경우보다 훨씬 더 많은 인덱스 레코드를 스캔해야만 한다.

인덱스 스캔을 통해 얻은 결과 건수는 똑같은데 왜 이처럼 인덱스 리프 블록에서 스캔하는 레코드 개수에 차이가 생기는 걸까? 왜 효율성에 차이가 나는 걸까? 구체적으로, 왜 후자는 전자보다 들인 노력에 비해 얻은 결과가 적을까?

인덱스 선행 컬럼이 조건절에 없기 때문이다. **인덱스 선행 컬럼이 조건절에 없거나 '=' 조건이 아니면 인덱스 스캔 과정에 비효율이 발생한다.**

### [인덱스 스캔 효율성 측정]
인덱스 스캔 효율이 좋은지 나쁜지는 어떻게 알 수 있을까? 조건절 데이터를 일일이 조회해 보는 방법도 있지만, SQL 트레이스를 통해 쉽게 알 수 있다.
```
Rows    Row Source Operation
------- -----------------------------------------------------------------------------------------
     10 TABLE ACCESS BY INDEX ROWID BIG_TABLE (cr=7471 pr=1466 pw=0 time=22137 us)
     10   INDEX RANGE SCAN BIG_TABLE_IDX (cr=7463 pr=1466 pw=0 time=22328 us)
```
위 트레이스를 분석해 보면, 인덱스를 스캔하고 얻은 레코드가 열 개인데, 그 과정에 7,463개 블록(cr=7463)을 읽었다는 사실을 알 수 있다.
한 블록당 평균 500개 레코드가 담긴다고 가정하면, 3,731,500(=7,463✕500)개 레코드를 읽은 셈이다. 그 많은 데이터를 읽고 열 개를 얻었다니 이만저만한 비효율이 아니다.

- #### [선두 컬럼, 선행 컬럼]

  생각하기에 따라 같은 용어라고 해석될 수 있지만 서로 헷갈리지 않도록 용어를 정리해 보자.
  앞으로 '선두 컬럼'은 인덱스 구성상 '맨 앞쪽'에 있는 컬럼을 지칭할 때 사용하고, '선행 컬럼'은 어떤 컬럼보다 '상대적으로 앞쪽'에 놓인 컬럼을 칭할 때 사용하기로 하자.

<br/>

## (3) 액세스 조건과 필터 조건
인덱스 스캔 효율성을 계속 설명하기에 앞서 반드시 이해해야 할 용어 두 가지가 있다. '액세스 조건'과 '필터 조건'이다.

인덱스를 스캔하는 단계에 처리하는 조건절은 액세스 조건과 필터 조건으로 나뉜다. 인덱스 액세스 조건은 인덱스 스캔 범위를 결정하는 조건절이다.
인덱스 수직적 탐색을 통해 스캔 시작점을 결정하는 데 영향을 미치고, 인덱스 리프 블록을 스캔하다가 어디서 멈출지를 결정하는 데 영향을 미치는 조건절이다.
인덱스 필터 조건은 테이블로 액세스할지를 결정하는 조건절이다.

인덱스를 이용하든, 테이블을 Full Scan 하든, 테이블 액세스 단계에서 처리되는 조건절은 모두 필터 조건이다. 테이블 필터 조건은 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함할지를 결정한다.
- #### [옵티마이저의 비용 계산 원리]

  인덱스를 이용한 테이블 액세스 비용은 항상 아래 공식으로 구한다.

  > 비용 = 인덱스 수직적 탐색 비용 + 인덱스 수평적 탐색 비용 + 테이블 랜덤 액세스 비용
  >
  >  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 인덱스 루트와 브랜치 레벨에서 읽는 블록 수 +
  >
  >  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인덱스 리프 블록을 스캔하는 과정에 읽는 블록 수 +
  >
  >  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블 액세스 과정에 읽는 블록 수


<br/>

## (4) 비교 연산자 종류와 컬럼 순서에 따른 군집성
테이블과 달리 인덱스에는 '같은 값'을 갖는 레코드들이 서로 군집해 있다.
'같은 값'을 찾을 때 '=' 연산자를 사용하므로 인덱스 컬럼을 앞쪽부터 누락없이 '=' 연산자로 조회하면 조건절을 만족하는 레코드는 모두 모여 있다.
어느 하나를 누락하거나 '=' 조건이 아닌 연산자로 조회하면 조건절을 만족하는 레코드가 서로 흩어진 상태가 된다.

- ```
  < 조건절 1 >
  where C1 = 1
  and   C2 = 'A'
  and   C3 = '나'
  and   C4 = 'a'
  ```
  - 인덱스 구성 컬럼을 모두 '=' 조건으로 비교할 떄는 조건을 만족하는 레코드들이 모두 연속해서 모여 있다.

- ```
  < 조건절 2 >
  where C1 = 1
  and   C2 = 'A'
  and   C3 = '나'
  and   C4 >= 'a'
  ```
  - 선행 컬럼은 모두 '='이고 맨 마지막 컬럼만 범위검색 조건(부등호, BETWEEN, LIKE)일 때도 조건을 만족하는 레코드가 서로 모여 있다.

만약 맨 마지막 컬럼이 아닌 중간 컬럼이 범위검색 조건일 때는 어떻게 되는지 살펴보자.

- ```
  < 조건절 3 >
  where C1 = 1
  and   C2 = 'A'
  and   C3 between '가' and '다'
  and   C4 = 'a'
  ```
  - 세 번째 컬럼 C3가 범위검색 조건인 경우는 C1부터 C3까지 세 조건을 만족하는 인덱스 레코드는 서로 모여 있지만, C4 조건까지 만족하는 레코드는 흩어지게 된다.

- ```
  < 조건절 4 >
  where C1 = 1
  and   C2 <= 'B'
  and   C3 = '나'
  and   C4 between 'a' and 'b'
  ```
  - 두 번째 컬럼 C2가 범위검색 조건인 경우는 C1부터 C2까지 두 조건을 만족하는 인덱스 레코드는 서로 모여 있지만, C3과 C4 조건까지 만족하는 레코드는 흩어지게 된다.

여기서 우리는 한 가지 규칙을 발견할 수 있다.
선행 컬럼이 모두 '=' 조건인 상태에서 첫 번째 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드는 모두 연속해서 모여 있지만, 그 이하 조건까지 만족하는 레코드는 비교 연산자 종류에 상관없이 흩어진다.
(우연히 모여 있을 수는 있음)

- ```
  < 조건절 5 >
  where C1 between 1 and 3
  and   C2 = 'A'
  and   C3 = '나'
  and   C4 = a'
  ```
  - 선두 C1 컬럼이 범위검색 조건일 경우 C1 조건을 만족하는 레코드는 서로 모여 있고, 나머지 조건까지 만족하는 레코드는 비교 연산자 종류에 상관없이 흩어지게 된다.

앞서 인덱스 스캔 범위를 결정하는 조건절이 인덱스 액세스 조건이라고 설명한 것을 상기하자. 선행 컬럼이 모두 '=' 조건인 상태에서 첫 번째 나타나는 범위검색 조건이 인덱스 스캔 범위를 결정한다.
만약 가장 선두 컬럼이 범위검색 조건이면, 그 조건이 스캔 범위를 결정한다. 따라서 이들 조건이 인덱스 액세스 조건이다. 나머지 인덱스 컬럼 조건은 모두 인덱스 필터 조건이다.

- #### [범위검색 조건 맨 처음과 마지막 구간에서의 액세스 조건]

  사실 조건절 5에서 C2, C3, C4도 인덱스 스캔량을 줄이는 데 어느 정도 역할을 한다. C1 = 1인 구간과 C1 = 3인 구간에서 그렇다.
  아래 조건을 만족하는 첫 번째 레코드를 찾아 수직적 탐색하므로 C1 = 1 구간에서 스캔 범위를 줄이는 역할을 한다.

  ```
  where C1 >= 1 and C2 = 'A' and C3 = '나' and C4 = 'a'
  ```

  아래 조건보다 큰 값을 만나는 순간 멈추므로 C1 = 3 구간에서도 스캔 범위를 줄이는 역할을 한다.

  ```
  where C1 <= 3 and C2 = 'A' and C3 = '나' and C4 'a'
  ```

  마찬가지로, 조건절 3과 4의 필터 조건도 범위검색 조건 맨 처음과 마지막 구간에서는 스캔량을 줄이는 데 역할을 한다. 하지만, 대개 무시할만한 수준이다.

  오라클은 실행계획 하단에 아래와 같이 액세스 조건과 필터 조건을 정리해서 보여주는데, 조건절 5를 테스트해 보면 C2, C3, C4 컬럼이 액세스 조건에 포함되는 이유가 바로 여기에 있다.

  ```
  Predicate information (identified by operation id):
  -------------------------------------------------------------------------
  2 - access("C1">=1 AND "C2"='A' AND "C3"='나' AND "C4"='a' AND "C1"<=3)
  2 - filter("C2"='A' AND "C3"='나' AND "C4"='a')
  ```
  결국, 아래 몇 가지 케이스를 제외하면, 인덱스 컬럼에 대한 조건절은 모두 액세스 조건에 표시된다. 첫 번째 나타나는 범위검색 조건 이후 조건절 컬럼은 스캔 범위를 줄이는 데 큰 역할을 못 하는데도 말이다.
  - 좌변 컬럼을 가공한 조건절
  - 왼쪽 '%' 또는 양쪽 '%' 기호를 사용한 like 조건절
  - 같은 컬럼에 대한 조건절이 두 개 이상일 때, 인덱스 액세스 조건으로 선택되지 못한 조건절
  - OR Expansion 또는 INLIST ITERATOR로 선택되지 못한 OR 또는 IN 조건절

  액세스 조건과 필터 조건을 실행계획에 표시된 대로 이해하면 사실 이 둘을 구분할 이유가 없어진다.
  따라서 실행계획에 위와 같이 표시되더라도 복잡하게 생각하지 말고, **첫번째 나타나는 범위검색 조건까지가 인덱스 액세스 조건이고, 나머지는 필터 조건이라고 이해하자.**

<br/>

## (5) 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율
인덱스 스캔 효율성은 인덱스 컬럼을 조건절에 모두 등치(=) 조건으로 사용할 때가 가장 좋다.
리프 블록을 스캔하면서 읽은 레코드는 하나도 걸러지지 않고 모두 테이블 액세스로 이어지므로 인덱스 스캔 단계에서의 비효율은 전혀 없다.
인덱스 컬럼 중 일부가 조건절에 없거나 등치 조건이 아니더라도, 그것이 뒤쪽 컬럼일 때는 비효율이 없다.

반면, 인덱스 선행 컬럼이 조건절에 없거나 부등호, BETWEEN, LIKE 같은 범위검색 조건이면, 인덱스를 스캔하는 단계에서 비효율이 생긴다.

예를 들어, 인덱스를 [아파트시세코드 + 평형 + 평형타입 + 인터넷매물] 순으로 구성한 상황에서 아래 SQL을 수행하는 경우를 살펴보자.
```
select  해당층, 평당가, 입력일, 해당동, 매물구분, 연사용일수, 중개업소코드
from    매물아파트매매
where   인터넷매물 between '1' and '3'
and     아파트시세코드='A01011350900056'
and     평형 = '59'
and     평형타입 = 'A'
order by 입력일 desc
```
인터넷매물이 BETWEEN 조건이지만 선행 칼럼들(아파트시세코드, 평형, 평형타입)이 모두 '=' 조건이기 때문에 전혀 비효율 없이 조건을 만족하는 세 건을 빠르게 찾았다.
비효율이 전혀 없다는 것은 세 건을 찾기 위해 단 네 건만 스캔했음을 의미한다. 맨 마지막 스캔은 조건을 만족하는 레코드가 더 없음을 확인하기 위한 one-plus 스캔이므로 불가피하다.

인덱스 선행 컬럼이 모두 '=' 조건일 때 필요한 범위만 스캔하고 멈출 수 있는 있는 것은, 조건을 만족하는 레코드가 모두 한데 모여 있기 때문이다.

이제 인덱스 구성을 [인터넷매물 + 아파트시세코드 + 평형 + 평형타입] 순으로 바꾼 후 같은 SQL을 수행하면, 인덱스 스캔 범위가 넓어진다.
인덱스 선두 컬럼 인터넷매물에 BETWEEN 연산자를 사용하면 나머지 조건(아파트시세코드='A01011350900056' and 평형 = '59' and 평형타입 = 'A')을 만족하는 레코드들이
인터넷매물 값(0, 1, 2, 3)별로 뿔뿔이 흩어져 있게 된다. 따라서 조건을 만족하지 않은 레코드까지 스캔하고서 버리는 비효율이 생긴다.

다행스러운 것은 인터넷매물 BETWEEN 조건절 시작 값인 '1' 구간에서는 전체를 다 읽지 않고 조건을 만족하는 첫 번째 레코드부터 읽기 시작한다.
인터넷매물 BETWEEN 조건절 마지막 값인 '3' 구간에서도 전체를 다 읽지 않고 조건을 만족하는 보다 큰 값을 만나는 순간 스캔을 멈춘다.

하지만, 인터넷매물 BETWEEN 조건절 중간에 걸친 값 '2' 구간에서는 전체 레코드를 다 읽어야만 한다는 사실에 주목하자.

<br/>

## (6) BETWEEN을 IN-List로 전환
범위검색 컬럼이 맨 뒤로 가도록 인덱스를 [아파트시세코드 + 평형 + 평형타입 + 인터넷매물] 순으로 변경하면 좋겠지만 운영 시스템에서 인덱스 구성을 바꾸기는 쉽지 않다.
이럴 때 BETWEEN 조건을 아래와 같이 IN-List로 바꿔주면 큰 효과를 얻는 경우가 있다.
```
select  해당층, 평당가, 입력일, 해당동, 매물구분, 연사용일수, 중개업소코드
from    매물아파트매매
where   인터넷매물 in ('1', '2', '3')
and     아파트시세코드='A01011350900056'
and     평형 = '59'
and     평형타입 = 'A'
order by 입력일 desc
```
이때 인덱스 수직적 탐색이 세 번 (IN-List의 value 개수) 발생하며, 이때의 실행계획은 아래와 같다.(INLIST ITERATOR 오퍼레이션 주목).
```
-------------------------------------------------------------------------------------
| Id  | Operation                       | Name          |Starts | A-Rows | Buffers |
-------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                |               |      1 |      3 |      12 |
|   1 |   INLIST ITERATOR               |               |      1 |      3 |      12 |
|   2 |     TABLE ACCESS BY INDEX ROWID | 매물아파트매매    |      3 |      3 |      12 |
|   3 |       INDEX RANGE SCAN          | 매물아파트매매_PK |      3 |      3 |      10 |
-------------------------------------------------------------------------------------
```
dbms_xplan.dislay_cursor 함수를 이용해 Row Source별 수행 통계를 출력해 보면, 아래와 같이 Index Range Scan 단계(ID=3)의 Starts 항목이 3으로 나타난다.
이를 통해 인덱스를 세 번 탐색한다는 사실을 확인할 수 있다.
- [부록 4절] 캐싱된 커서의 Row Source별 수행 통계 출력 참조

인덱스를 세 번 탐색한다는 것은 IN-List 개수만큼 UNION ALL 브랜치가 생성되고 각 브랜치마다 모든 컬럼을 '=' 조건으로 검색하므로 앞서 선두 컬럼에 BETWEEN을 사용할 때와 같은 비효율이 사라진다.

Index Skip Scan 방식으로 유도해도 비슷한 효과를 얻을 수 있다.

IN-List 항목 개수가 늘어날 수 있다면(예를 들어, 인터넷 매물에 '1'과 '3' 사이에 다른 값 추가), BETWEEN을 IN-List로 전환하는 방식은 사용하기 곤란하다.
그럴 때는 아래처럼 NL 방식의 조인문이나 서브쿼리로 구현하면 된다. 물론 IN-List 값들을 코드 테이블로 관리하고 있을 때 가능한 방식이다. 인터넷매물을 '=' 조건으로 조인하고 있다는 데 주목하자.
```
select /*+ ordered use_nl(b) */ b.해당층, b.평당가, b.입력일
      , b.해당동, b.매물구분, b.연사용일수, b.중개업소코드
from    통합코드 a, 매물아파트매매 b
where   a.코드구분 = 'CD064'  -- 인터넷매물구분
and     a.코드 between '1' and '3'
and     b.인터넷매물 = a.코드  -- ***
and     b.아파트시세코드='A01011350900056'
and     b.평형 = '59'
and     b.평형타입 = 'A'
order by b.입력일 desc
```

### [BETWEEN 조건을 IN-List로 전환할 때 주의 사항]
BETWEEN 조건을 IN-List 조건으로 전환할 때 주의할 점은, IN-List 개수가 많지 않아야 한다는 것이다. IN-List 개수가 많으면 수직적 탐색이 많이 발생한다.
그러면 BETWEEN 조건 때문에 리프 블록을 많이 스캔하는 비효율보다 IN-List 개수만큼 브랜치 블록을 반복 탐색하는 비효율이 더 클 수 있다. 루트에서 브랜치 블록까지 Depth가 깊을 때 특히 그렇다.

인덱스 스캔 과정에 선택되는 레코드들이 서로 멀리 떨어져 있을 때만 유용하다는 사실도 기억하기 바란다.
- 아래 조건절로 말하면, [고객등급 + 고객번호] 순으로 구성한 인덱스에서 고객번호 = 123 조건을 만족하는 레코드가 서로 멀리 떨어져 있을 때만 BETWEEN 조건을 IN-List로 전환하는 기법이 유용하다.

  ```
  where 고객등급 between 'C' and 'D'
  and   고객번호 = 123
  ```

조건을 만족하는 레코드가 멀리 떨어져 있을 경우, 인덱스 리프 블록을 많이 스캔해야 한다. 이럴 때 BETWEEN을 IN-List로 변환하면 효과가 크다.
그러나 조건을 만족하는 레코드가 서로 가까이 있을 경우, 둘 사이에 놓은 인덱스 블록이 소량이다.
이럴 때 BETWEEN을 IN-List로 변환하면 효과가 전혀 없거나 수직적 탐색 때문에 오히려 블록 I/O가 더 많이 발생한다.

정리하면, BETWEEN 조건 때문에 인덱스를 비효율적으로 스캔하더라도 블록 I/O 측면에서는 대개 소량에 그치는 경우가 많다. 인덱스 리프 블록에는 테이블 블록과 달리 매우 많은 레코드가 담기기 때문이다.
데이터 분포나 수직적 탐색 비용을 따져보지도 않고 BETWEEN을 IN-List로 변환하는 우를 범하지 않기 바란다.

<br/>

## (7) Index Skip Scan 활용
BETWEEN 조건을 IN-List 조건으로 변환하면 도움이 되는 상황에서 굳이 조건절을 바꾸지 않고도 같은 효과를 낼 방법이 있다. Index Skip Scan을 활용하는 것이다.

아래와 같이 월별고객별판매집계 테이블을 생성하고 직접 테스트를 통해 확인해 보자.
```
create table 월별고객별판매집계
as
select rownum 고객번호
     , '2018' || lpad(ceil(rownum/100000), 2, '0') 판매월
     , decode(mod(rownum, 12), 1, 'A', 'B') 판매구분
     , round(dbms_random.value(1000, 100000), -2) 판매금액
from   dual
connect by level <= 1200000 ;
```
2018년 1월부터 12월까지 월별로 10만 개(총 120만 개) 판매데이터가 입력되도록 했다. 판매구분 값별로는 'A'가 10만 개, 'B'가 110만 개다.
이 테이블을 이용해 아래와 같은 COUNT 쿼리를 수행하려고 한다.
```
select count(*)
from   월별고객별판매집계 t
where  판매구분 = 'A'
and    판매월 between '201801' and '201812'
```

이 쿼리를 최적으로 수행하려면 '=' 조건인 판매구분이 선두컬럼에 위치하도록 아래와 같이 인덱스를 구성해야 한다.
```
create index 월별고객별판매집계_IDX1 on 월별고객별판매집계(판매구분, 판매월);
```
아래는 IDX1 인덱스를 사용할 때의 트레이스 결과로서, 인덱스를 스캔하면서 281개의 블록 I/O가 발생한 것을 볼 수 있다. 테이블 액세스는 전혀 발생하지 않는다.
```
Rows    Row Source Operation
------- ---------------------------------------------------------------------
      1 SORT AGGRETAGE (cr=281 pr=0 pw=0 time=47753 us)
 100000   INDEX RANGE SCAN 월별고객별판매집계_IDX1 (cr=281 pr=0 pw=0 time= ... )
```
이번에는 BETWEEN 조건의 판매월 컬럼이 선두인 아래 인덱스를 사용하는 경우를 보자.
```
create index 월별고객별판매집계_IDX2 on 월별고객별판매집계(판매월, 판매구분);
```
판매구분 = 'A'인 레코드는 2018년 1월부터 12월까지 각 판매월 앞쪽에 위치하며, 전체에서 차지하는 비중이 8.3%(=10/120)에 불과하므로 서로 멀리 떨어지게 된다.

아래는 방금 생성한 IDX2 인덱스를 사용할 때의 트레이스 결과로서, 인덱스를 스캔하면서 3,090개 블록 I/O가 발생한 것을 볼 수 있다.
```
select /*+ index(t 월별고객별판매집계_IDX2) */ count(*)
from   월별고객별판매집계 t
where  판매구분 = 'A'
and    판매월 between '201801' and '201812'

Rows    Row Source Operation
------- ---------------------------------------------------------------------
      1 SORT AGGRETAGE (cr=3090 pr=0 pw=0 time=206430 us)
 100000   INDEX RANGE SCAN 월별고객별판매집계_IDX2 (cr=3090 pr=0 pw=0 time= ... )  
```
테이블을 전혀 방문하지 않았는데도 I/O가 많이 발생한 이유는, 인덱스 선두 컬럼이 BETWEEN 조건이어서 판매구분이 'B'인 레코드까지 모두 스캔하고서 버렸기 때문이다.

앞서 설명한 튜닝 방식을 적용해 BETWEEN 조건을 IN-List로 전환하고 다시 실행해 보자.
```
select /*+ index(t 월별고객별판매집계_IDX2) */ count(*)
from   월별고객별판매집계 t
where  판매구분 = 'A'
and    판매월 int ( '201801', '201802', '201803', '201804', '201805', '201806'
                , '201807', '201808', '201809', '201810', '201811', '201812' )

Rows    Row Source Operation
------- ---------------------------------------------------------------------
      1 SORT AGGRETAGE (cr=314 pr=0 pw=0 time=31527 us)
 100000   INLIST ITERATOR (cr=314 pr=0 pw=0 time=900030 us)  
 100000     INDEX RANGE SCAN 월별고객별판매집계_IDX2 (cr=314 pr=0 pw=0 time= ... )  
```
3,090개이던 블록 I/O 개수가 314개로 감소하였다. 인덱스 브랜치 블록을 열두 번 반복 탐색했지만, 리프 블록을 스캔할 때의 비효율을 제거함으로써 성능이 열 배 좋아졌다.

마지막으로 Index Skip Scan으로 유도해 보자.
```
select /*+ INDEX_SS(t 월별고객별판매집계_IDX2) */ count(*)
from   월별고객별판매집계 t
where  판매구분 = 'A'
and    판매월 between '201801' and '201812'

Rows    Row Source Operation
------- ---------------------------------------------------------------------
      1 SORT AGGRETAGE (cr=300 pr=0 pw=0 time=94282 us)
 100000   INDEX SKIP SCAN 월별고객별판매집계_IDX2 (cr=300 pr=0 pw=0 time=500073 us)  
```
인덱스 선두 컬럼이 BETWEEN 조건인데도 큰 비효율 없이 단 300 블록만 읽고 일을 마쳤다.
다음 표는 네 가지 테스트 결과를 요약한 것인데, Index Skip Scan이 IN-List보다 오히려 낫고 [판매구분 + 판매월] 순으로 구성된 IDX1 인덱스를 사용할 때와 비교해서도 큰 차이가 없다.

|구분|IDX1 인덱스|Between|IN-List|Skip Scan|
|:---:|:---:|:---:|:---:|:---:|
|**블록 I/O**|281|3,090|314|300|

선두 컬럼이 BETWEEN 이어서 나머지 검색 조건을 만족하는 데이터들이 서로 멀리 떨어져 있을 때, Index Skip Scan의 위력이 나타난다.

<br/>

## (8) IN 조건은 '='인가
SQL 튜닝 입문자에게서 흔히 볼 수 있는 현상은 IN 조건을 '=' 조건과 동등시한다는 점이다.
아래 SQL에 대한 인덱스를 [상품ID + 고객번호]로 설계할 때와 [고객번호 + 상품ID]로 설계할 때 차이가 있는지 물어보면 쉽게 알 수 있다. 흔히 차이가 없다고 생각한다.
그런데 IN 조건은 '='이 아니다. 따라서 인덱스를 어떻게 구성하느냐에 따라 성능도 달라질 수 있다.
```
select *
from   고객별가입상품
where  고객번호 = :cust_no
and    상품ID in ('NH00037', 'NH00041', 'NH00050')
```
고객별가입상품 테이블에서 고객번호의 평균 카디널리티는 3이라고 가정하자. 즉, 고객별로 평균 세 건의 상품을 가입한다.
인덱스를 [상품ID + 고객번호] 순으로 생성하면, 같은 상품은 고객번호 순으로 정렬된 상태로 하나(또는 연속된 두 개)의 리프 블록에 저장된다.
반면, 고객번호 기준으로는 같은 고객번호가 상품ID에 따라 뿔뿔이 흩어진 상태가 된다. 예를 들어, 고객번호가 1234인 레코드가 상품ID에 따라 연속되지 않은 세 개 리프 블록에 저장돼 있다.

인덱스가 이렇게 구성돼 있다면, 상품ID 조건절이 IN-List 방식으로 풀리는 것이 효과적이다. 고객번호 = 1234 조건을 만족하는 레코드가 서로 멀리 떨어져 있기 때문이다.
상품ID 조건절이 IN-List Iterator 방식으로 풀린다는 건 IN 조건이 '=' 조건으로 바뀐 SQL이 UNION ALL로 연결되는 방식을 실행된다는 의미다.

상품ID 조건절을 이처럼 IN-List Iterator 방식으로 풀면 고객번호와 상품ID 둘 다 인덱스 액세스 조건으로 사용된다. 인덱스를 수직적으로 세 번 탐색하며, 그 과정에서 아홉 개 블록을 읽는다.

지금과 같은 인덱스 구성에서는 상품ID 조건절이 IN-List Iterator 방식으로 풀려야 효과적일 뿐만 아니라 반드시 그렇게 풀려야만 한다.
인덱스를 정상적으로 사용하려면 수직적 탐색을 통해 스캔 시작점을 찾아야 하는데, 상품ID가 'NH00037'이거나 'NH00041'이거나 'NH00050'인 어느 한 지점을 바로 찾을 수 없기 때문이다.
상품ID가 인덱스 선두 컬럼인 상황에서 IN-List Iterator 방식으로 풀지 않으면, 상품ID는 필터 조건이므로 테이블 전체 또는 인덱스 전체를 스캔하면서 필터링해야 한다.

이번에는 인덱스를 [고객번호 + 상품ID] 순으로 생성해 보자. 그러면 고객은 상품ID 순으로 정렬된 상태로 같은 리프 블록에 저장된다.
여기서도 상품ID 조건절을 IN-List Iterator 방식으로 풀면, 인덱스를 수직적으로 세 번 탐색하는 과정에 아홉 개 블록을 읽는다.

상품ID 조건절을 IN-List Iterator 방식으로 풀지 않으면, 상품ID 조건절은 필터로 처리한다. 그러면 고객번호만 액세스 조건이므로 고객번호 = 1234인 레코드를 모두 스캔한다.
같은 고객은 한 블록(또는 연속된 두 블록)에 모여 있으므로 블록 I/O는 수직적 탐색 과정을 포함해 총 세 개(또는 네 개)만 발생한다.

요컨대, IN 조건은 '='이 아니다. IN 조건이 '='이 되려면 IN-List Iterator 방식으로 풀려야만 한다. 그렇지 않으면, IN 조건은 필터 조건이다.
그런데 과연 IN 조건을 '=' 조건으로 만들기 위해, 즉 액세스 조건으로 만들기 위해 IN-List Iterator 방식으로 푸는 것이 항상 효과적인가?

방금 본 사례에서 상품ID가 액세스 조건으로서 의미있는 역할을 하려면, 고객별 상품 데이터가 아주 많아야 한다. 그렇지 않은 상황에서 상품ID는 필터 방식으로 처리되는 게 오히려 낫다.

- #### [더 쉬운 예]

  더 쉬운 에를 들어보자. 상품 테이블 인덱스가 아래와 같이 구성돼 있다.

  - 상품_PK : 상품ID
  - 상품_X01 : 상품ID + 상품구분코드

  아래는 조회한 상품(상품ID = :prod_id)의 상품구분코드가 'GX' 또는 'KR'이면 데이터를 출력하는 쿼리문이다.
  상품구분코드 조건은 X01 인덱스에 대한 필터 조건으로 사용되고 있다는 사실을 실행계획(하단 Predicate information)에서 확인할 수 있다.

  ```
  select * from 상품
  where  상품ID = :prod_id
  and    상품구분코드 in ('GX', 'KR')

  Execution Plan
  -----------------------------------------------------------------------------
  0        SELECT STATEMENT Optimizer=ALL_ROWS (Cost=2 Card=1 Bytes=38)
  1    0     TABLE ACCESS (BY INDEX ROWID) OF '상품' (TABLE) (Cost=2 Card=1 Bytes=38)
  2    1       INDEX (RAGNE SCAN) OF '상품_X01' (INDEX) (Cost=1 Card=1)

  Predicate information (identified by operation id):
  -----------------------------------------------------------------------------
      2 - access("상품ID"=:PROD_ID)
      2 - filter("상품구분코드"='GX' OR "상품구분코드"='KR')
  ```

  지금과 같은 상황에서 X01 인덱스 스캔을 IN-List Iterator 방식으로 유도하면 성능향상에 도움이 될까? 아니면, X01 인덱스를 상품구분코드 + 상품ID로 변경하면 성능향상에 도움이 될까?

  그렇지 않다는 사실을 쉽게 이해했으리라 맏는다. 상품ID가 Unique 하다는 데 힌트가 있다.


### [NUM_INDEX_KEYS 힌트 활용]
다음 주제로 넘어가기 전에, IN-List 액세스 조건 또는 필터 조건으로 유도하는 방법을 살펴보자.
인덱스가 [고객번호 + 상품ID] 순으로 구성된 상황에서 고객번호만 인덱스 액세스 조건으로 사용하려면 아래와 같이 힌트를 사용하면 된다.
num_index_keys 힌트의 세 번째 인자 '1'은 인덱스 첫 번째 컬럼까지만 액세스 조건으로 사용하라는 의미다.
```
select /*+ num_index_keys(a 고객별가입상품_X1 1) */ *
from  고객별가입상품 a
where  고객번호 = :cust_no
and    상품ID in ('NH00037', 'NH00041', 'NH00050')

Execution Plan
-----------------------------------------------------------------------------
  0        SELECT STATEMENT Optimizer=ALL_ROWS
  1    0     TABLE ACCESS (BY INDEX ROWID BATCHED) OF '고객별가입상품' (TABLE)
  2    1       INDEX (RAGNE SCAN) OF '고객별가입상품_X1' (INDEX)

Predicate information (identified by operation id):
-----------------------------------------------------------------------------
  2 - access("고객번호"=:TO_NUMBER(:CUST_NO)
  2 - filter("상품ID"='NH00037' OR "상품ID"='NH00041' OR "상품ID"='NH00050')
```

힌트를 사용하지 않고 아래와 같이 인덱스 컬럼을 가공하는 방법도 있다.
```
select *
from   고객별가입상품
where  고객번호 = :cust_no
and    RTRIM(상품ID) in ('NH00037', 'NH00041', 'NH00050')

select *
from   고객별가입상품
where  고객번호 = :cust_no
and    상품ID || '' in ('NH00037', 'NH00041', 'NH00050')
```

상품ID까지 인덱스 액세스 조건으로 사용하려면, 아래와 같이 힌트를 사용하면 된다. 실행계획을 보면 상품ID가 IN-List Iterator 방식으로 풀리면서 인덱스 액세스 조건으로 사용되었다.
```
select /*+ num_index_keys(a 고객별가입상품_X1 2) */ *
from  고객별가입상품 a
where  고객번호 = :cust_no
and    상품ID in ('NH00037', 'NH00041', 'NH00050')

Execution Plan
-----------------------------------------------------------------------------
  0        SELECT STATEMENT Optimizer=ALL_ROWS
  1    0     INLIST ITERATOR
  2    1       TABLE ACCESS (BY INDEX ROWID BATCHED) OF '고객별가입상품' (TABLE)
  3    2         INDEX (RAGNE SCAN) OF '고객별가입상품_X1' (INDEX)

Predicate information (identified by operation id):
-----------------------------------------------------------------------------
  3 - access("고객번호"=TO_NUMBER(:CUST_NO) AND ("상품ID"='NH00037' OR "상품ID"='NH00041' OR "상품ID"='NH00050'))
```

<br/>

## (9) BETWEEN과 LIKE 스캔 범위 비교
월별로 집계된 테이블에서 2019년 1월부터 12월 데이터를 조회하고자 할 때, 흔히 아래와 같이 LIKE 연산자를 사용한다.
```
select * from 월별고객별판매집계
where  판매월 like '2019%';
```

아래 BETWEEN이 더 정확한 표현인데도 개발자들이 LIKE를 더 선호하는 이유는 단순하다. LIKE로 코딩하는 것이 더 편리하기 때문이다.
```
select * from 월별고객별판매집계
where  판매월 between '201901' and '201912'
```

LIKE와 BETWEEN은 둘 다 범위검색 조건으로서, 앞에서 설명한 범위검색 조건을 사용할 때의 비효율 원리가 똑같이 적용된다. 하지만 데이터 분포와 조건절 값에 따라 인덱스 스캔량이 서로 다를 수 있다.

결론부터 말하면, LIKE보다 BETWEEN을 사용하는 게 낫다. 사용하기엔 BETWEEN이 다소 불편하나, 몸에 좋은 약이 입에 쓴 법이다.
상황에 따라 큰 차이가 아닐 수 있지만, BETWEEN을 사용하면 적어도 손해는 안 본다.

예를 들어 보자. 인덱스를 [판매월 + 판매구분]으로 구성했다.
판매구분으로는 'A'와 'B' 두 개 값이 존재하고, 각각 90%와 10%의 비중을 차지하는 상황에서 아래 두 조건절에 대해 인덱스 스캔량을 비교해 보자.
```
< 조건절 1 >
where  판매월 BETWEEN '201901' and '201912'
and    판매구분 = 'B'

< 조건절 2 >
where  판매월 LIKE '2019%'
and    판매구분 = 'B'
```
조건절 1은 판매월 = '201901'이고 판매구분 = 'B'인 첫 번째 레코드에서 스캔을 시작한다. 반면, 조건절 2는 판매월 = '201901'인 첫 번째 레코드에서 스캔을 시작한다.
혹시라도 '201900'이 저장돼 있다면 그 값도 읽어야 하므로 판매구분 = 'B'인 지점으로 바로 내려갈 수 없다.

이번에는 판매구분 'A'와 'B' 두 값이 각각 10%와 90% 비중을 차지한다고 가정하고, 아래 두 조건절에 대해 인덱스 스캔량을 비교해 보자.
```
< 조건절 3 >
where  판매월 BETWEEN '201901' and '201912'
and    판매구분 = 'A'

< 조건절 4 >
where  판매월 LIKE '2019%'
and    판매구분 = 'A'
```
조건절 3은 판매월 = '201912'이고 판매구분 'B'인 첫 번째 레코드를 만나는 순간 스캔을 멈춘다. 반면, 조건절 4는 판매월 = '201912'인 레코드를 모두 스캔하고서야 멈춘다.
혹시라도 '201913'이 저장돼 있다면 그 값도 읽어야 하므로 중간에 멈출 수가 없다.

<br/>

## (10) 범위검색 조건을 남용할 때 생기는 비효율
사용자 입력과 선택에 따라 조건절이 다양하게 바뀔 때 SQL을 간편하게 작성하려고 조건절을 모두 LIKE로 구사하는 개발팀을 종종 보는데, 해당 컬럼이 인덱스 구성 컬럼일 때는 주의가 필요하다.

예를 들어, 회사코드, 지역코드, 상품명 등을 입력함으로써 '가입상품' 테이블에서 데이터를 조회하는 프로그램이 있다고 하자.
조회 화면에서 회사코드(=가입접수를 받은 회사코드)는 반드시 입력하지만 지역코드는 입력하지 않을 수 있다. 그리고 상품명은 단어 중 일부만 입력할 수 있다.
따라서 이 프로그램은 내부에서 아래 두 쿼리 중 하나를 선택적으로 사용할 것이다.
```
< 쿼리 1 > 회사코드, 지역코드, 상품명을 모두 입력할 때
SELECT  고객ID, 상품명, 지역코드, ...
FROM    가입상품
WHERE   회사코드 = :com
AND     지역코드 = :reg
AND     상품명 LIKE :prod || '%'

< 쿼리 2 > 회사코드, 상품명만 입력할 때
SELECT  고객ID, 상품명, 지역코드, ...
FROM    가입상품
WHERE   회사코드 = :com
AND     상품명 LIKE :prod || '%'
```
인덱스를 [회사코드 + 지역코드 + 상품명] 순으로 구성했다고 하자.

만약 사용자가 회사코드, 지역코드, 상품명을 모두 입력하고 조회했을 때의 인덱스 스캔 범위와 지역코드를 입력하지 않고 조회했을 때 스캔 범위는 어떻게 다를까?

인덱스 중간 컬럼(=지역코드)에 대한 조건이 없을 때는 어쩔 수 없이 넓은 범위를 스캔하지만, 이 조건이 있을 때는 세 컬럼 모두 액세스 조건이므로 아주 적은 범위만 스캔하고 빠르게 결과를 출력할 수 있다.

그런데 이 프로그램을 담당한 개발자가 두 가지 상황을 SQL 하나로 처리하려고 아래와 같이 지역코드 컬럼 조건절에 LIKE 연산자를 사용했다면, 조회 성능에 어떤 영향을 미칠까?
```
SELECT  고객ID, 상품명, 지역코드, ...
FROM    가입상품
WHERE   회사코드 = :com
AND     지역코드 LIKE :reg || '%'
AND     상품명 LIKE :prod || '%'
```
같은 인덱스 구성에서 회사코드, 지역코드, 상품명을 모두 입력했을 때의 스캔 범위와 지역코드를 입력하지 않고 조회했을 때 스캔 범위는 어떻게 다를까?

지역코드를 입력 안 한 경우는 이전과 똑같지만, 지역코드를 입력한 경우는 이전에 비해 인덱스 스캔 범위가 늘어난 것을 볼 수 있다. 앞서 액세스 조건이던 상품명이 필터 조건으로 바뀌면서 생긴 변화다.

또 다른 예로, 아래와 같이 모든 조건절을 BETWEEN으로 처리하는 개발팀을 본 적도 있다. 이 역시 옵션 조건을 처리하기 위해 고안한 방법이다.
```
SELECT  거래일자, 종목코드, 투자자유형코드
      , 주문매체코드, 체결건수, 체결수량, 거래대금
FROM    일별종목거래
WHERE   거래일자 BETWEEN :시작일자 AND :종료일자               -- 필수 조건
AND     종목코드 BETWEEN :종목1 AND :종목2                   -- 옵션 조건
AND     투자자유형코드 BETWEEN :투자자유형1 AND :투자자유형2      -- 옵션 조건
AND     주문매체구분코드 BETWEEN :주문매체구분1 AND :주문매체구분2  -- 옵션 조건
```
예를 들어, 종목코드에 최대 6자리까지 입력 가능하다고 할 때, 사용자가 종목코드를 입력하면 양쪽 변수(:종목1, :종목2)에 같은 값을 입력한다.
종목코드를 입력하지 않으면 왼쪽 변수에는 '______'('_' 여섯 개), 오른쪽 변수에는 'ZZZZZZ'를 입력한다. 이렇게 입력하면 모든 종목코드가 조회된다.

옵션 조건이 세 개이므로 나올 수 있는 모든 경우의 수만큼 총 여덟 개 SQL을 작성해야 하는데, 이 방식을 사용하면 SQL 하나로 모든 경우를 다 처리할 수 있다.
개발 생산성만 놓고 보면 좋은 아이디어라고 생각할 수 있지만, 인덱스 스캔 효율을 고려한다면 사용을 자제해야 할 패턴이다.

코딩을 쉽게 하려고 이처럼 인덱스 컬럼에 범위검색 조건을 남용하면 인덱스 스캔 비효율이 생긴다.
인덱스 스캔 비효율이 성능에 미치는 영향이 적을 수도 있지만, 대량 테이블을 넓은 범위로 검색할 때는 그 영향이 매우 클 수도 있다.
따라서 SQL 작성할 때 주의해야 하며, 데이터 분포에 따라 인덱스 컬럼에 대한 비교 연산자를 신중하게 선택해야 한다.

<br/>

## (11) 다양한 옵션 조건 처리 방식의 장단점 비교
방금 살펴본 두 가지 외에도 옵션 조건에 개발자들이 다양한 방식을 사용하는데, 각각의 장단점을 비교해 보자.

### [OR 조건 활용]
옵션 조건 처리에 아래와 같이 OR 조건을 사용할 수 있다.
```
select * from 거래
where  (:cust_id is null or 고객ID = :cust_id)
and    거래일자 between :dt1 and :dt2

Execution Plan
-----------------------------------------------------------------------------
0        SELECT STATEMENT Optimizer=ALL_ROWS
1    0     TABLE ACCESS (FULL) OF '거래' (TABLE)
```
개발자들이 흔히 사용하는 이 방식의 가장 큰 문제점은 (옵티마이저에 의한 OR Expansion 쿼리 변환이 기본적으로 작동하지 않으므로) 옵션 조건 컬럼을 선두에 두고 [고객ID + 거래일자] 순으로 인덱스를
구성해도 이를 사용할 수 없다는 데 있다. 따라서 인덱스 선두 컬럼에 대한 옵션 조건에 OR 조건을 사용해선 안 된다.

[거래일자 + 고객ID] 순으로 구성한 인덱스는 사용할 수 있다. 하지만, 고객ID를 필터 조건으로 사용한다는 데 문제가 있다.
인덱스 스캔 단계에서 필터링해도 비효율적인데, 심지어 테이블 액세스 단계에서 필터링한다.
거래일자 BETWEEN 조건을 찾기 위해 인덱스에서 100만 건을 스캔하면, 그만큼 테이블을 랜덤 액세스한 후에 고객ID를 필터링한다는 뜻이다.
그렇다면 OR 옵션 조건으로 처리한 고객ID를 인덱스에 포함할 필요조차 없다.
(인덱스에 Not Null 컬럼이 포함된 경우, 즉 모든 테이블 레코드가 인덱스에 저장돼 있음이 보장되는 경우, 18c 버전부터 OR 조건도 인덱스 필터로 처리되기 시작했다.)

```
Execution Plan
------------------------------------------------------------
0        SELECT STATEMENT Optimizer=ALL_ROWS
1    0     FILTER
2    1       TABLE ACCESS (BY INDEX ROWID) OF '거래' (TABLE)
3    2         INDEX (RANGE SCAN) OF '거래_IDX3' (INDEX)
------------------------------------------------------------

Predicate informatino (identified by operation id):
------------------------------------------------------------
  1 - filter(TO_DATE(:DT1)<=TO_DATE(:DT2))
  2 - filter(:CUST_ID IS NULL OR "고객ID"=TO_NUMBER(:CUST_ID))
  3 - access("거래일자">=:DT1 AND "거래일자"<=:DT2)
```

인덱스에 포함되지 않은 컬럼에 대한 옵션 조건은 어차피 테이블에서 필터링할 수밖에 없으므로 그럴 때는 OR 조건을 사용해도 무방하다. OR 조건을 활용한 옵션 조건 처리를 정리하면 다음과 같다.
- 인덱스 액세스 조건으로 사용 불가
- 인덱스 필터 조건으로 사용 불가
- 테이블 필터 조건으로만 사용 가능
- 단, 인덱스 구성 컬럼 중 하나 이상이 Not Null 컬럼이면, 18c부터 인덱스 필터 조건으로 사용 가능

이런 특성을 고려한다면, OR 조건을 이용한 옵션 조건 처리는 가급적 사용하지 않아야 한다. 이 방식의 유일한 장점은 옵션 조건이 NULL 허용 컬럼이더라도 결과집합을 보장하는 것뿐이다.
(이어서 설명할 방식들은 UNION ALL을 제외하면 모두 NULL 허용 컬럼에 사용할 수 없다는 단점이 있다. 결과집합을 보장하지 않기 때문이다.)

참고로, 아래와 같은 형태의 OR 조건절에는 OR-Expansion을 통해 인덱스 사용이 가능하다.
```
select * from 거래
where  고객ID = :cust_id
and    ((:dt_type = 'A' AND 거래일자 between :dt1 and :dt2)
        or
        (:dt_type = 'B' AND 결제일자 between :dt1 and :dt2))
Execution Plan
----------------------------------------------------------------------------
0        SELECT STATEMENT Optimizer=ALL_ROWS
1    0     CONCATENATION
2    1       FILTER
3    2         TABLE ACCESS (BY LOCAL INDEX ROWID) OF '거래' (TABLE)
4    3           INDEX (RANGE SCAN) OF '거래_IDX1' (INDEX)   -- 고객ID + 거래일자
5    1       FILTER
6    5         TABLE ACCESS (BY LOCAL INDEX ROWID) OF '거래' (TABLE)
7    6           INDEX (RANGE SCAN) OF '거래_IDX2' (INDEX)   -- 고객ID + 결제일자
```

### [LIKE/BETWEEN 조건 활용]
앞에서 설명한 것처럼 LIKE/BETWEEN도 옵션 조건 처리를 위해 많이 사용하는 방식 중 하나다.
아래와 같이 변별력이 좋은 필수 조건이 있는 상황(당일 등록 상품은 소수)에서 이들 패턴을 사용하는 것은 나쁘지 않다.
필수 조건 컬럼을 인덱스 선두에 두고 액세스 조건으로 사용하면, LIKE/BETWEEN이 인덱스 필터 조건이어도 충분히 좋은 성능을 낼 수 있기 때문이다.
```
-- 인덱스 : 등록일시 + 상품분류코드
select * from 상품
where  등록일시 >= trunc(sysdate)            -- 필수 조건(당일 등록 상품)
and    상품분류코드 like :prd_cls_cd || '%'   -- 옵션 조건
```
더구나, 필수 조건이 아래와 같이 '='이면 옵션 조건인 상품분류코드까지도 인덱스 액세스 조건이므로 최적의 성능을 낼 수 있다.
```
-- 인덱스 : 상품명 + 상품분류코드
select * from 상품
where  상품명 = :prd_nm                      -- 필수 조건
and    상품분류코드 like :prd_cls_cd || '%'    -- 옵션 조건
```
문제는 필수 조건의 변별력이 좋지 않을 때다. 예를 들어, 아래 SQL에서 상품대분류코드만으로 조회할 때는 Table Full Scan이 유리하다.
그런데 옵티마이저는 상품코드까지 입력할 때를 기준으로 Index Range Scan을 선택한다. 다행히 사용자가 상품코드까지 입력하면 최적의 성능을 내겠지만, 그렇지 않을 때 성능에 문제가 생긴다.
```
-- 인덱스 : 상품대분류코드 + 상품코드
select * from 상품
where  상품대분류코드 = :prd_lcls_cd            -- 필수 조건
and    상품코드 like :prd_cd || '%'           -- 옵션 조건
```
이 외에도 LIKE/BETWEEN 패턴을 사용하고자 할 때는 아래 네 가지 경우에 속하는지 반드시 점검해야 한다.(BETWEEN 조건은 1번과 2번 조건에 해당하는지만 점검하면 된다.)
#### [1] 인덱스 선두 컬럼
인덱스 선두 컬럼에 대한 옵션 조건을 LIKE/BETWEEN 연산자로 처리하는 것은 금물이다.

예를 들어, 인덱스를 [고객ID + 거래일자]로 구성한 상황에서 고객ID에 대한 옵션 조건을 아래와 같이 LIKE로 처리했다고 하자.
```
select * from 거래
where  고객ID like :cust_id || '%'
and    거래일자 between :dt1 and :dt2
```
사용자가 고객ID 값을 입력하면, 둘 다 범위검색 조건이어서 인덱스 스캔 과정에 약간 비효율이 있더라도 고객ID가 변별력이 매우 좋기 때문에 비교적 빠르게 조회된다.
그런데 만약 사용자가 고객ID 값을 입력하지 않으면, 인덱스에서 '모든' 거래 데이터를 스캔하면서 거래일자 조건을 필터링하는 불상사가 생긴다.

옵션 조건 처리에 위와 같이 LIKE/BETWEEN을 사용했다면, 인덱스를 [거래일자 + 고객ID] 순으로 구성해야 한다. 이때는 고객ID 값을 입력할 때 생기는 비효율을 감수해야 한다.
특정 고객의 거래를 조회하고 싶은데도 거래일자 범위에 속한 모든 거래 데이터를 스캔하면서 고객ID 조건을 필터링하기 때문이다.

#### [2] NULL 허용 컬럼
NULL 허용 컬럼에 대한 옵션 조건을 LIKE/BETWEEN 연산자로 처리하는 것도 금물이다. 성능을 떠나 결과 집합에 오류가 생기기 때문이다.

위 SQL에서 :cust_id 변수에 NULL을 입력하면 조건절은 아래와 같은 형태가 된다.
```
select * from 거래
where  고객ID like '%'
and    거래일자 between :dt1 and :dt2
```
거래일자 조건에 해당하는 모든 고객의 거래를 선택해야 하는 상황인데, 고객ID가 NULL 허용컬럼이고 실제 NULL 값이 입력돼 있다면 그 데이터는 결과집합에서 누락된다.
잘 이해가 되지 않는다면, 아래 :var 변수에 아무 값도 입력하지 않고 SQL을 실행해 보자. 그리고 결과가 왜 공집합인지 곰곰이 생각해 보기 바란다.
```
SQL> select * from dual where null like :var || '%';

선택된 레코드가 없습니다.
```
BETWEEN 조건을 사용할 때도 컬럼 값이 NULL인 데이터는 결과집합에서 누락된다.

#### [3] 숫자형 컬럼
숫자형이면서 인덱스 액세스 조건으로도 사용 가능한 컬럼에 대한 옵션 조건 처리는 LIKE 방식을 사용해선 안 된다.

예를 들어, 인덱스를 [거래일자 + 고객ID] 순으로 구성한 상황에서 SQL을 아래와 같이 작성하면, :cust_id에 값을 입력했을 때 두 컬럼 모두 인덱스 액세스 조건으로 사용된다.
```
select * from 거래
where  거래일자 = :trd_dt
and    고객ID like :cust_id || '%'
```
그런데 만약 고객ID가 숫자형 컬럼이면, 아래와 같이 자동 형변환이 일어나므로 고객ID가 필터 조건으로 사용된다.
특정 고객의 하루 치 거래를 조회하고 싶은데 하루 치 거래를 모두 스캔하면서 고객ID 조건을 필터링한다는 뜻이다.
```
select * from 거래
where  거래일자 = :trd_dt
and    to_char(고객ID) like :cust_id || '%'
```
[고객ID + 거래일자] 순으로 구성한 인덱스는 아예 사용할 수 없다.

#### [4] 가변 길이 컬럼
LIKE를 옵션 조건에 사용할 때는 컬럼 값 길이가 고정이어야 한다.

예를 들어, 고객명 컬럼에는 '김훈', '김훈남' 등 길이가 다른 값이 입력될 수 있다.
그런데 고객명에 대한 옵션 조건을 아래와 같이 LIKE 패턴으로 처리하면, '김훈' 고객을 찾기 위해 :cust_nm 변수에 '김훈'을 입력했을 때 '김훈남' 고객도 같이 조회된다.
```
where 고객명 like :cust_nm || '%'    -- :cust_nm = '김훈'
```
따라서 컬럼 값 길이가 가변적일 때는 변수 값 길이가 같은 레코드만 조회되도록 아래와 같은 조건절을 추가해야 한다.
```
where 고객명 like :cust_nm || '%'    -- :cust_nm = '김훈'
and   length(고객명) = length(nvl(:cust_nm, 고객명))
```
아래와 같이 하는 방법도 있다.
```
where 고객명 like :cust_nm           -- 고객명을 입력하지 않을 떄 :cust_nm에 '%' 입력
```
'%' 없는 LIKE 조건이므로 '=' 조건처럼 :cust_nm에 입력한 값과 정확히 일치하는 고객명만 출력한다.
단, 사용자가 고객명을 입력하지 않으면(:cust_nm is null), :cust_nm 변수에 '%'를 입력해야 모든 고객명을 출력한다.

### [UNION ALL 활용]
아래와 같이 UNION ALL을 이용하는 방법도 있다. :cust_id 변수에 값을 입력했는지에 따라 위아래 SQL 중 어느 하나만 실행되게 하는 방식이다.
```
select * from 거래
where  :cust_id is null
and    거래일자 between :dt1 and :dt2
union all
select * from 거래
where  :cust_id is not null
and    고객ID = :cust_id
and    거래일자 between :dt1 and :dt2
```
아래는 위 SQL에 대한 실행계획인데, ':cust_id' 변수에 값을 입력하지 않으면(:cust_id is null) 위쪽 브랜치에서 거래일자가 선두인 인덱스를 사용하고,
변수에 값을 입력하면(:cust_id is not null) 아래쪽 브랜치에서 [고객ID + 거래일자] 인덱스를 사용하고 있다.
```
Execution Plan
-----------------------------------------------------------------------------
0        SELECT STATEMENT Optimizer=ALL_ROWS
1    0     UNION ALL
2    1       FILTER    -- :cust_id is null
3    2         TABLE ACCESS (BY LOCAL INDEX ROWID) OF '거래' (TABLE)
4    3           INDEX (RANGE SCAN) OF '거래_IDX1' (INDEX)  -- 거래일자
5    1       FILTER    -- :cust_id is not null
6    5         TABLE ACCESS (BY LOCAL INDEX ROWID) OF '거래' (TABLE)
7    6           INDEX (RAGNE SCAN) OF '거래_IDX2' (INDEX)  -- 고객ID + 거래일자
```
이 패턴을 사용하면, :cust_id 변수에 값을 입력하든 안 하든, 인덱스를 가장 최적으로 사용한다. 위쪽 브랜치에서는 거래일자, 아래쪽 브랜치에서는 고객ID와 거래일자 모두 액세스 조건으로 사용하기 때문이다.
LIKE 패턴도 인덱스 사용은 가능하지만 필수 조건인 거래일자가 BETWEEN이면 옵션 조건 컬럼을 필터 조건으로 사용한다.
(인덱스 선두 컬럼에 대한 LIKE 패턴 사용은 금물이므로 인덱스 후행 컬럼에서 필터 방식으로 사용하는 경우를 말한다.)
반면, UNION ALL 방식은 옵션 조건 컬럼도 인덱스 액세스 조건으로 사용한다는 사실이 매우 중요하다.

고객ID가 NULL 허용 컬럼이라도 사용하는 데 전혀 문제가 없다. 유일한 단점은 SQL 코딩량이 길어진다는 점이다.

### [NVL/DECODE 함수 활용]
아래와 같이 NVL, DECODE 함수도 옵션 조건에 많이 사용하는 패턴 중 하나다.
```
select * from 거래
where  고객ID = nvl(:cust_id, 고객ID)
and    거래일자 between :dt1 and :dt2

또는

select * from 거래
where  고객ID = decode(:cust_id, null, 고객ID, :cust_id)
and    거래일자 between :dt1 and :dt2
```
아래는 위 SQL에 대한 실행계획이다.
:cust_id 변수에 값을 입력하지 않으면 위쪽 브랜치에서 거래일자가 선두인 인덱스를 사용하고, 변수에 값을 입력하면 아래쪽 브랜치에서 [고객ID + 거래일자] 인덱스르르 사용한다는 것을 표현하고 있다.
NVL, DECODE 둘 중 어느 것을 사용하든, 실행계획은 똑같다.
- NVL 함수 대신 Coalesce 함수, DECODE 함수 대신 CASE 문을 사용해도 될 듯하지만, Coalesce 함수나 CASE 문을 사용하면 OR Expansion이 작동하지 않는다.

```
Execution Plan
-----------------------------------------------------------------------------
0        SELECT STATEMENT Optimizer=ALL_ROWS
1    0     CONCATENATION
2    1       FILTER    -- :cust_id is null
3    2         TABLE ACCESS (BY LOCAL INDEX ROWID) OF '거래' (TABLE)
4    3           INDEX (RANGE SCAN) OF '거래_IDX1' (INDEX)  -- 거래일자
5    1       FILTER    -- :cust_id is not null
6    5         TABLE ACCESS (BY LOCAL INDEX ROWID) OF '거래' (TABLE)
7    6           INDEX (RAGNE SCAN) OF '거래_IDX2' (INDEX)  -- 고객ID + 거래일자
```
고객ID 컬럼을 함수 인자로 사용(인덱스 컬럼 가공)했는데도 인덱스를 사용할 수 있는 것은 OR Expansion 쿼리 변환이 일어났기 때문이다. 앞서 살펴본 UNION ALL 방식으로 옵티마이저가 쿼리를 변환한 것이다.
- NVL, DECODE 함수에 대한 OR Expansion을 가능하게 하는 히든 파라미터는 '_or_expand_nvl_predicate'이다.

만약 이 기능이 작동하지 않으면, NVL, DECODE 함수를 사용하는 패턴도 인덱스 액세스 조건으로 사용이 불가능하다.
:cust_id에 값을 입력하지 않으면(즉, NULL을 입력하면) 조건절이 '고객ID = 고객ID' 형태가 되므로 인덱스에서 이 조건을 만족하는 어느 한 시작점을 찾을 수 없기 때문이다.

이 방식의 가장 큰 장점은 옵션 조건 컬럼을 인덱스 액세스 조건으로 사용할 수 있다는 데 있다. 즉, UNION ALL보다 단순하면서도 UNION ALL과 같은 성능을 낸다.

단점은, 앞서 설명한 LIKE 패턴처럼 NULL 허용 컬럼에 사용할 수 없다는 데 있다. 조건절 변수에 NULL을 입력하면 값이 NULL인 레코드가 결과집합에서 누락되기 때문이다.
잘 이해가 되지 않는다면, 아래 결과를 참고하기 바란다.
```
SQL> select * from dual where NULL = NULL;

선택된 레코드가 없습니다.

SQL> select * from dual where NULL IS NULL;

DU
--
X

1 개의 행이 선택되었습니다.
```
옵션 조건 처리용 NVL/DECODE 함수를 여러 개 사용하면 그중 **변별력이 가장 좋은 컬럼 기준으로 한 번만 OR Expansion이 일어난다**는 사실도 기억할 필요가 있다.
따라서 OR Expansion 기준으로 선택되지 않으면 인덱스 구성 컬럼이어도 모두 필터 조건으로 처리된다.
NVL/DECODE 함수의 장점에도 불구하고 모든 옵션 조건을 이 방식으로 처리할 수 없는 이유가 바로 여기에 있다.

지금까지 시스템 개발 현장에서 많이 사용하는 다양한 옵션 조건 패턴의 장단점을 비교해 보았다. 많은 차세대 프로젝트에서 성능 컨설팅을 수행하면서 가장 다루기 어려운 주제가 바로 옵션 조건 처리다.
다른 성능 관련 SQL 패턴은 애플리케이션 특성에 맞게 어느 하나의 솔루션을 선택해서 개발팀에 권고안을 제시할 수 있지만, 옵션 조건 처리는 그럴 수 없기 때문이다.
지금까지 설명한 여러 방식의 장단점을 이해함으로써 상황에 따라 선택할 수밖에 없다.

문제는 인덱스 구조와 탐색 원리, 특히 인덱스 스캔 효율화 원리를 정확히 이해하지 못하면, 올바른 선택을 할 수 없다는 데 있다.
아무쪼록 이번 장에서 다룬 인덱스 활용 원리가 많은 개발자에게 전파되고 활용되기를 바랄 뿐이다.

- #### [Dynamic SQL]

  Dynamic SQL을 이용해 조건절을 동적으로 구성할 수 있는 시스템 환경에서 개발하고 있다면, 방금 설명한 내용에 잘 공감하지 못할 수도 있다.
  Dynamic SQL을 이용하면 옵션 조건에 '=' 연산자를 사용할 수 있기 때문이다. 예를 들어, iBatis 같은 SQL 매핑 프레임워크에서는 옵션 조건을 아래와 같이 처리한다.
  ```
  <select id="..." parameterClass="..." resultClass="..." >
  select * from 거래
  where 거래일자 between #dt1# and #dt2#
    <isNotEmpty prepend="and" property="cust_id">
      고객ID = #cust_id#
    </isNotEmpty>
  </select>
  ```
  Dynamic SQL을 이용해 옵션 조건에 '=' 연산자를 사용할 경우, 변별력 있는 컬럼을 액세스 조건으로 사용할 수 있게 인덱스만 잘 구성해 주면 된다.

  그런데 Dynamic SQL을 허용하지 않는 시스템(특히, 금융권)도 있다. 허용하더라도 힌트로 액세스 경로를 고정하려고 할 때 방금 설명한 튜닝 기법을 적절히 활용해야 한다.
  Dynamic SQL에 옵티마이저 힌트를 명시하면 동적으로 구성된 조건절과 서로 상충함으로 인해 오히려 성능 문제를 야기할 수 있기 때문이다.

  마지막으로, Dynamic SQL을 이용하더라도 하드파싱에 의한 성능 문제가 발생하지 않도록 바인드 변수를 잘 사용하기 바란다. 조건절을 동적으로 구성한다고 해서 입력 값까지 동적으로 변경할 이유는 없다.

<br/>

## (12) 함수호출부하 해소를 위한 인덱스 구성

### [PL/SQL 함수의 성능적 특성]
PL/SQL 사용자 정의 함수는 개발자들이 일반적으로 생각하는 것보다 매우 느리다.

예를 들어, 아래처럼 한두 번 호출할 때는 함수를 사용하지 않았을 때와 비교해 성능 차이를 잘 느끼지 못한다.
```
select 회원번호, 회원명, 생년, 생월일, encryption(전화번호)
from   회원
where  회원번호 = :member_no  -- 한 건 조회
```

아래처럼 대량 데이터를 조회해 보면 성능 차이를 확연히 느낄 수 있다.
```
select 회원번호, 회원명, 생년, 생월일, encryption(전화번호)
from   회원
where  생월일 like '01%'  -- 수십 ~ 수백 만 건 조회
```

PL/SQL 사용자 정의 함수가 느린 데는 아래 3가지 이유가 있다.
- [1] 가상머신(VM) 상에서 실행되는 인터프리터 언어
- [2] 호출 시마다 컨텍스트 스위칭 발생
- [3] 내장 SQL에 대한 Recursive Call 발생

오라클은 오라클 서버가 아닌 Oracle Forms, Oracle Reports 같은 제품에서도 수행될 수 있도록 PL/SQL을 설계하였다.
그래서 PL/SQL로 작성한 함수와 프로시저를 컴파일하면 JAVA 언어처럼 바이트코드(Bytecode)를 생성해서 데이터 딕셔너리에 저장하며, 이를 해석할 수 있는 PL/SQL 엔진(가상머신)만 있으면 어디서든
실행할 수 있다. PL/SQL 엔진은 바이트 코드를 런타임 시 해석하면서 실행한다.

지금은 가장 인기 있는 개발언어가 된 JAVA가 초기에 고전했던 이유는 바로 속도 때문이었는데, PL/SQL도 JAVA처럼 인터프리터 언어이기 때문에 Native 코드로 완전 컴파일된 내장(Built-In)
함수에 비해 많이 느리다.

PL/SQL 함수는 실행 시 매번 SQL 실행엔진과 PL/SQL 가상머신 사이에 컨텍스트 스위칭(Context Switching)이 일어난다.
C++, JAVA, VB와 같은 일반 프로그래밍 언어에서는 될 수 있으면 함수를 이용해 작은 단위로 모듈화・공용화하는 것을 권장하지만, PL/SQL 함수를 그런 식으로 활용하면 안 되는 이유가 여기에 있다.

PL/SQL 사용자 정의 함수의 성능을 떨어뜨리는 가장 결정적인 요소는 Recursive Call이다.

아래 SQL에서 조건을 만족하는 회원이 100만 명이면 GET_ADDR도 100만 번 실행하는데, 만약 함수에 SQL이 내장돼 있으면 그 SQL도 100만 번 실행한다.
대개 PL/SQL 함수에는 SQL이 내장돼 있으므로 일반적으로 인터프리팅, 컨텍스트 스위칭보다 Recursive Call 부하가 가장 크다.
```
select 회원번호, 회원명, 생년, 생월일, GET_ADDR(우편번호) as 기본주소
from   회원
where  생월일 like '01%'
```
위 SQL에 PL/SQL 함수를 쓰지 않고 아래와 같이 조인문으로 처리하면 성능 차이가 매우 크다. 당연히 아래 SQL이 빠르다.
```
select a.회원번호, a.회원명, a.생년, a.생월일
     , (select b.시도 || ' ' || b.구군 || ' ' || b.읍면동
        from  기본주소 b
        where b.우편번호 = a.우편번호
        and   b.순번 = 1) 기본주소
from  회원 a
where a.생월일 like '01%'

또는

select a.회원번호, a.회원명, a.생년, a.생월일
     , b.시도 || ' ' || b.구군 || ' ' || b.읍면동 as 기본주소
from  회원 a, 기본주소 b
where a.생월일 like '01%'
and   b.우편번호(+) = a.우편번호
and   b.순번(+) = 1
```
PL/SQL 함수 내부 로직이 너무 복잡하면 그대로 쓸 수 밖에 없는데, 그럴 때 함수 호출 횟수를 줄이는 여러 방법이 있다. 그중 하나가 액세스 조건을 고려한 인덱스 구성이다.

### [효과적인 인덱스 구성을 통한 함수호출 최소화]
조건절에 아래와 같이 PL/SQL 함수를 사용했을 때, 회원 테이블을 Full Scan 방식으로 읽으면 encryption 함수는 테이블 건수만큼 수행된다.
```
select /*+ full(a) */ 회원번호, 회원명, 생년, 생월일, 등록일자
from   회원 a
where  암호화된_전화번호 = encryption( :phone_no )
```
아래와 같이 다른 조건절이 있으면, encryption 함수는 그 조건절(생년 = '1987')을 만족하는 건수만큼 수행된다.
```
select /*+ full(a) */ 회원번호, 회원명, 생년, 생월일, 등록일자
from   회원 a
where  생년 = '1987'
and    암호화된_전화번호 = encryption( :phone_no )
```

아래와 같이 인덱스를 세 개 만들어 보자.
```
create index 회원_X01 on 회원(생년);
create index 회원_X02 on 회원(생년, 생월일, 암호화된_전화번호);
create index 회원_X03 on 회원(생년, 암호화된_전화번호);
```
아래와 같이 생년 단일컬럼으로 구성한 회원_X01 인덱스를 사용하면, 암호화된_전화번호 조건절을 테이블 액세스 단계에서 필터링한다.
따라서 encryption 함수는 테이블 액세스 횟수 즉, 생년 = '1987'을 만족하는 건수만큼 수행된다.
```
select /*+ index(a 회원_x01) */ 회원번호, 회원명, 생년, 생월일, 등록일자
from   회원 a
where  생년 = '1987'
and    암호화된_전화번호 = encryption( :phone_no )

Execution Plan
---------------------------------------------------------
  0        SELECT STATEMENT Optimizer=ALL_ROWS (Cost=1 Card=1 Bytes=156)
  1    0     TABLE ACCESS (BY INDEX ROWID BATCHED) OF '회원' (TABLE) (Cost=1 ... )
  2    1       INDEX (RANGE SCAN) OF '회원_X01' (INDEX) (Cost=1 Card=1)
---------------------------------------------------------

Predicate information (identified by operation id):
---------------------------------------------------------
  1 - filter("암호화된_전화번호"="ENCRYPTION"(:PHONE_NO))
  2 - access("생년"='1987')
```
아래와 같이 [생년 + 생월일 + 암호화된_전화번호] 순으로 구성한 회원_X02 인덱스를 사용하면, 암호화된_전화번호는 선행 컬럼인 생월일에 대한 '=' 조건이 없으므로 인덱스 필터 조건이다.
따라서 encryption 함수는 인덱스 스캔 횟수 즉, 생년 = '1987' 조건을 만족하는 건수만큼 수행된다.
```
select /*+ index(a 회원_x02) */ 회원번호, 회원명, 생년, 생월일, 등록일자
from   회원 a
where  생년 = '1987'
and    암호화된_전화번호 = encryption( :phone_no )

Execution Plan
---------------------------------------------------------
  0        SELECT STATEMENT Optimizer=ALL_ROWS (Cost=1 Card=1 Bytes=156)
  1    0     TABLE ACCESS (BY INDEX ROWID BATCHED) OF '회원' (TABLE) (Cost=1 ... )
  2    1       INDEX (RANGE SCAN) OF '회원_X02' (INDEX) (Cost=2 Card=1)
---------------------------------------------------------

Predicate information (identified by operation id):
---------------------------------------------------------
  2 - access("생년"='1987' AND "암호화된_전화번호"="ENCRYPTION"(:PHONE_NO))
  2 - filter("암호화된_전화번호"="ENCRYPTION"(:PHONE_NO))
```
마지막으로 아래와 같이 [생년 + 암호화된_전화번호] 순으로 구성한 회원_X03 인덱스를 사용하면, 암호화된_전화번호도 생년과 함께 인덱스 액세스 조건으로 사용된다.
따라서 encryption 함수는 단 한 번 수행된다.
```
select /*+ index(a 회원_x03) */ 회원번호, 회원명, 생년, 생월일, 등록일자
from   회원 a
where  생년 = '1987'
and    암호화된_전화번호 = encryption( :phone_no )

Execution Plan
---------------------------------------------------------
  0        SELECT STATEMENT Optimizer=ALL_ROWS (Cost=2 Card=1 Bytes=156)
  1    0     TABLE ACCESS (BY INDEX ROWID BATCHED) OF '회원' (TABLE) (Cost=2 ... )
  2    1       INDEX (RANGE SCAN) OF '회원_X03' (INDEX) (Cost=1 Card=1)
---------------------------------------------------------

Predicate information (identified by operation id):
---------------------------------------------------------
  2 - access("생년"='1987' AND "암호화된_전화번호"="ENCRYPTION"(:PHONE_NO))
```