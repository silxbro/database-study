# 3.4 | 인덱스 설계

온라인 트랜잭션을 처리하는 시스템에서 인덱스 설계의 중요성은 아무리 강조해도 지나치지 않다. 인덱스 튜닝, 더 나아가 SQL 튜닝의 하이라이트라고 할 수 있다.
많은 경험과 고도의 기술력이 요구되는 매우 전문적인 설계 영역이기도 하다. 그런 전문성을 갖추려면 세밀한 인덱스 원리와 이론을 바탕으로 많은 시행착오를 겪어야 하는데, 인덱스 설계에 관한 시행착오를 줄일
수 있는 실무 노하우를 전반에 걸쳐 많이 소개하고 있다.

그 일환으로 지금까지 학습한 내용을 바탕으로 인덱스 설계에 필요한 여러 가지 판단 기준, 공식을 초월한 전략적 설계의 필요성, 방법론 등을 설명한다.

<br/>

## (1) 인덱스 설계가 어려운 이유
SQL 각각에 최적화된 인덱스를 마음껏 생성할 수 있다면, SQL 튜닝과 인덱스 설계만큼 쉬운 일도 없다. 몇 가지 공식만 알면 되기 때문이다.
하지만 그렇게 인덱스를 생성하다 보면 테이블마다 인덱스가 수십 개씩 달리게 되고, 관리비용뿐만 아니라 시스템 부하를 증가시키는 요인이 된다. 인덱스가 많으면 구체적으로 아래와 같은 문제가 생긴다.
- DML 성능 저하 (→ TPS 저하)
- 데이터베이스 사이즈 증가 (→ 디스크 공간 낭비)
- 데이터베이스 관리 및 운영 비용 상승

예를 들어 테이블에 인덱스가 여섯 개 달려 있으면, 신규 데이터를 입력할 때마다 여섯 개 인덱스에도 데이터를 입력해야 한다.
테이블과 달리 인덱스는 정렬 상태를 유지해야 하므로 수직적 탐색을 통해 입력할 블록부터 찾는다. 찾은 블록에 여유 공간이 없으면 인덱스 분할(Index Split)도 발생한다.
- 테이블은 레코드 간 정렬 상태를 유지할 필요가 없으므로 공간이 부족하면 새로운 블록을 할당받아서 값을 계속 입력한다. 하지만 인덱스는 정렬 상태를 유지해야 하므로 아무 블록에나 값을 입력할 수 없다.
  따라서 값을 입력할 위치에 공간이 없으면, 인덱스 분할(Split)을 통해 공간을 확보한다.

  예를 들어, 정렬 순서상 5번 리프 블록에 값을 입력해야 하는데, 그 블록이 꽉 차 있으면 새로운 블록을 5번과 6번 사이에 끼워 넣는다(인덱스는 양방향 연결 리스트 구조).
  그리고 5번 블록에 저장된 데이터 중 뒤쪽 절반을 6번 블록으로 옮긴다. 이런 식으로 공간을 확보한 후 값을 입력한다.


데이터를 지울 때도 마찬가지다. 여섯 개 인덱스에서 레코드를 일일이 찾아 지워줘야 한다. 핵심 트랜잭션이 참조하는 테이블에 대한 DML 성능 저하는 TPS 저하로 이어진다.
꼭 필요하지 않은 인덱스를 많이 만들면 디스크 공간을 낭비하고, 데이터베이스 사이즈가 커지는 만큼 백업, 복제, 재구성 등을 위한 운영 비용도 상승한다.

개별 쿼리 성능뿐만 아니라 그 개수를 최소화함으로써 DML 부하를 줄여야 하므로 인덱스 설계가 어렵다. SQL 튜닝은 그래서 어렵고, OLTP 환경에서 특히 그렇다.
인덱스 설계는 시스템 전체 시각에서 종합적, 전략적으로 접근해야 하는데, 전략을 논하기에 앞서 인덱스를 구성하는 기본원리부터 살펴보자.

- #### [진퇴양난 SQL 튜닝 - 개발 단계에서 최적 인덱스 설계의 중요성]

  인덱스 개수를 최소화하려면 기존 인덱스 구성을 변경함으로써 문제를 해결해야 하는데, 인덱스 변경에 따른 시스템 변경 영향도가 매우 커서 이 역시 쉽지 않다.
  영향받는 SQL을 모두 찾아 성능을 검증해야 하기 때문이다.
  시스템 개발 단계에서는 (개발 일정에 큰 영향을 주지 않는 범위 안에서) 비교적 쉽게 인덱스를 변경할 수 있지만, 개발을 마치고 운영 환경으로 이행하는 순간부터 인덱스 변경은 쉽지 않은 일이 돼 버린다.
  특히 금융권에선 거의 불가능에 가깝다.

  그나마 신규 인덱스 추가는 비교적 변경 영향도가 적다. 그래서 기존 인덱스를 변경해서 해결할 수 있는 문제도 신규 인덱스를 추가해서 해결하곤 하는데, 그럴수록 시스템 수준 TPS는 점점 나빠진다.

  정리하면, 인덱스 추가는 시스템에 부하를 주고, 인덱스 변경은 운영 리스크가 크다. 시스템 개발 단계에서 인덱스를 최적으로 설계하는 일이 무엇보다 중요한 이유가 바로 여기에 있다.
  특히 핵심 트랜잭션에 데이터를 추가, 변경, 삭제하는 테이블은 고도의 기술력을 가진 SQL 튜닝 전문가를 통해 인덱스를 정교하게 설계해야 한다.

  사실 도구의 지원도 필요하다. 인덱스 설계도를 작성하려면 각 테이블에 대한 액세스 경로를 모두 수집해서 패턴별로 정리해야 하는데, 이는 결코 쉬운 작업이 아니다.
  수천 개 테이블에 대한 수만 개 SQL을 수집해서 나온 수십만 개 액세스 경로를 패턴별로 압축해서 정리해야 하기 때문이다.
  이 작업에 드는 엄청난 시간과 노력을 줄이고 설계 품질을 높이려면, 자동화된 인덱스 설계 도구가 필요하다.

<br/>

## (2) 가장 중요한 두 가지 선택 기준
인덱스 스캔 방식에 여러 가지가 있지만, 가장 정상적이고 일반적인 방식은 Index Range Scan이라고 했다. 이를 위해서는 인덱스 선두 컬럼을 조건절에 반드시 사용해야 한다.
따라서 결합 인덱스를 구성할 때 첫 번째 기준은, 조건절에 항상 사용하거나, 자주 사용하는 컬럼을 선정하는 것이다.

두 번째 기준은, 그렇게 선정한 컬럼 중 '=' 조건으로 자주 조회하는 컬럼을 앞쪽에 두어야 한다는 것이다. 그 이유는 지금까지 충분히 설명하였다. 아래 두 가지 선택 기준을 공식처럼 외우기 바란다.
- [1] 조건절에 항상 사용하거나, 자주 사용하는 컬럼을 선정한다.
- [2] '=' 조건으로 자주 조회하는 컬럼을 앞쪽에 둔다.

<br/>

## (3) 스캔 효율성 이외의 판단 기준
방금 제시한 두 가지 선택기준이 인덱스를 설계할 때 일반적으로 사용하는 기본 공식임은 틀림없다. 하지만, 인덱스 설계가 그렇게 간단하지만은 않다.
공식대로 하려다 보면, 공식을 모르고 설계할 때보다 오히려 인덱스 개수가 더 늘어나는 현상도 경험하게 된다.

방금 설명한 공식은 인덱스 스캔 효율성이 판단 기준이었다. 그 외 고려해야 할 판단 기준을 나열하면 아래와 같다.
- 수행 빈도
- 업무상 중요도
- 클러스터링 팩터
- 데이터량
- DML 부하(= 기존 인덱스 개수, 초당 DML 발생량, 자주 갱신하는 컬럼 포함 여부 등)
- 저장 공간
- 인덱스 관리 비용 등

이런 다양한 판단 기준에 대한 해석이 서로 다르기 때문에 설계자의 성향이나 스타일에 따라 결과물도 크게 달라진다.
전장에서 똑같은 상황에 맞닥뜨리더라도 지휘관 스타일에 따라 전략과 전술이 달라지는 것처럼 말이다.

이 중 가장 중요한 하나를 꼽으라며녀 수행 빈도가 아닐까 싶다. 자주 수행하지 않는 SQL이면 인덱스 스캔 과정에 약간의 비효율이 있어도 큰 문제가 아닐 수 있다.
반면, 수행빈도가 매우 높은 SQL에는 앞서 설명한 공식을 이용해 최적의 인덱스를 구성해 줘야 한다.

수행빈도와 관련해, NL 조인할 때 어느 쪽에서 자주 액세스 되는지도 중요한 판단 기준이 된다.
NL 방식으로 조인하는 두 테이블이 있을 때, Outer 쪽(드라이빙 집합)에서 액세스하는 인덱스는 스캔 과정에 비효율이 있더라도 큰 문제가 아닐 수 있다.

예를 들어, 아래 SQL에서 거래쪽 인덱스를 [거래일자 + 거래구분코드] 순으로 구성하는 경우를 말한다.
```
select /*+ leading(a) use_nl(b) */
b.상품코드, b.상품명, a.고객번호, a.거래일자, a.거래량, a.거래금액
from    거래 a, 상품 b
where   a.거래구분코드 = 'AC'
and     a.거래일자 between '20090101' and '20090131'
and     b.상품번호 = a.상품번호
and     b.상품분류 = '가전'
```
거래 쪽 인덱스를 스캔하는 과정에 비효율이 있더라도 NL 조인 메커니즘 상 비효율은 한 번에 그친다.
불필요한 테이블 액세스는 발생하지 않으므로 아주 넓은 거래일자 구간으로 조회하지만 않는다면 성능도 비교적 나쁘지 않을 것이다.
당장 조회 성능에 별문제가 없고 자주 수행하는 SQL이 아니라면 굳이 스캔 효율을 높이기 위해 [거래구분코드 + 거래일자] 인덱스를 따로 안 만들어도 된다.

반대로, NL 조인에서 Inner 쪽 인덱스 스캔 과정에 비효율이 있다면, 이는 성능에 큰 문제를 야기할 수 있다.

아래 SQL에서 거래 쪽 인덱스를 [거래일자 + 상품번호 + 거래구분코드] 순으로 구성하는 경우가 그렇다.
BETWEEN 조건 컬럼이 인덱스 선두 컬럼이므로 Outer 테이블로부터 액세스하는 횟수만큼 비효율적인 스캔을 반복한다.
```
select /*+ leading(b) use_nl(a) */
b.상품코드, b.상품명, a.고객번호, a.거래일자, a.거래량, a.거래금액
from    거래 a, 상품 b
where   a.거래구분코드 = 'AC'
and     a.거래일자 between '20090101' and '20090131'
and     b.상품번호 = a.상품번호
and     b.상품분류 = '가전'
```
수행빈도가 매우 높은 SQL이라면, 테스트 과정에 당장 성능이 좋게 나오더라도 인덱스를 최적으로 구성해 줘야 한다.
NL 조인 Inner 쪽 인덱스는 '=' 조건 컬럼을 선두에 두는 것이 중요하고, 될 수 있으면 테이블 액세스 없이 인덱스에서 필터링을 마치도록 구성해야 한다.

데이터량도 인덱스를 설계할 때 중요한 판단 기준이다. 데이터량이 적다면 굳이 인덱스를 많이 만들 필요가 없다. Full Scan으로도 충분히 빠르기 때문이다.
반대로, 인덱스를 많이 만들어도 저장 공간이나 트랜잭션 부하 측면에서 그다지 문제될 것이 없다. 테이블이 작으면, 심각하게 고민할 이유가 없다는 것이다.

초대용량 테이블일 때는 어떨까? 초대용량 테이블은 INSERT도 많다. 앞서도 언급했듯, 초당 DML 발생량은 트랜잭션 성능(TPS)에 직접적인 영향을 준다.
그런 테이블에 인덱스를 설계할 때, 전문가의 순길이 필요하다. 진정한 튜닝 전문가는 이때 빛을 발한다. 인덱스를 하나라도 줄였을 때 그것이 시스템에 미치는 영향은 적지 않다.

<br/>

## (4) 공식을 초월한 전략적 설계
조건절 패턴이 열 개 있을 떄, 패턴마다 인덱스를 하나씩 만들 수는 없다. 그런 식이라면 앞에서 제시한 두 가지 공식만 알면 누구나 쉽게 설계할 수 있다.

SQL 튜닝 전문가라면, 열 개 중 최적을 달성해야 할 가장 핵심적인 액세스 경로 한두 개를 전략적으로 선택해서 최적 인덱스를 설계하고, 나머지 액세스 경로는 약간의 비효율이 있더라도 목표 성능을 만족하는
수준으로 인덱스를 구성할 수 있어야 한다. 그리고 왜 그런 선택을 했는지, 전략적 판단 근거가 무엇인지 답할 수 있어야 한다.
단순한 공식에 의한 결정이 아니라, 업무 상황을 이해하고 나름의 판단 기준을 가지고 결정을 내리라는 것이다.

예를 들어 보자. 어떤 보험사에 '가계약' 테이블이 있다. 가계약 목록을 조회할 때 다양한 방식으로 조회한다.
우선, 드롭다운 리스트(콤보박스)에서 취급부서, 취급지점, 취급자, 입력자, 대리점설계사, 대리점지사 중 하나를 선택한다. 조건절 연산자는 '='이다.
그리고 청약일자, 보험개시일자, 보험종료일자, 데이터생성일시 중 하나를 선택한다. 조건절 연산자는 BETWEEN이다. 선택한 두 항목에 대한 값을 입력하고 조회 버튼을 누른다.

이런 상황에서 인덱스 스캔 효율을 위해 '=' 조건 컬럼을 앞에, BETWEEN 조건 컬럼을 뒤에 두려면 24개(6✕4) 인덱스가 필요하다.
가계약 테이블에는 INSERT가 매우 많이 발생하는데, 과연 인덱스를 24개나 만들 것인가? 전략적인 판단이 필요하다.

일자/일시 조건을 선두에 두고, 자주 사용하는 필터 조건을 모두 뒤쪽에 추가하는 방식은 어떨까?
- X01 : 청약일자 + 취급부서 + 취급지점 + 취급자 + 입력자 + 대리점설계사 + 대리점지사
- X02 : 보험개시일자 + 취급부서 + 취급지점 + 취급자 + 입력자 + 대리점설계사 + 대리점지사
- X03 : 보험종료일자 + 취급부서 + 취급지점 + 취급자 + 입력자 + 대리점설계사 + 대리점지사
- X04 : 데이터생성일시 + 취급부서 + 취급지점 + 취급자 + 대리점설계사 + 대리점지사

이렇게 설계한 핵심 포인트는 두 가지다.
첫째, 일자 조회구간이 길지 않으면 인덱스 스캔 비효율이 성능에 미치는 영향이 크지 않다는 점이다. 둘째, 인덱스 스캔 효율보다 **테이블 액세스가 더 큰 부하요소**라는 점이다.

가계약은 주로 최근 3일 이내 데이터를 조회한다. 대개는 전일자로 조회하므로 인덱스 스캔량은 그리 많지 않다. 가끔 3일을 초과한 기간으로 조회할 수 있고, 어쩌다 한 달 치를 조회할 수도 있다.
그렇더라도 불필요한 테이블 액세스는 전혀 발생하지 않도록 설계했으므로 사용자가 인내할 수 있는 수준의 성능은 낼 수 있다.

사용자가 인내할 수 있는 수준의 인덱스 스캔 비효율이더라도 BETWEEN 조건 컬럼을 선두에 두고 설계하는 것은 좀 찜찜하다. 그런데도 이 결정을 한 이유는 따로 있다.
가계약 테이블을 다양한 패턴으로 조회하지만, 그중 가장 많이 사용(85% 이상)하는 패턴은 입력자 '=', 데이터생성일시 BETWEEN 조건이기 때문이다.
따라서 이 패턴에 최적의 스캔 효율을 제공하면, 다른 패턴에 다소 비효율이 있어도 업무에 크게 지장이 없다고 판단한 것이다.

앞서 설계한 네 개 인덱스에 아래 인덱스를 하나 더 추가하자. (X04 인덱스에 입력자 컬럼은 누락된 것이 아니라 이 인덱스가 있어서 일부러 뺐다.)
- X05 : 입력자 + 데이터생성일시

공식대로 설계하려면 24개 인덱스가 필요하지만, 업무 상황을 고려한 전략적 판단을 통해 다섯 개로 줄였다.
이렇게 인덱스 개수를 최소화하면, 사용빈도가 높거나 중요한 인덱스 경로가 새로 도출됐을 때 최적의 인덱스를 추가할 여유도 생긴다.

<br/>

## (5) 소트 연산을 생략하기 위한 컬럼 추가
인덱스는 항상 정렬 상태를 유지하므로 ORDER BY, GROUP BY를 위한 소트 연산을 생략할 수 있게 해 준다.
따라서 조건절에 사용하지 않는 컬럼이라도 소트 연산을 생략할 목적으로 인덱스 구성에 포함시킴으로써 성능 개선을 도모할 수 있다.

아래 쿼리에 ORDER BY 절이 있음에도 불구하고 소트 연산이 발생하지 않도록 인덱스를 구성해보자.
```
select 계약ID, 청약일자, 입력자ID, 계약상태코드, 보험시작일자, 보험종료일자
from   계약
where  취급지점ID = :trt_brch_id
and    청약일자 between :sbcp_dt1 and :sbcp_dt2
and    입력일자 >= trunc(sysdate - 3)
and    계약상태코드 in (:ctr_stat_cd1, :ctr_stat_cd2, :ctr_stat_cd3)
order by 청약일자, 입력자ID
```
성능을 고려하지 않아도 된다면, 소트 연산을 생략하도록 인덱스 구성하는 일은 너무 쉽다. ORDER BY 절 순서대로 [청약일자 + 입력자ID]로 구성하면 된다.

'=' 조건절 컬럼은 ORDER BY 절에 없더라도 인덱스 구성에 포함할 수 있다. 위 SQL에선 취급지점ID가 '=' 조건이다.
이를 포함해 [청약일자 + 취급지점ID + 입력자ID] 순으로 구성해도 소트 연산을 생략할 수 있다는 뜻이다. 위치는 앞뒤 중간 어디에 두어도 상관없다.

'='이 아닌 조건절 컬럼은 반드시 ORDER BY 컬럼보다 뒤쪽에 두어야(예를 들어, 청약일자 + 입력자ID + 입력일자 + 계약상태코드) 소트 연산을 생략할 수 있다.

인덱스를 그렇게 구성하면 일단 소트는 생략할 수 있다. 문제는 성능인데, 조건을 만족하는 데이터를 빨리 만날 수 있느냐가 관건이다.
다행히 앞쪽에서 만나면 결과집합이 빨리 출력되기 시작하겠지만, 불행하게도 맨 뒤쪽에서 만나면 사용자는 그때까지 손 놓고 기다려야만 한다.
그 순간 DBMS 내부에서는 많은 I/O가 발생하고 있을 것이다.(테이블 필터까지 있다면 어마어마한 I/O가 발생한다.)

I/O를 최소화하면서도 소트 연산을 생략하려면, 아래 공식에 따라 인덱스를 구성하면 된다.
- [1] '=' 연산자로 사용한 조건절 컬럼 선정
- [2] ORDER BY 절에 기술한 컬럼 추가
- [3] '=' 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정

이 공식에 따라 위에서 제시한 SQL에는 인덱스를 [취급지점ID + 청약일자 + 입력자ID] 순으로 구성한다.

입력일자와 계약상태코드는 뒤쪽에 붙여도 되고 안 붙여도 된다. 이들 조건을 만족하는 데이터가 적으면, 인덱스에 추가하는 게 좋다.
테이블 랜덤 액세스를 줄일 수 있기 때문이다. 이들 조건을 만족하는 데이터가 많으면, 굳이 인덱스에 추가하지 않아도 된다.
테이블에서 필터링할 때와 큰 성능 차이가 없기 때문이다. 단 몇 회라도 테이블 액세스를 줄이면 조회 성능은 좋지만, 반대급부도 생각해야 한다.

### [IN 조건은 '='이 아니다]
방금 본 사례에서 계약상태코드를 인덱스 앞쪽에 두어도 소트연산을 생략할 수 있다고 생각했을 수 있다. IN 조건은 '='이라고 생각하는 분들이 그랬을 것이다.

앞에서도 강조했듯, IN 조건은 '='이 아니다. 아래 SQL을 예로 들어보자.
```
select 고객번호, 고객명, 거주지역, 혈액형, 연령
from   고객
where  거주지역 = '서울'
and    혈액형 in ( 'A', 'O' )
order by 연령
```
인덱스는 [거주지역 + 혈액형 + 연령] 순으로 구성했다.

IN 조건이 '='이 되려면 IN-List Iterator 방식으로 풀려야 한다. IN-List Iterator 방식으로 푼다는 건 SQL을 아래와 같은 방식으로 실행한다는 의미다.
그러면 IN 조건이 '='이 됐지만, UNION ALL 위아래 두 집합을 묶어 '연령' 순으로 정렬하는 문제가 남는다.
```
select  고객번호, 고객명, 거주지역, 혈액형, 연령
from    고객
where   거주지역 = '서울'
and     혈액형 = 'A'
union all
select  고객번호, 고객명, 거주지역, 혈액형, 연령
from    고객
where   거주지역 = '서울'
and     혈액형 = 'O'
order by 연령
```
ORDER BY 절이 있음에도 불구하고 소트 연산을 생략하려면, 위쪽 브랜치를 실행하고 이어서 아래쪽을 실행했을 때 그 결과가 연령 순으로 정렬돼야 한다.
그것이 가능하려면, 서울에 거주하는 모든 'A'형 고객이 'O'형 고객보다 연령이 낮아야 한다. 불가능한 일이므로 옵티마이저는 결코 소트 연산을 생략하지 않는다.
인덱스를 [혈액형 + 거주지역 + 연령] 순으로 구성해도 마찬가지다.

결론적으로, 소트 연산을 생략하려면 IN 조건절이 IN-List Iterator 방식으로 풀려선 안 된다. 즉, IN 조건절을 인덱스 액세스 조건으로 사용하면 안 된다. 필터 조건으로 사용해야 한다.
따라서 인덱스를 [거주지역 + 연령 + 혈액형] 순으로 구성해야 한다.
- IN-List 컬럼이 ORDER BY 절에 있으면 (본문 예에서 혈액형을 ORDER BY 절 앞쪽에 두면), 인덱스를 [거주지역 + 혈액형 + 연령] 순으로 구성하더라도 소트 연산을 생략할 수 있다.
  오라클이 IN-List 목록을 정렬하고 나서 액세스 조건으로 사용하기 때문이다. 물론, 필터 조건으로 사용하더라도 정렬 순서상 소트 생략이 가능하다.

<br/>

## (6) 결합 인덱스 선택도
인덱스 생성 여부를 결정할 때는 선택도가 충분히 낮은지가 중요한 판단기준이다.
'선택도(Selectivity)'란, 전체 레코드 중에서 조건절에 의해 선택되는 레코드 비율을 말하며, 선택도에 총 레코드 수를 곱해서 '카디널리티'를 구한다.
'인덱스 선택도'는 인덱스 컬럼을 모두 '='로 조회할 때 평균적으로 선택되는 비율을 의미한다. 선택도가 높은(카디널리티가 높은) 인덱스는 생성해봐야 효용가치가 별로 없다.
테이블 액세스가 많이 발생하기 때문이다.

따라서 인덱스를 생성할 때는 반드시 선택도/카디널리티를 확인해야 한다.

아래는 계약ID와 취급지점ID, 두 컬럼에 대한 카디널리티를 조회하는 쿼리다.
```
select count(*) as NDV, max(cnt) as MX_CARD, min(cnt) as MN_CARD, avg(cnt) as AVG_CARD
from (
    select  계약ID, 취급지점ID, count(*) as cnt
    from    계약조직
    where  (계약ID is not null or 취급지점ID is not null)
    group by 계약ID, 취급지점ID
)
```

### [컬럼 순서 결정 시, 선택도 이슈]
결합 인덱스 컬럼 간 순서를 정할 때도 선택도가 중요할까? 결합 인덱스를 구성할 때 선택도가 낮은(변별력이 높은) 컬럼을 앞에 두는 것이 유리하다고 흔히 알려져서 하는 질문이다.

구체적인 예로 아래 쿼리에서 고객번호를 앞에 두는 것이 유리하다고 생각하겠지만, 그렇지 않다. 성별과 고객번호 중 어떤 컬럼이 앞으로 오든 인덱스 스캔 효율에 전혀 차이가 없다.
둘 다 인덱스 액세스 조건이므로 어떤 컬럼이 앞으로 오든 인덱스 스캔 범위는 똑같다.
```
  WHERE 성별        =  :GENDER
  AND   고객번호     =  :CUST_NO
```
인덱스 설계할 때 우리가 할 일은 '항상 사용하는' 컬럼을 앞쪽에 두고 그 중 '=' 조건을 앞쪽에 위치시키는 것뿐이다. 그중 선택도가 낮은 컬럼을 앞쪽에 두려는 노력은 의미 없거나 오히려 손해일 수 있다.

예를 들어, 아래 네 개 조건절이 있다.
```
< 조건절 1 >
WHERE  고객등급  = :V1
AND    고객번호  = :V2
AND    거래일자 >= :V3

< 조건절 2 >
WHERE  고객등급  = :V1
AND    고객번호  = :V2
AND    거래일자 >= :V3
AND    거래유형  = :V4

< 조건절 3 >
WHERE  고객등급  = :V1
AND    고객번호  = :V2
AND    거래일자 >= :V3
AND    상품번호  = :V5

< 조건절 4 >
WHERE  고객등급  = :V1
AND    고객번호  = :V2
AND    거래일자 >= :V3
AND    거래유형  = :V4
AND    상품번호  = :V5
```
여기서 '항상 사용하는' 고객번호, 고객등급, 거래일자 중 고객번호와 고객등급은 '=' 조건, 거래일자는 BETWEEN 조건이다.
그리고 거래유형과 상품번호는 항상 사용하는 조건이 아니어서 인덱스를 다음과 같이 구성하려고 한다.

> IDX : 고객등급 + 고객번호 + 거래일자 + 거래유형 + 상품번호

여기서 고객등급과 고객번호 중 어떤 컬럼이 앞으로 오든 인덱스 스캔 효율에 전혀 영향을 주지 않는다. 거래일자까지 세 컬럼이 액세스 조건이므로 인덱스 스캔 범위는 똑같다.

거래유형과 상품번호 간에도 어떤 컬럼이 앞으로 오든 인덱스 스캔 효율에 영향을 주지 않는다.
인덱스 스캔 범위가 고객등급, 고객번호, 거래일자에 의해 결정되므로 둘 중 어떤 컬럼이 앞으로 오든 인덱스 스캔 효율에 차이가 없다. 심지어 이들 컬럼에 어떤 연산자를 사용해도 상관없다.

고객등급, 고객번호 둘 다 필수 '=' 조건이면 어떤 컬럼이 앞으로 오든 상관없지만, 둘 중 하나 이상이 조건절에서 누락되거나 범위검색 조건일 수 있다면 얘기가 복잡해진다.
고객번호는 필수인데 고객등급이 조건절에서 누락되거나 범위검색 조건일 수 있는 경우만 설명하면, 이때는 고객등급을 앞쪽에 두는 것이 유리하다. Index Skip Scan이나 IN-List 조건을 활용할 수 있기 때문이다.
인덱스를 압축할 경우, 고객등급을 앞쪽에 두면 압축률이 더 좋은 측면도 있다.

결론적으로, 인덱스 생성 여부를 결정할 때는 선택도가 매우 중요하지만, 컬럼 간 순서를 결정할 때는 각 컬럼의 선택도보다 필수 조건 여부, 연산자 형태가 더 중요한 판단 기준이다.
어느 컬럼을 앞에 두는 것이 유리한지는 상황에 따라 판단할 일이다.

<br/>

## (7) 중복 인덱스 제거
아래 세 인덱스는 중복이다. X02 인덱스 선두 컬럼이 X01 인덱스 전체를 완전히 포함하고, X03 인덱스 선두 컬럼이 X01과 X02 인덱스 전체를 완전히 포함하기 때문이다.
필자는 이를 '완전 중복'이라고 부른다. X03 인덱스를 남기고, X01, X02 인덱스는 삭제해도 된다.
- X01 : 계약ID + 청약일자
- X02 : 계약ID + 청약일자 + 보험개시일자
- X03 : 계약ID + 청약일자 + 보험개시일자 + 보험종료일자

아래 네 개 인덱스는 얼핏 보기엔 중복이 아니다. 선두 컬럼은 같지만, 두 번째 컬럼이 모두 다르기 때문이다.
- X01 : 계약ID + 청약일자
- X02 : 계약ID + 보험개시일자
- X03 : 계약ID + 보험종료일자
- X04 : 계약ID + 데이터생성일시

하지만, 계약ID의 평균 카디널리티가 매우 낮다면 사실상 중복이다.

예를 들어, 계약ID 평균 카디널리티가 5라고 가정하자. 계약ID를 '=' 조건으로 조회하면, 평균 다섯 건이 조회된다는 뜻이다. 그렇다면 이렇게 인덱스를 네 개씩이나 만들 이유가 없다.
아래와 같이 하나만 만들면 충분하다. 필자는 '완전중복'과 대비해 이를 '불완전 중복'이라고 부른다.

> X01 : 계약ID + 청약일자 + 보험개시일자 + 보험종료일자 + 데이터생성일시

### [중복제거 실습 1]
아래 다섯 인덱스 중에서 중복 인덱스를 찾아 재설계해 보자.
- PK : 거래일자 + 관리지점번호 + 일련번호
- N1 : 계좌번호 + 거래일자
- N2 : 결제일자 + 관리지점번호
- N3 : 거래일자 + 종목코드
- N4 : 거래일자 + 계좌번호

거래일자, 결제일자는 항상 BETWEEN 또는 부등호 조건으로 조회한다. 각 컬럼의 데이터 분포는 다음과 같다. NDV는 'Number of Distinct Values'의 약자이다.
컬럼에 입력된 값의 종류 개수를 의미한다.

|컬럼명|NDV|
|:---|---:|
|거래일자|2,356|
|관리지점번호|127|
|일련번호|1,850|
|계좌번호|5,956|
|종목코드|1,715|
|결제일자|2,356|

중복 인덱스가 보이는가? 거래일자가 항상 BETWEEN 또는 부등호 조건이면 N3와 N4 인덱스는 둘 다 거래일자가 인덱스 액세스 조건이다. 그렇다면 인덱스를 두 개나 만들 필요가 없다.
아래와 같이 N4 인덱스를 제거하고, N3 인덱스 뒤쪽에 계좌번호를 추가하면 된다.
- PK : 거래일자 + 관리지점번호 + 일련번호
- N1 : 계좌번호 + 거래일자
- N2 : 결제일자 + 관리지점번호
- N3 : 거래일자 + 종목코드 + 계좌번호
- ~~N4 : 거래일자 + 계좌번호~~

두 번째 방안으로, N3 인덱스 변경 없이 그냥 N4 인덱스를 제거해도 된다.
계좌번호와 거래일자로 조회하거나 계좌번호 단독으로 조회할 때는 N1 인덱스를 사용하고, 거래일자만으로 조회할 때는 N3 인덱스를 사용하면 되기 때문이다.

|조건절|인덱스|
|:---|:---:|
|계좌번호 =|N1|
|계좌번호 = , 거래일자 =|N1|
|계좌번호 = , 거래일자 BETWEEN|N1|
|거래일자 =|N3|
|거래일자 BETWEEN|N3|

최종적으로 아래와 같이 설계하면 어떨까?
- PK : 관리지점번호 + 거래일자 + 일련번호
- N1 : 계좌번호 + 거래일자
- N2 : 결제일자 + 관리지점번호
- N3 : 거래일자 + 종목코드
- ~~N4 : 거래일자 + 계좌번호~~

기존에 관리지점번호가 선두 컬럼인 인덱스가 없었으므로 관리지점번호 단독으로 조회하는 경우는 없었던 것 같다. 그렇다고 PK를 그대로 두면 관리지점번호 '=', 거래일자 BETWEEEN으로 조회할 때 비효율적이다.
방금 제시한 초종안으로 설계하면, 관리지점번호와 거래일자로 조회할 때는 PK 인덱스를 사용하고, 거래일자만으로 조회할 때는 N3 인덱스를 사용하면 된다.

|조건절|인덱스|
|:---|:---:|
|관리지점번호 = ,거래일자 = |PK|
|관리지점번호 = , 거래일자 BETWEEN|PK|
|거래일자 =|N3|
|거래일자 BETWEEN|N3|

### [중복제거 실습 2]
실습을 하나 더 해 보자. 인덱스 설계는 조건절 분석 과정이 필수지만, 조건절 없이도 중복 인덱스를 찾아내는 경우가 있다. 아래에서 중복 인덱스를 찾아 재설계해 보자.
- PK : 주소ID + 건물동번호 + 건물호번호 + 관리번호
- N1 : 상태구분코드 + 관리번호
- N2 : 관리번호
- N3 : 주소ID + 관리번호

각 칼럼의 데이터 분포는 다음과 같다.

|컬럼명|NDV|
|:---|---:|
|주소ID|736,000|
|건물동번호|175|
|건물호번호|3,052|
|관리번호|250,782|
|상태구분코드|3|

이제 중복 인덱스가 보이기 시작하는가? 상태구분코드는 NDV가 3이므로 선택도가 매우 높다. 상태구분코드로만 조회할 때는 N1 인덱스가 사용되지 않는다는 뜻이다.
N1 인덱스가 사용되려면, 상태구분코드와 관리번호를 같이 조회해야 한다.

N2 인덱스는 관리번호로 조회할 때만 아래와 같이 N2 인덱스를 제거하고, N1 인덱스를 [관리번호 + 상태구분코드] 순으로 변경해 보자.
관리번호로만 조회하든, 상태구분코드까지 같이 조회하든 N1 인덱스를 사용하면 된다.
- PK : 주소ID + 건물동번호 + 건물호번호 + 관리번호
- N1 : 관리번호 + 상태구분코드
- ~~N2 : 관리번호~~
- N3 : 주소ID + 관리번호

여기서 주의할 점이 하나 있다. 상태구분코드 NDV가 3이긴 하나, 그중 특정 값은 변별력이 매우 좋을 수 있다는 점이다.
만약 그 값으로 조회할 때 사용할 목적으로 N1 인덱스를 만들었다면, N1 인덱스 구성을 바꾸면 문제가 생길 수 있다.

<br/>

## (8) 인덱스 설계도 작성
앞에서도 얘기했듯이 인덱스 설계 시 시스템 전체 효율을 고려해야 한다.

#### [표 3-8] 인덱스 설계도 예시
- 상단 좌측([1])을 보면 '변경 전 인덱스 구성' 필드가 있고, 우측([2])에는 '변경 후 인덱스 구성' 필드가 있다.
  전자는 말 그대로 현재의 인덱스 구성을 데이터베이스 딕셔너리에서 읽어 기록한 것이고, 후자는 새로운 구성 전략을 기록한 것이다.
- 개별 SQL이 아니라 전체를 보면서 전략을 수립하려면 일단 테이블별로 실제 발생하는 액세스 유형을 모두 조사하는 과정이 필요한데, 표의 중간부터 아래쪽까지 작성된 '액세스 경로([3])가 그것이다.
  17번 액세스 경로를 예로 들면, 조건절에 사용한 비교 연산자가 [물건종류 =, 도시 =, 구시군 =, 읍면동 =, CO9 <>, 입력일 >=]인 경우를 표시한 것이다.
  그리고 그 아래쪽을 보면 현재 인덱스 구성([1])에서는 6번 인덱스(IDX06)을 사용하지만 구성을 변경([2])하고 나면 3번(IDX3) 인덱스를 사용하게 될 것임을 표시하고 있다.
- 설계도 상단에 파티션 구성을 기록하는 필드를 둔 것도 주목하기 바란다. 인덱스 설계 전에 파티션 설계를 먼저 진행하거나 최소한 병행해야 제대로 된 인덱스 전략을 수립할 수 있다.
  그래서 파티션 구성도 참조하도록 했다.

### [인덱스 설계도 작성을 통한 튜닝 사례]
표 3-8을 보면, 매물 테이블에 사용된 액세스 경로가 총 25개인데, 인덱스가 무려 15개나 달린 것을 볼 수 있다.
이런 매물 테이블이 20여 개(아파트매매, 아파트전세, 아파트월세, 점포매매, 점포임대, 토지매매, 토지임대 등)에 이르고, 인덱스가 모두 같은 패턴으로 설계돼 있었다.

조회를 빠르게 하려고 이렇게 많은 인덱스를 만들어 놓았지만 조회해 보면 어떤 매물조회 화면이든지 수십 초에서 수분이 경과해야 결과를 볼 수 있었다. 원인이 무엇이었을까?
현재 인덱스 구성과 액세스 경로를 잘 분석해 보면, 대부분 액세스 경로에 '입력일 >=' 조건이 포함되어 있다. 그리고 변경 전 인덱스 구성에서 대부분 인덱스 선두 컬럼이 '입력일'인 것도 확인할 수 있다.

상황을 더 심각하게 만든 것은, 선두컬럼 입력일 조건에 해당하는 범위가 인덱스 전체 레코드에서 95% 이상이라는 사실이다.
매물 테이블에는 최근 한달 치 데이터만 보관해야 하는데, 과거 데이터가 정확히 커팅(cutting) 되지 않았을 때 한달을 초과한 매물이 함께 조회되는 현상을 막으려고 입력일 조건을 대부분 쿼리에 포함시켰던 것이다.
조건절에 항상 사용하는 컬럼이 인덱스 선두로서 1순위 후보지만 '=' 조건이어야 한다는 사실을 몰랐다면 누구라도 이런 실수를 할 수 있다.

열다섯 개나 되던 인덱스를 표 우측 상단([2])처럼 다섯 개로 줄이면서 입력일 컬럼을 모두 제거하는 새로운 인덱스 구성 전략을 수립하였고, 인덱스 생성 스크립트까지 작성해서 DBA 팀에 넘겨주었다.
그 다음 날 아침 눈을 뜨자마자 사이트에 접속해 보니 하루 전만 하더라도 수분씩 걸리던 대부분 화면에서 검색결과가 바로바로 출력되는 것을 확인할 수 있었다.