# 5.3 | 인덱스를 이용한 소트 연산 생략
인덱스는 항상 키 컬럼 순으로 정렬된 상태를 유지한다. 이를 활용하면 SQL에 Order By 또는 Group By 절이 있어도 소트 연산을 생략할 수 있다.
여기에 Top N 쿼리 특성을 결합하면, 온라인 트랜잭션 처리 시스템에서 대량 데이터를 조회할 때 매우 빠른 응답 속도를 낼 수 있다.
특정 조건을 만족하는 최소값 또는 최대값도 빨리 찾을 수 있어 이력 데이터를 조회할 수 있어 매우 유용하다.

<br/>

## (1) Sort Order By 생략
인덱스 선두 컬럼을 [종목코드 + 거래일시] 순으로 구성하지 않으면, 아래 쿼리에서 소트 연산을 생략할 수 없다.
```
select 거래일시, 체결건수, 체결수량, 거래대금
from   종목거래
where  종목코드 = 'KR123456'
order by 거래일시
```
종목코드 = 'KR123456' 조건을 만족하는 레코드를 인덱스에서 모두 읽어야 하고, 그만큼 많은 테이블 랜덤 액세스가 발생한다.
모든 데이터를 다 읽어 거래일시 순으로 정렬을 마치고서야 출력을 시작하므로 OLTP 환경에서 요구되는 빠른 응답 속도를 내가 어렵다. 아래는 인덱스로 소트 연산을 생략할수 없을 때 나타나는 실행계획이다.

```
-----------------------------------------------------------------------------------
| Id  | Operation                      | Name        | Rows  | Bytes | Cost (%CPU)|
-----------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |             | 40000 |  3515K|  2041   (1)|
|   1 |   SORT ORDER BY                |             | 40000 |  3515K|  2041   (1)|
|   2 |     TABLE ACCESS BY INDEX ROWID| 종목         | 40000 |  3515K|  1210   (1)|
|*  3 |       INDEX RANGE SCAN         | 종목거래_N1   | 40000 |       |    96   (1)|
-----------------------------------------------------------------------------------

Predicate Information (identified by operation id):
-----------------------------------------------------
  2 - access("종목코드"='KR123456')
```
인덱스 선두 컬럼을 [종목코드 + 거래일시] 순으로 구성하면 소트 연산을 생략할 수 있다. 아래는 그렇게 구성한 인덱스를 사용할 때의 실행계획이다.
SQL 문에 Order By 절이 있는데도 옵티마이저가 Sort Order By 오퍼레이션을 생략한 사실을 확인하기 바란다.
```
---------------------------------------------------------------------------------
| Id  | Operation                    | Name        | Rows  | Bytes | Cost (%CPU)|
---------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |             | 40000 |  3515K|  1372   (1)|
|   1 |   TABLE ACCESS BY INDEX ROWID| 종목         | 40000 |  3515K|  1372   (1)|
|*  2 |     INDEX RANGE SCAN         | 종목거래_PK   | 40000 |       |   258   (1)|
---------------------------------------------------------------------------------

Predicate Information (identified by operation id):
-----------------------------------------------------
  2 - access("종목코드"='KR123456')
```
소트 연산을 생략함으로써 종목코드 = 'KR123456' 조건을 만족하는 전체 레코드를 읽지 않고도 바로 결과집합 출력을 시작할 수 있게 되었다. 즉, 부분범위 처리 가능한 상태가 되었다.
이 원리를 잘 활용하면, 소트해야 할 대상 레코드가 무수히 많은 상황에서 극적인 성능 개선 효과를 얻을 수 있다.

### [부분범위 처리를 활용한 튜닝 기법, 아직도 유효한가?]
지금까지 부분범위 처리 원리를 여러 곳에서 강조해 왔고, 방금도 그랬다. 그런데 많은 분이 요즘 DB 애플리케이션은 대부분 3-Tier 환경에서 작동하므로 부분범위 처리는 의미 없다고 생각한다.
3-Tier 환경에서 부분범위 처리는 정말 의미 없어져 버린걸까?

부분범위 처리는 쿼리 수행 결과 중 앞쪽 일부를 우선 전송하고 멈추었다가 클라이언트가 추가 전송을 요청(그리드 스크롤 또는 '다음' 버튼 클릭을 통한 Fetch Call) 할 때마다 남은 데이터를 조금씩 나눠
전송하는 방식을 말한다.
토드나 오렌지가 DB 서버에 접속하듯, 클라리언트 프로그램이 DB 서버에 직접 접속하는 2-Tier 환경에서는 이 특징을 활용한 튜닝 기법을 많이 활용했다.

클라이언트와 DB 서버 사이에 WAS, AP 서버 등이 존재하는 3-Tier 아키텍처는 서버 리소스를 수많은 클라이언트가 공유하는 구조이므로 클라이언트가 특정 DB 커넥션을 독점할 수 없다.
단위 작업을 마치면 DB 커넥션을 바로 커넥션 풀에 반환해야 하므로 그 전에 쿼리 조회 결과를 클라이언트에게 '모두' 전송하고 커서(Cursor)를 닫아야만 한다.
따라서 쿼리 결과 집합을 조금씩 나눠서 전송하는 방식을 사용할 수 없다.
- JAVA 기준으로 Statement와 ResultSet 객체, 마이크로소프트 ADODB 기준으로 Command와 Recordset 객체가 커서 역할을 한다.

부분범위 처리 활용은 첫째, 결과집합 출력을 바로 시작할 수 있느냐 둘째, 앞쪽 일부만 출력하고 멈출 수 있느냐가 핵심이므로 3-Tier 환경에서 의미 없다고 생각할 만하다.
하지만, 부분범위 처리 원리는 3-Tier 환경에서도 여전히 유효하다. 비밀은 바로 Top N 쿼리에 있다.

<br/>

## (2) Top N 쿼리
우선 Top N 쿼리가 무엇인지부터 살펴보자. Top N 쿼리는 전체 결과집합 중 상위 N개 레코드만 선택하는 쿼리다. SQL Server나 Sybase는 Top N 쿼리를 아래와 같이 손쉽게 작성할 수 있다.
```
select TOP 10 거래일시, 체결건수, 체결수량, 거래대금
from   종목거래
where  종목코드 = 'KR123456'
and    거래일시 >= '20180304'
order by 거래일시
```
IBM DB2는 아래와 같은 Row Limiting 절을 제공한다.
```
select 거래일시, 체결건수, 체결수량, 거래대금
from   종목거래
where  종목코드 = 'KR123456'
and    거래일시 >= '20180304'
order by 거래일시
FETCH FIRST 10 ROWS ONLY  ;
```
오라클에서는 아래처럼 인라인 뷰로 한 번 감싸야 하는 불편함이 있다.
```
select * from (
  select 거래일시, 체결건수, 체결수량, 거래대금
  from   종목거래
  where  종목코드 = 'KR123456'
  and    거래일시 >= '20180304'
  order by 거래일시
)
where rownum <= 10
```
- 오라클도 12c부터 DB2와 같은 Row Limiting 절을 지원한다. 하지만, 지금부터 설명하려는 'Top N Stopkey' 알고리즘이 잘 작동하지 않는 경우가 있어 아직은 사용하는 데 있어 유보적이다.
  따라서 전통적인 방식 기준으로 설명한다.

SQL 형태만 놓고 보면, 인라인 뷰로 정의한 집합을 모두 읽어 거래일시 순으로 정렬한 중간 집합을 우선 만들고, 거기서 상위 열 개 레코드를 취하는 형태다.
소트를 생략할 수 있도록 인덱스를 구성해 주더라도 중간집합을 만들어야 하므로 부분범위 처리는 불가능해 보인다.
하지만, 위 쿼리에 [종목코드 + 거래일시] 순으로 구성된 인덱스를 이용하면, 옵티마이저는 소트 연산을 생략하며, 인덱스를 스캔하다가 열 개 레코드를 읽는 순간 바로 멈춘다.

아래 실행계획을 보면, Sort Order By 오퍼레이션이 보이지 않는다. 대신 'COUNT (STOPKEY)'가 눈에 띈다.
이는 조건절에 부합하는 레코드가 아무리 많아도 그 중 ROWNUM으로 지정한 건수만큼 결과 레코드를 얻으면 거기서 바로 멈춘다는 뜻이다.
지금부터 이 기능을 'Top N Stopkey' 알고리즘이라고 부르기로 하자.
```
Execution Plan
------------------------------------------------------------------------------------
0      SELECT STATEMENT Optimizer=ALL_ROWS
1  0     COUNT (STOPKEY)
2  1       VIEW
3  2         TABLE ACCESS (BY INDEX ROWID) OF '종목거래' (TABLE)
4  3           INDEX (RANGE SCAN) OF '종목거래_PK' (INDEX (UNIQUE))
```

### [페이징 처리]
이제 3-Tier 환경에서 부분범위 처리를 어떻게 응용할지 아이디어가 생겼는가? 답은 **페이징 처리**에 있다. 지금부터 페이징 처리에 대한 얘기를 시작해 보자.

3-Tier 환경에서는 대량의 결과집합을 조회할 때 페이징 처리 기법을 활용한다. 일반적으로 사용하는 표준 패턴은 아래와 같다.
```
select *
from (
  select rownum no, a.*
  from
    (

    /* SQL Body */

    ) a
  where rownum <= (:page * 10)
  )
where no >= (:page-1)*10 + 1
```
Top N 쿼리이므로 ROWNUM으로 지정한 건수만큼 결과 레코드를 얻으면 거기서 바로 멈춘다.
뒤쪽 페이지로 이동할수록 읽는 데이터량도 많아지는 단점이 있지만, 보통 앞쪽 일부 데이터만 확인하므로 문제가 되지 않는다.
예를 들어, 인터넷 카페 게시글 목록을 조회하거나 은행 사이트에서 입출금 내역을 조회할 때 일반적으로 1 ~ 2 페이지만 확인한다.

3-Tier 환경에서 부분범위 처리를 활용하기 위해 우리가 할 일은 다음과 같다.
- [1] '부분범위 처리 가능하도록 SQL을 작성한다. 부분범위 처리가 잘 작동하는지 토드, 오렌지 같은 쿼리 툴에서 테스트한다.
- [2] 작성한 SQL 문을 페이징 처리용 표준 패턴 SQL Body 부분에 붙여 넣는다.

'부분범위 처리 가능하도록 SQL을 작성한다'는 의미는 무엇일까?
**인덱스 사용 가능하도록 조건절을 구사**하고, **조인은 NL 조인 위주로 처리**(룩업을 위한 작은 테이블은 해시 조인 Build Input으로 처리해도 됨)하고, **Order By 절이 있어도 소트 연산을
생략할 수 있도록 인덱스를 구성**해 주는 것을 의미한다.

아래는 완성된 페이징 처리 SQL이다. 실행계획에 소트 연산이 없고 세 번째 라인(ID=2) Count 옆에 Stopkey라고 표시된 부분을 주목하기 바란다.
```
select *
from  (
  select rownum no, a.*
  from
    (
      select 거래일시, 체결건수, 체결수량, 거래대금
      from   종목거래
      where  종목코드 = 'KR123456'
      and    거래일시 >= '20180304'
      order by 거래일시
    ) a
  where rownum <= (:page * 10)
  )
where no >= (:page-1) * 10 + 1

Execution Plan
------------------------------------------------------------------------------------
0       SELECT STATEMENT Optimizer=ALL_ROWS (Cost=16 Card=756 Bytes=126K)
1    0    VIEW (Cost=16 Card=756 Bytes=126K)
2    1      COUNT (STOPKEY)      → NO SORT + STOPKEY
3    2        VIEW (Cost=16 Card=756 Bytes=117K)
4    3          TABLE ACCESS (BY INDEX ROWID) '종목거래' (TABLE) (Cost=16 ... )
5    4            INDEX (RANGE SCAN) OF '종목거래_PK' (INDEX) (Cost=4 Card=303)
```

### [페이징 처리 ANTI 패턴]
여기서 매우 중요한 사실 한가지를 설명하려고 한다. 위 SQL 문을 잘 분석해 보면, Order By 아래 쪽 ROWNUM 조건절이 불필요해 보인다. 이 조건을 제거하고, 아래와 같이 표현하는 게 더 간결하다.
```
select *
from  (
  select rownum no, a.*
  from
    (
      select 거래일시, 체결건수, 체결수량, 거래대금
      from   종목거래
      where  종목코드 = 'KR123456'
      and    거래일시 >= '20180304'
      order by 거래일시
    ) a
  )
where no between (:page-1) * 10 + 1 and (:page * 10)
```
개발자는 프로그램 소스를 간결하게 표현하고 싶어 한다. 그래서 페이징 처리에 위와 같은 패턴을 사용하는 개발팀이 많다.
SQL Body 대부분은 개발자가 작성하고 앞뒤 페이징 처리 부분은 자동으로 삽입해 주는 기능을 대부분 개발 프레임워크가 제공하는데, 위와 같은 패턴을 사용하는 프레임워크도 여러 차례 목격했다.

그런데 Order By 아래 쪽 ROWNUM은 단순한 조건절이 아니다. 지금까지 설명한 'Top N Stopkey' 알고리즘(그리고 뒤에서 설명할 'Top N 소트' 알고리즘)을 작동하게 하는 열쇠다.
불필요해 보인다고 ROWNUM 조건절을 제거하면 실행계획이 아래와 같이 바뀐다.
```
Execution Plan
------------------------------------------------------------------------------------
0       SELECT STATEMENT Optimizer=ALL_ROWS (Cost=16 Card=756 Bytes=126K)
1    0    FILTER
2    1      VIEW (Cost=16 Card=756 Bytes=126K)
3    2        COUNT     → NO SORT + NO STOP
4    3          VIEW (Cost=16 Card=756 Bytes=117K)
5    4            TABLE ACCESS (BY INDEX ROWID) OF '종목거래' (TABLE) (Cost=16 ... )
6    5              INDEX (RANGE SCAN) OF '종목거래_PK' (INDEX) (Cost=4 Card=303)
```
여기서도 Sort Order By 오퍼레이션은 나타나지 않지만, Count 옆에 Stopkey가 없음을 확인하기 바란다.
소트 생략 가능하도록 인덱스를 구성했으므로 소트 생략은 가능하지만, Stopkey가 작동하지 않아 전체범위를 처리한다는 뜻이다.

SQL 트레이스를 분석해 보면 이 방식의 문제점을 바로 확인할 수 있지만, SQL 트레이스에 익숙하지 않은 초보자를 위해 더 쉽게 확인할 수 있는 방법을 소개한다.

우선, 노트북에 오라클을 설치하자. 방금 설명한 패턴으로 SQL을 작성하고, 조회 조건에 해당하는 데이터를 아주 많이 입력하자. 그 상태에서 SQL을 수행해 보면, 화면에 첫 번째 페이지가 금방 출력된다.
그 순간 노트북에 귀를 가까이 가져가 보면 하드디스크 돌아가는 소리가 계속 날 것이다.
맨 아래 between 조건에 해당하는 데이터를 이미 다 출력했음에도 불구하고, 그 조건을 만족하는 데이터가 더 존재하는지 확인하면서 내는 소리다.

DB 서버가 원격에 있다면 직접 소리를 들을 수 없지만, 잘못된 페이징 처리 패턴이 DB 서버에 어떤 영향을 주는지 여기서 분명히 이해하기 바란다.

- #### [부분범위 처리 가능하도록 SQL 작성하기]

  '부분범위 처리 가능하도록 SQL을 작성한다'는 의미를 이미 설명했지만, 이해를 돕기 위해 튜닝사례를 하나 소개하려고 한다. 우선, 거래 테이블 인덱스 구성은 아래와 같다.

  - 거래_PK : 거래일자 + 계좌번호 + 거래순번
  - 거래_X01 : 계좌번호 + 거래순번 + 결제구분코드

  아래 Top N 쿼리는 인덱스로 소트 연산을 생략할 수 없기 때문에 실행계획에 Sort Order By 오퍼레이션(ID=3)이 나타났다.
  화면에 50개 레코드만 출력하고 싶은데도, 거래일자 조건에 해당하는 데이터를 모두 읽어 정렬을 마칠 때까지 기다려야 하는 상황이다.

  ```
  select *
  from (
    select 계좌번호, 거래순번, 주문금액, 주문수량, 결제구분코드, 주문매체구분코드
    from   거래
    where  거래일자 = :ord_dt
    order by 계좌번호, 거래순번, 결제구분코드
  )
  where rownum <= 50

  Execution Plan
  ------------------------------------------------------------------------------------
  0       SELECT STATEMENT Optimizer=ALL_ROWS (Cost=433K Card=10 Bytes=1K)
  1    0    COUNT (STOPKEY)
  2    1      VIEW (Cost=433K Card=421K Bytes=57M)
  3    2        SORT (ORDER BY STOPKEY) (Cost=433K Card=421K Bytes=40M)
  4    3          TABLE ACCESS (BY INDEX ROWID) OF '거래' (TABLE) (Cost=423K ... )
  5    4            INDEX (RANGE SCAN) OF '거래_PK' (INDEX) (Cost=2K Card=421K)
  ```

  PK 인덱스에 결제구분코드를 추가하면 소트생략이 가능하지만, PK에 컬럼을 함부로 추가할 수는 없다.
  [거래일자 + 계좌번호 + 거래순번 + 결제구분코드] 순으로 구성된 인덱스를 하나 더 만들어도 되지만, 이 역시 탐탁지 않다. 트랜잭션이 많은 대형 테이블에 인덱스는 최소한으로 유지해야 하기 때문이다.

  불필요한 소트가 발생하지 않도록 SQL을 작성하려면 데이터 모델에 대한 이해와 집합적 사고가 필요하다고 앞서 강조했는데, 여기서도 그런 능력이 필요하다.
  PK가 [거래일자 + 계좌번호 + 거래순번]이고, 거래일자가 '=' 조건이다. 같은 거래일자 데이터를 [계좌번호 + 계좌순번] 순으로 정렬해 놓고 보면, 중복 레코드가 전혀 없다.
  있으나 마나 한 결제구분코드를 Order By 절에서 제거하면 Sort Order By 오퍼레이션이 사라지고, 부분범위 처리가 잘 작동한다.

<br/>

## (3) 최소값/최대값 구하기
최소값(MIN) 또는 최대값(MAX)을 구하는 SQL 실행계획을 보면, 아래와 같이 SortA Aggregate 오퍼레이션이 나타난다.
Sort Aggregate를 위해 전체 데이터를 정렬하진 않지만, 전체 데이터를 읽으면서 값을 비교한다고 앞에서 설명하였다.
```
SELECT MAX(SAL) FROM EMP;

Execution Plan
------------------------------------------------------------------------------------
0       SELECT STATEMENT Optimizer=ALL_ROWS (Cost=3 Card=1 Bytes=4)
1    0    SORT (AGGREGATE) (Card=1 Bytes=4)
2    1      TABLE ACCESS (FULL) OF 'EMP' (TABLE) (Cost=3 Card=14 Bytes=56)
```

인덱스는 정렬돼 있으므로 이를 이용하면 전체 데이터를 읽지 않고도 최소 또는 최대값을 쉽게 찾을 수 있다.
인덱스 맨 왼쪽으로 내려가서 첫 번째 읽는 값이 최소값이고, 맨 오른쪽으로 내려가서 첫 번째 읽는 값이 최대값이다.
- '인덱스 맨 오른쪽으로 내려가서 첫 번째 읽는 값이 최대값'이라는 설명은 인덱스의 논리적 구조(삼각형 모양)를 염두에 둔 것이다.
  인덱스의 물리적 구조를 고려해서 정확히 설명하면, 루트와 브랜치 블록에서 맨 마지막 레코드가 가리키는 하위 블록으로 내려가다가 만나는 리프 블록(가장 마지막 리프 블록)에 저장된 맨 마지막 레코드가
  최대값이다.

아래는 인덱스를 이용해 최대값을 찾을 때의 실행계획이다.
```
CREATE INDEX EMP_X1 ON EMP(SAL);

SELECT MAX(SAL) FROM EMP;

Execution Plan
------------------------------------------------------------------------------------
0       SELECT STATEMENT Optimizer=ALL_ROWS (Cost=1 Card=1 Bytes=3)
1    0    SORT (AGGREGATE) (Card=1 Bytes=3)
2    1      INDEX (FULL SCAN (MIN/MAX)) OF 'EMP_X1' (INDEX) (Cost=1 Card=1 ... )
```

참고로, 위와 같은 실행계획이 나타나기 시작한 것은 오라클 8i부터다. 8 버전까지는 인덱스가 있어도 아래와 같이 전체 데이터를 읽었다.

```
Execution Plan
------------------------------------------------------------------------------------
0       SELECT STATEMENT Optimizer=ALL_ROWS (Cost=1 Card=1 Bytes=3)
1    0    SORT (AGGREGATE) (Card=1 Bytes=3)
2    1      INDEX (FULL SCAN) OF 'EMP_X1' (INDEX) (Cost=1 Card=14 Bytes=42)
```

### [인덱스 이용해 최소/최대값 구하기 위한 조건]
**전체 데이터를 읽지 않고 인덱스를 이용해 최소 또는 최대값을 구하려면, 조건절 컬럼과 MIN/MAX 함수 인자 컬럼이 모두 인덱스에 포함돼 있어야 한다. 즉, 테이블 액세스가 발생하지 않아야 한다.**
아래는 인덱스를 [DEPTNO + MGR + SAL] 순으로 구성한 경우다.
```
CREATE INDEX EMP_X1 ON EMP(DEPTNO, MGR, SAL);

SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 30 AND MGR = 7698;

Execution Plan
------------------------------------------------------------------------------------
0       SELECT STATEMENT Optimizer=ALL_ROWS (Cost=1 Card=1 Bytes=8)
1    0    SORT (AGGREGATE) (Card=1 Bytes=8)
2    1      FIRST ROW (Cost=1 Card=1 Bytes=8)
3    2        INDEX (RANGE SCAN (MIN/MAX)) OF 'EMP_X1' (INDEX) (Cost=1 Card=1 ... )
```

조건절 컬럼과 MAX 컬럼이 모두 인덱스에 포함돼 있고, 인덱스 선두 컬럼 DEPTNO, MGR이 모두 '=' 조건이므로 이 두 조건을 만족하는 범위(Range) 가장 오른쪽에 있는 값 하나를 읽는다.
실행계획 세 번째 라인(ID=2) 'FIRST ROW'는 조건을 만족하는 레코드 하나를 찾았을 때 바로 멈춘다는 것을 의미한다. 지금부터 이를 'First Row Stopkey' 알고리즘이라고 부르기로 하자.

아래는 인덱스를 [DEPTNO + SAL + MGR] 순으로 구성한 경우다. DEPTNO = 30 조건을 만족하는 MAX(SAL) 값을 쉽게 찾을 수 있는 구성이다.
```
CREATE INDEX EMP_X1 ON EMP(DEPTNO, SAL, MGR);

SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 30 AND MGR = 7698;

Execution Plan
------------------------------------------------------------------------------------
0       SELECT STATEMENT Optimizer=ALL_ROWS (Cost=1 Card=1 Bytes=8)
1    0    SORT (AGGREGATE) (Card=1 Bytes=8)
2    1      FIRST ROW (Cost=1 Card=1 Bytes=8)
3    2        INDEX (RANGE SCAN (MIN/MAX)) OF 'EMP_X1' (INDEX) (Cost=1 Card=1 ... )
```

DEPTNO = 30 조건을 만족하는 범위(Range) 가장 오른쪽으로 내려가면 가장 큰 SAL 값을 읽게 된다. 거기서부터 스캔을 시작해 MGR = 7698 조건을 만족하느나 레코드 하나를 찾았을 때 멈추면 된다.
즉, DEPNO는 액세스 조건, MGR은 필터 조건이다. 여기서도 조건절 컬럼과 MAX 컬럼이 모두 인덱스에 포함돼 있으므로 'First Row Stopkey' 알고리즘이 작동한다.

아래는 인덱스를 [SAL + DEPTNO + MGR] 순으로 구성한 경우다. 조건절 컬럼이 둘 다 인덱스 선두 컬럼이 아니므로 Index Range Scan은 불가능하다.
```
CREATE INDEX EMP_X1 ON EMP(SAL, DEPTNO, MGR);

SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 30 AND MGR = 7698;

Execution Plan
------------------------------------------------------------------------------------
0       SELECT STATEMENT Optimizer=ALL_ROWS (Cost=1 Card=1 Bytes=8)
1    0    SORT (AGGREGATE) (Card=1 Bytes=8)
2    1      FIRST ROW (Cost=1 Card=1 Bytes=8)
3    2        INDEX (FULL SCAN (MIN/MAX)) OF 'EMP_X1' (INDEX) (Cost=1 Card=1 ... )
```

Index Full Scan 방식으로 인덱스 전체 레코드 중 가장 오른쪽에서 스캔을 시작해 DEPTNO = 30 조건과 MGR = 7698 조건을 만족하는 레코드 하나를 찾았을 때 멈추면 된다.
즉, DEPTNO와 MGR 모두 필터 조건이다. 여기서도 조건절 컬럼과 MAX 컬럼이 모두 인덱스에 포함돼 있으므로 'First Row Stopkey' 알고리즘이 작동한다.

아래는 조건절 컬럼과 MAX 컬럼 중 어느 하나가 인덱스에 포함돼 있지 않은 경우다. 인덱스를 [DEPTNO + SAL]로 구성했으므로 DEPTNO = 30 조건을 만족하는 MAX(SAL)은 쉽게 찾을 수 있다.
그런데 MGR 컬럼이 인덱스에 없으므로 MGR = 7698 조건은 테이블에서 필터링해야만 한다.
```
CREATE INDEX EMP_X1 ON EMP(DEPTNO, SAL);

SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 30 AND MGR = 7698;

Execution Plan
------------------------------------------------------------------------------------
0       SELECT STATEMENT Optimizer=ALL_ROWS (Cost=2 Card=1 Bytes=8)
1    0    SORT (AGGREGATE) (Card=1 Bytes=8)
2    1      TABLE ACCESS (BY INDEX ROWID) OF 'EMP' (TABLE) (Cost=2 Card=1 Bytes=8)
3    2        INDEX (RANGE SCAN) OF 'EMP_X1' (INDEX) (Cost=1 Card=5)
```
이럴 때는 인덱스에서 DEPTNO = 30 조건을 만족하는 '전체' 레코드를 읽어 테이블에서 MGR = 7698 조건을 필터링한 후 MAX(SAL) 값을 구한다.
즉, 'First Row Stopkey' 알고리즘이 작동하지 않는다.

### [Top N 쿼리 이용해 최소/최대값 구하기]
Top N 쿼리를 통해서도 최소 또는 최대값을 쉽게 구할 수 있다. 아래와 같이 ROWNUM <= 1 조건을 이용해 Top 1 레코드를 찾으면 된다.
```
CREATE INDEX EMP_X1 ON EMP(DEPTNO, SAL);

SELECT *
FROM (
  SELECT SAL
  FROM   EMP
  WHERE  DEPTNO = 30
  AND    MGR = 7698
  ORDER BY SAL DESC
)
WHERE ROWNUM <= 1;

Execution Plan
------------------------------------------------------------------------------------
0       SELECT STATEMENT Optimizer=ALL_ROWS (Cost=2 Card=1 Bytes=13)
1    0    COUNT (STOPKEY)
2    1      VIEW (Cost=2 Card=1 Bytes=13)
3    2        TABLE ACCESS (BY INDEX ROWID) OF 'EMP' (TABLE) (Cost=2 Card=1 ... )
4    3          INDEX (RANGE SCAN DESCENDING) OF 'EMP_X1' (INDEX) (Cost=1 Card=5)
```
Top N 쿼리에 작동하는 'Top N Stopkey' 알고리즘은 모든 컬럼이 인덱스에 포함돼 있지 않아도 잘 작동한다.
즉, 위 SQL에서 MGR 컬럼이 인덱스에 없지만, 가장 큰 SAL 값을 찾기 위해 DEPTNO = 30 조건을 만족하는 '전체' 레코드를 읽지 않는다.
DEPTNO = 30 조건을 만족하는 가장 오른쪽에서부터 역순으로 스캔하면서 테이블을 액세스하다가 MGR = 7698 조건을 만족하는 레코드 하나를 찾았을 때 바로 멈춘다.

인라인 뷰를 사용하므로 쿼리가 약간 더 복잡하긴 하지만, 성능 측면에서는 MIN/MAX 쿼리보다 낫다.

<br/>

## (4) 이력 조회
일반 테이블은 각 컬럼의 현재(최종) 값만 저장하므로 변경되기 이전 값을 알 수 없다. 값이 어떻게 변경돼 왔는지 과거 이력을 조회할 필요가 있다면, 이력 테이블을 따로 관리해야 한다.
'상태변경이력'이 각 장비의 상태코드 변경이력을 관리하는 이력 테이블이라고 하자.

|장비|상태변경이력&nbsp;&nbsp;&nbsp;&nbsp;|
|:---|:---|
|# 장비번호<br/>* 장비명<br/>* 장비구분코드<br/>* 상태코드<br/>* 최종변경일자|# 장비번호<br/># 변경일자<br/># 변경순번<br/>* 상태코드<br/>◦ 메모|

과거 변경이력을 관리하기 위해 이력 테이블을 두지만, 일반적으로 이 테이블에는 현재(최종) 데이터도 저장한다. 그렇게 구현해야 변경 이력을 완벽히 재생할 수 있기 때문이다.
예를 들어, 특정 장비의 최종 상태코드가 'A2'인데 이 값으로 바뀐 날짜를 알고 싶다면, 이력 테이블에서 확인해야 한다. 장비 테이블에도 최종변경일자가 있지만, 이 값을 이용할 순 없다.
이 값은 상태코드 이외의 컬럼, 즉 장비명 또는 장비구분코드가 바뀔 때도 갱신되기 때문이다.

### [가장 단순한 이력 조회]
이력 데이터 조회할 때 'First Row Stopkey' 또는 'Top N Stopkey' 알고리즘이 작동할 수 있게 인덱스 설계 및 SQL 구현하는 일은 고급 SQL 튜너가 되기 위해 반드시 정복해야 할 산이다.
가장 단순한 조회 패턴부터 살펴보자.

아래는 장비구분코드가 'A001'인 장비 목록을 조회하는 쿼리다. 상태코드가 현재 값으로 변경된 날짜(최종 변경일자)는 상태변경이력에서 조회하고 있다.
```
SELECT 장비번호, 장비명, 상태코드
     , (SELECT MAX(변경일자)
        FROM   상태변경이력
        WHERE  장비번호 = P.장비번호) 최종변경일자
FROM   장비 P
WHERE  장비구분코드 = 'A001'

-----------------------------------------------------------------------------------
| Id  | Operation                       | Name        | Starts | A-Rows | Buffers |
-----------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                |             |      1 |     10 |       4 |
|   1 |   SORT AGGREGATE                |             |     10 |     10 |      22 |
|   2 |     FIRST ROW                   |             |     10 |     10 |      22 |
|   3 |       INDEX RANGE SCAN (MIN/MAX)| 상태변경이력_PK|     10 |     10 |      22 |
|   4 |   TABLE ACCESS BY INDEX ROWID   | 장비         |      1 |     10 |       4 |
|   5 |     INDEX RANGE SCAN            | 장비_N1      |      1 |     10 |       2 |
-----------------------------------------------------------------------------------
```
위 SQL 문에서 이력 조회하는 스칼라 서브쿼리 부분에 'First Row Stopkey' 알고리즘이 작동하고 있다.
상태변경이력_PK 인덱스가 [장비번호 + 변경일자 + 변경순번] 순으로 구성돼 있기 때문에 가능한 일이다.

### [점점 복잡해지는 이력 조회]
```
SELECT 장비번호, 장비명, 상태코드
     , SUBSTR(최종이력, 1, 8) 최종변경일자
     , TO_NUMBER(SUBSTR(최종이력, 9, 4)) 최종변경순번
FROM (
  SELECT 장비번호, 장비명, 상태코드
       , (SELECT MAX(H.변경일자 || LPAD(H.변경순번, 4))
          FROM   상태변경이력 H
          WHERE  장비번호 = P.장비번호) 최종이력
  FROM   장비 P
  WHERE  장비구분코드 = 'A001'
)

-----------------------------------------------------------------------------------
| Id  | Operation                       | Name        | Starts | A-Rows | Buffers |
-----------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                |             |      1 |     10 |       4 |
|   1 |   SORT AGGREGATE                |             |     10 |     10 |    6380 |
|   2 |     INDEX RANGE SCAN            | 상태변경이력_PK|     10 |  1825K |    6380 |
|   3 |   TABLE ACCESS BY INDEX ROWID   | 장비         |      1 |     10 |       4 |
|   4 |     INDEX RANGE SCAN            | 장비_N1      |      1 |     10 |       2 |
-----------------------------------------------------------------------------------
```

이 SQL은 인덱스 컬럼을 가공했으므로 'First Row Stopkey' 알고리즘이 작동하지 않는다. 장비별 상태변경이력이 많지 않을 때는 문제가 안 될 수 있지만, 많을 때 문제가 된다.

장비별 상태변경이력이 많아 성능에 문제가 된다면, 차라리 아래와 같이 쿼리하는 게 낫다.
쿼리가 복잡하고 상태변경이력을 세 번 조회하는 비효율은 있지만, 'First Row Stopkey' 알고리즘이 잘 작동하므로 성능은 비교적 좋다.

```
SELECT 장비번호, 장비명, 상태코드
     , (SELECT MAX(H.변경일자)
        FROM   상태변경이력 H
        WHERE  장비번호 = P.장비번호) 최종변경일자
     , (SELECT MAX(H.변경순번)
        FROM   상태변경이력 H
        WHERE  장비번호 = P.장비번호
        AND    변경일자 = (SELECT MAX(H.변경일자)
                         FROM   상태변경이력 H
                         WHERE  장비번호 = P.장비번호)) 최종변경순번
FROM   장비 P
WHERE  장비구분코드 = 'A001'


---------------------------------------------------------------------------------------
| Id  | Operation                           | Name        | Starts | A-Rows | Buffers |
---------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                    |             |      1 |     10 |       4 |
|   1 |   SORT AGGREGATE                    |             |     10 |     10 |      22 |
|   2 |     FIRST ROW                       |             |     10 |     10 |      22 |
|   3 |       INDEX RANGE SCAN (MIN/MAX)    | 상태변경이력_PK|     10 |     10 |      22 |
|   4 |   SORT AGGREGATE                    |             |     10 |     10 |      47 |
|   5 |     INDEX RANGE SCAN                | 상태변경이력_PK|     10 |   1000 |      47 |
|   6 |       SORT AGGREGATE                |             |     10 |     10 |      22 |
|   7 |         FIRST ROW                   |             |     10 |     10 |      22 |
|   8 |           INDEX RANGE SCAN (MIN/MAX)| 상태변경이력_PK|     10 |     10 |      22 |
|   9 |   TABLE ACCESS BY INDEX ROWID       | 장비         |      1 |     10 |       4 |
|  10 |     INDEX RANGE SCAN                | 장비_N1      |      1 |     10 |       2 |
---------------------------------------------------------------------------------------
```
문제는 이력 테이블에서 읽어야 할 컬럼이 많을 때다. 예를 들어, 상태코드까지 이력 테이블에서 읽어야 한다면, SQL 문이 아래와 같이 훨씬 더 복잡해진다.
상태코드 말고도 이력 테이블에서 읽어야 할 컬럼이 더 많다면?
```
SELECT 장비번호, 장비명, 상태코드
     , (SELECT MAX(H.변경일자)
        FROM   상태변경이력 H
        WHERE  장비번호 = P.장비번호) 최종변경일자
     , (SELECT MAX(H1.변경순번)
        FROM   상태변경이력 H1
        WHERE  장비번호 = P.장비번호
        AND    변경일자 = (SELECT MAX(H2.변경일자)
                         FROM   상태변경이력 H2
                         WHERE  장비번호 = P.장비번호)) 최종변경순번
     , (SELECT H1.상태코드
        FROM   상태변경이력 H1
        WHERE  장비번호 = P.장비번호
        AND    변경일자 = (SELECT MAX(H2.변경일자)
                         FROM   상태변경이력 H2
                         WHERE  장비번호 = P.장비번호)
        AND    변경순번 = (SELECT MAX(H3.변경순번)
                         FROM   상태변경이력 H3
                         WHERE  장비번호 = P.장비번호
                         AND    변경일자 =
                                   (SELECT MAX(H4.변경일자)
                                    FROM   상태변경이력 H4
                                    WHERE  장비번호 = P.장비번호))) 최종상태코드
FROM   장비 P
WHERE  장비구분코드 = 'A001'
```

### [INDEX_DESC 힌트 활용]
단순하게 쿼리하면서도 성능을 높이기 위해 SQL 튜닝 전문가들이 전통적으로 사용해 온 방식은 아래와 같다.
인덱스를 역순으로 읽도록 index_desc 힌트를 사용했고, 첫 번째 레코드에서 바로 멈추도록 rownum <= 1 조건절을 사용했다.
```
SELECT 장비번호, 장비명
     , SUBSTR(최종이력, 1, 8) 최종변경일자
     , TO_NUMBER(SUBSTR(최종이력, 9, 4)) 최종변경순번
     , SUBSTR(최종이력, 13) 최종상태코드
FROM (
    SELECT 장비번호, 장비명
        , (SELECT /*+ INDEX_DESC(X 상태변경이력_PK) */
            변경일자 || LPAD(변경순번, 4) || 상태코드
           FROM   상태변경이력 X
           WHERE  장비번호 = P.장비번호
           AND    ROWNUM <= 1) 최종이력
    FROM   장비 P
    WHERE  장비구분코드 = 'A001'
)

---------------------------------------------------------------------------------------
| Id  | Operation                           | Name        | Starts | A-Rows | Buffers |
---------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                    |             |      1 |     10 |       4 |
|   1 |   COUNT STOPKEY                     |             |     10 |     10 |      41 |
|   2 |     TABLE ACCESS BY INDEX ROWID     | 상태변경이력   |     10 |     10 |      41 |
|   3 |       INDEX RANGE SCAN DESCENDING   | 상태변경이력_PK|     10 |     10 |      30 |
|   4 |   TABLE ACCESS BY INDEX ROWID       | 장비         |      1 |     10 |       4 |
|   5 |     INDEX RANGE SCAN                | 장비_N1      |      1 |     10 |       2 |
```
이 방식이 성능은 확실히 좋다. 문제는 인덱스 구성이 완벽해야만 쿼리가 잘 작동한다는 데 있다. 인덱스를 잘 구성해서 처음엔 잘 작동하다가도 인덱스 구성이 바뀌면 언제든 결과집합에 문제가 생길 수 있다.
PK 구성을 변경하는 일은 거의 없으므로 대개 문제가 되지 않는다고 볼 수 있지만, 다른 대안이 있다면 그 방법을 사용하는 게 바람직하다.

### [11g/12c 신기능 활용]
방금 본 쿼리는 사실 아래 쿼리가 작동하지 않기 때문에 궁여지책으로 사용해 온 측면이 있다. 11g 이하 버전에서 실행해 보면, ORA-00904 오류가 발생한다.
메인 쿼리 컬럼을 서브 쿼리 내 인라인 뷰에서 참조했기 때문에 발생하는 파싱 오류다.
```
SELECT 장비번호, 장비명
     , SUBSTR(최종이력, 1, 8) 최종변경일자
     , TO_NUMBER(SUBSTR(최종이력, 9, 4)) 최종변경순번
     , SUBSTR(최종이력, 13) 최종상태코드
FROM (
  SELECT 장비번호, 장비명
       , (SELECT 변경일자 || LPAD(변경순번, 4) || 상태코드
          FROM   (SELECT 변경일자, 변경순번, 상태코드
                  FROM   상태변경이력
                  WHERE  장비번호 = P.장비번호 -- ORA-00904(부적합한 식별자) 오류
                  ORDER BY 변경일자 DESC, 변경순번 DESC)
          WHERE   ROWNUM <= 1) 최종이력
  FROM   장비 P
  WHERE  장비구분코드 = 'A001'
)
```
이 오류를 회피하기 위해 11g부터 쿼리를 아래와 같이 작성할 수 있다.
```
SELECT 장비번호, 장비명
     , SUBSTR(최종이력, 1, 8) 최종변경일자
     , TO_NUMBER(SUBSTR(최종이력, 9, 4)) 최종변경순번
     , SUBSTR(최종이력, 13) 최종상태코드
FROM (
  SELECT 장비번호, 장비명
      , (SELECT 변경일자 || LPAD(변경순번, 4) || 상태코드
         FROM   (SELECT 장비번호, 변경일자, 변경순번, 상태코드
                 FROM   상태변경이력
                 ORDER BY 변경일자 DESC, 변경순번 DESC)
         WHERE   장비번호 = P.장비번호
         AND     ROWNUM <= 1) 최종이력
  FROM   장비 P
  WHERE  장비구분코드 = 'A001'
)

---------------------------------------------------------------------------------------
| Id  | Operation                           | Name        | Starts | A-Rows | Buffers |
---------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                    |             |      1 |     10 |       4 |
|   1 |   COUNT STOPKEY                     |             |     10 |     10 |      40 |
|   2 |     VIEW                            |             |     10 |     10 |      40 |
|   3 |       TABLE ACCESS BY INDEX ROWID   | 상태변경이력   |     10 |     10 |      40 |
|   4 |         INDEX RANGE SCAN DESCENDING | 상태변경이력_PK|     10 |     10 |      30 |
|   5 |     TABLE ACCESS BY INDEX ROWID     | 장비         |      1 |     10 |       4 |
|   6 |       INDEX RANGE SCAN              | 장비_N1      |      1 |     10 |       2 |
---------------------------------------------------------------------------------------
```
SQL 형태만 놓고 보면, 인라인 뷰로 정의한 집합(모든 상태변경이력을 읽어 변경일자와 변경순번 역순으로 정렬한 중간집합)을 우선 만들고 나서 장비번호와 ROWNUM 조건을 필터링할 것처럼 보인다.
하지만, 실제 수행해 보면 [장비번호 = P.장비번호] 조건절이 인라인 뷰 안쪽으로 파고 들어간다. 'Predicate Pushing'이라고 불리는 쿼리 변환이 작동한 결과다.
이 방식을 사용하면, 혹시 인덱스 구성이 변경됐을 때 'Top N Stopkey' 알고리즘이 작동하지 않아 성능이 느려질 순 있지만, 쿼리 결과집합은 보장된다.

12c에서는 아래와 같은 패턴도 SQL 파싱 오류 없이 'Top N Stopkey' 알고리즘이 잘 작동한다. 11g까지 ORA-00904 오류가 발생한다고 했던 패턴이다.
```
SELECT 장비번호, 장비명
     , SUBSTR(최종이력, 1, 8) 최종변경일자
     , TO_NUMBER(SUBSTR(최종이력, 9, 4)) 최종변경순번
     , SUBSTR(최종이력, 13) 최종상태코드
FROM (
  SELECT 장비번호, 장비명
      , (SELECT 변경일자 || LPAD(변경순번, 4) || 상태코드
         FROM   (SELECT 변경일자, 변경순번, 상태코드
                 FROM   상태변경이력
                 WHERE  장비번호 = P.장비번호
                 ORDER BY 변경일자 DESC, 변경순번 DESC)
         WHERE  ROWNUM <= 1) 최종이력
  FROM   장비 P
  WHERE  장비구분코드 = 'A001'
)
```
Top N 쿼리는 여러모로 이점이 많은 패턴이니 잘 활용하기 바란다.

- #### [윈도우 함수와 Row Limiting 절]

  윈도우 함수 기능이 점점 좋아지고, 12c부터는 Row Limiting 절도 지원한다.
  지금까지 설명한 Top N 쿼리와 성능을 비교해 볼 필요가 있는데, 결론부터 말하면 인덱스 활용이 중요한 온라인성 쿼리에서 윈도우 함수 또는 Row Limiting 절을 사용하는 것은 시기상조다.
  Top N 쿼리를 사용하자.

  #### (1) 이력조회
  이력 조회하는 서브쿼리에 아래와 같이 윈도우 함수를 사용할 수 있지만, 'Top N Stopkey' 알고리즘이 작동하지 않는다. 따라서 인덱스로 소트를 생략할 수 있을 때 사용해선 안 된다.

  ```
  SELECT 장비번호, 장비명
       , SUBSTR(최종이력, 1, 8) 최종변경일자
       , TO_NUMBER(SUBSTR(최종이력, 9, 4)) 최종변경순번
       , SUBSTR(최종이력, 13) 최종상태코드
  FROM (
    SELECT 장비번호, 장비명
        , (SELECT 변경일자 || LPAD(변경순번, 4) || 상태코드
           FROM   (SELECT 변경일자, 변경순번, 상태코드
                   FROM   (SELECT 변경일자, 변경순번, 상태코드
                              , ROW_NUMBER() OVER (ORDER BY 변경일자 DESC, 변경순번 DESC) NO
                           FROM   상태변경이력
                           WHERE  장비번호 = P.장비번호) 
                   WHERE NO = 1) 최종이력
    FROM   장비 P
    WHERE  장비구분코드 = 'A001'
  );
  ```
  12c부터 Row Limiting 절을 이용해 아래와 같이 구현할 수도 있지만, 마찬가지로 'Top N Stopkey' 알고리즘이 작동하지 않는다.
  참고로, Row Limiting 절을 사용하면, 윈도우 함수를 사용하는 형태(위 쿼리)로 옵티마이저가 쿼리를 변환한다. 따라서 실행계획도 똑같다.

  ```
  SELECT 장비번호, 장비명
       , SUBSTR(최종이력, 1, 8) 최종변경일자
       , TO_NUMBER(SUBSTR(최종이력, 9, 4)) 최종변경순번
       , SUBSTR(최종이력, 13) 최종상태코드
  FROM (
    SELECT 장비번호, 장비명
        , (SELECT 변경일자 || LPAD(변경순번, 4) || 상태코드
           FROM   상태변경이력
           WHERE  장비번호 = P.장비번호
           ORDER BY 변경일자 DESC, 변경순번 DESC
           FETCH FIRST 1 ROWS ONLY) 최종이력
    FROM   장비 P
    WHERE  장비구분코드 = 'A001'
  );
  ```

  #### (2) 페이징처리
  아래와 같이 윈도우 함수를 페이징 처리에 활용할 때는 'Top N Stopkey' 알고리즘이 작동할 수 있다.
  하지만, 카디널리티와 비용 계산이 불완전함으로 인해 소트를 생략할 수 있는데도 인덱스를 사용하지 않는 경우가 자주 발생한다.
  따라서 페이징 처리에 이 방식을 사용하면 index/index_desc 힌트를 써야 할 일이 자주 생긴다.
  - 12c에서 first_rows(n) 힌트를 사용하면, 힌트에 지정한 n으로 카디널리티를 계산하므로 비교적 인덱스를 잘 사용한다.
    페이징 처리에 윈도우 함수 또는 Row Limiting 절을 사용했다면, first_rows(n) 힌트를 같이 사용하기 바란다.

  ```
  SELECT 변경일자, 변경순번, 상태코드
  FROM  (
      SELECT 변경일자, 변경순번, 상태코드
           , ROW_NUMBER() OVER (ORDER BY 변경일자, 변경순번) NO
      FROM   상태변경이력
      WHERE  장비번호 = :eqp_no)
  WHERE NO BETWEEN 1 AND 10;
  ```

  소트 생략 가능한 인덱스가 없어서 'Top N 소트' 알고리즘이 작동할 때, 기존 Top N 쿼리보다 윈도우 함수가 소트 공간(Sort Area, Temp 세그먼트)을 더 많이 사용하는 단점도 있다.

  12c 이후로 페이징 처리에 아래와 같이 Row Limiting 절을 사용할 수 있지만, 윈도우 함수를 사용할 때와 똑같은 성능 특성을 보인다.

  ```
  SELECT 변경일자, 변경순번, 상태코드
  FROM  (
      SELECT ROWNUM NO, 변경일자, 변경순번, 상태코드
      FROM (
          SELECT 변경일자, 변경순번, 상태코드
          FROM   상태변경이력
          WHERE  장비번호 = :eqp_no
          ORDER BY 변경일자, 변경순번
          FETCH FIRST ROW ONLY)
      )
  WHERE NO >= 1;
  ```

### [상황에 따라 달라져야 하는 이력 조회 패턴]
이력을 조회하는 업무 패턴은 다양하다.
일부 장비(장비구분코드 = 'A001')가 아닌 전체 장비를 대상으로 조회하거나, 최종이력이 아닌 직전 이력을 조회하거나, 특정 상태로 변경한 최종이력을 조회하는 등 여러 가지 상황이 존재한다.
본 절의 주제가 '인덱스를 이용한 소트 연산 생략'이므로 'First Row Stopkey' 또는 'Top N Stopkey' 알고리즘이 작동할 수 있게 SQL을 작성하는 내용 중심으로 살펴봤지만, 상황에 따라 이력 조회
패턴도 달라야 한다.

특히, 전체(또는 상당히 많은) 장비의 이력을 조회할 때는 인덱스를 이용한 Stopkey 기능 작동 여부가 튜닝의 핵심요소가 아니다.
인덱스 활용 패턴은 랜덤 I/O 발생량만큼 성능도 비례해서 느려지므로 대량 데이터 조회할 때 결코 좋은 솔루션이 되지 못한다.
[3.1.3] 인덱스 손익분기점' 후반부에 설명한 온라인 프로그램과 배치 프로그램 튜닝의 특징을 상기하기 바란다.

전체 장비의 이력을 조회할 때는 아래와 같이 윈도우 함수를 이용하는 것이 효과적이다.
```
SELECT P.장비번호, P.장비명
     , H.변경일자 AS 최종변경일자
     , H.변경순번 AS 최종변경순번
     , H.상태코드 AS 최종상태코드
FROM   장비 P
    , (SELECT 장비번호, 변경일자, 변경순번, 상태코드
            , ROW_NUMBER() OVER (PARTITION BY 장비번호
                                 ORDER BY 변경일자 DESC, 변경순번 DESC) RNUM
       FROM   상태변경이력) H
WHERE  H.장비번호 = P.장비번호
AND    H.RNUM = 1;

--------------------------------------------------------------------------------
| Id  | Operation                    | Name        | A-Rows | Buffers | Reads  |
--------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |             |   1000 |   2881K |  36812 |
|   1 |   HASH JOIN                  |             |   1000 |   2881K |  36812 |
|   2 |     TABLE ACCESS FULL        | 장비         |   1000 |      23 |      6 |
|   3 |     VIEW                     |             |   1000 |   2881K |  36806 |
|   4 |       WINDOW SORT PUSHED RANK|             |   1000 |   2881K |  36806 |
|   5 |         TABLE ACCESS FULL    | 상태변경이력   |   1000 |   2881K |  36803 |
--------------------------------------------------------------------------------
```

Full Scan과 해시 조인을 이용하기 때문에 오랜 과거 이력까지 모두 읽지만, 인덱스를 이용하는 방식보다 빠르다. 아래와 같이 KEEP 절을 활용할 수도 있다.
```
SELECT P.장비번호, P.장비명
     , H.변경일자 AS 최종변경일자
     , H.변경순번 AS 최종변경순번
     , H.상태코드 AS 최종상태코드
FROM   장비 P
    , (SELECT 장비번호
        , MAX(변경일자) 변경일자
        , MAX(변경순번) KEEP (DENSE_RANK LAST ORDER BY 변경일자, 변경순번) 변경순번
        , MAX(상태코드) KEEP (DENSE_RANK LAST ORDER BY 변경일자, 변경순번) 상태코드
       FROM   상태변경이력
       GROUP BY 장비번호) H
WHERE  H.장비번호 = P.장비번호

----------------------------------------------------------------------------
| Id  | Operation                | Name        | A-Rows | Buffers | Reads  |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT         |             |   1000 |   2881K |  17809 |
|   1 |   HASH JOIN              |             |   1000 |   2881K |  17809 |
|   2 |     TABLE ACCESS FULL    | 장비         |   1000 |      23 |      3 |
|   3 |     VIEW                 |             |   1000 |   2881K |  17806 |
|   4 |       SORT GROUP BY      |             |   1000 |   2881K |  17806 |
|   5 |         TABLE ACCESS FULL| 상태변경이력   | 18250K |   2881K |  17803 |
----------------------------------------------------------------------------
```

### [선분이력 맛보기]
업무 특성에 따라서는 다음처럼 선분이력 모델도 고려할 만하다.

|장비|상태변경이력|
|:---|:---|
|# 장비번호<br/>* 장비명<br/>* 장비구분코드<br/>* 상태코드<br/>* 최종변경일자<br/><br/>|# 장비번호<br/># 유효시작일자<br/># 유효종료일자<br/># 변경순번<br/>* 상태코드<br/>◦ 메모|

선분이력 모델을 채택하면, 어떤 상황에서든 아래와 같이 간단한 쿼리로 쉽게 이력을 조회할 수 있고, 쿼리가 간단한 만큼 성능 측면에 이점도 생긴다.
```
SELECT P.장비번호, P.장비명
     , H.상태코드, H.유효시작일자, H.유효종료일자, H.변경순번
FROM   장비 P, 상태변경이력 H
WHERE  P.장비구분코드 = 'A001'
AND    H.장비번호 = P.장비번호
AND    H.유효종료일자 = '99991231'

또는

SELECT P.장비번호, P.장비명
     , H.상태코드, H.유효시작일자, H.유효종료일자, H.변경순번
FROM   장비 P, 상태변경이력 H
WHERE  P.장비구분코드 = 'A001'
AND    H.장비번호 = P.장비번호
AND    :BASE_DT BETWEEN H.유효시작일자 AND H.유효종료일자
```
이력에 대해서 다룰 내용이 훨씬 더 많지만, 초보자를 대상으로 한 책이니 이 정도까지만 설명하는 게 좋겠다.
여기서 그치지 말고 다양한 이력모델과 조회 패턴의 장단점을 연구함으로써 각 상황에 맞는 최적 패턴을 선택할 수 있기를 바란다.

<br/>

## (5) Sort Group By 생략
인덱스를 이용해 소트 연산을 생략할 수 있다는 사실은 많이 알려졌고 이해하기도 비교적 쉽다. 반면, 그룹핑 연산에도 인덱스를 활용할 수 있다는 사실은 모르는 분이 많다.

아래 SQL에 region이 선두 컬럼인 인덱스를 이용하면, Sort Group By 연산을 생략할 수 있다. 실행계획에 'Sort Group By Nosort'라고 표시된 부분을 확인하기 바란다.
```
select region, avg(age), count(*)
from   customer
group by region

---------------------------------------------------------------------------------------
| Id  | Operation                      | Name         | Rows   | Bytes   | Cost (%CPU)|
---------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |              |     25 |     725 | 30142   (1)|
|   1 |   SORT GROUP BY NOSORT         |              |     25 |     725 | 30142   (1)|
|   2 |     TABLE ACCESS BY INDEX ROWID| CUSTOMER     |   1000K|      27M| 30142   (1)|
|   3 |       INDEX FULL SCAN          | CUSTOMER_X01 |   1000K|         |  2337   (2)|
---------------------------------------------------------------------------------------
```
위 실행계획을 수행하는 과정은 아래와 같다. Array Size는 3이라고 가정한다.

- [1] 인덱스에서 'A' 구간을 스캔하면서 테이블을 액세스하다가 'B'를 만나는 순간, 그때까지 집계한 값을 운반단위에 저장한다.
- [2] 계속해서 'B' 구간을 스캔하다가 'C'를 만나는 순간, 그때까지 집계한 값을 운반단위에 저장한다.
- [3] 계속해서 'C' 구간을 스캔하다가 'D'를 만나는 순간, 그때까지 집계한 값을 운반단위에 저장한다.
  Array Size가 3이므로 지금까지 읽은 A, B, C에 대한 집계결과를 클라이언트에게 전송하고 다음 Fetch Call이 올 때까지 기다린다.
  (추가 Fetch Call이 오지 않을 수도 있다. 그럴 경우, 작업은 여기서 끝난다.)
- [4] 클라이언트로부터 다음 Fetch Call이 오면, 1 ~ 3 과정을 반복한다. 물론, 두 번째 Fetch Call에서는 'D' 구간부터 읽기 시작한다.

이처럼 인덱스를 이용해 Nosort 방식으로 Group By를 처리하면 부분범위 처리가 가능해진다.