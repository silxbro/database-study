# 5.1 | 소트 연산에 대한 이해

SQL 수행 도중 가공된 데이터 집합이 필요할 때, 오라클은 PGA와 Temp 테이블스페이스를 활용한다. 소트 머지 조인, 해시 조인, 데이터 소트와 그룹핑 등이 대표적이다.
소트 머지 조인, 해시 조인 과정에 PGA와 Temp 테이블스페이스를 어떻게 활용하는지는 앞서 4장에서 살펴봤다. 지금부터 데이터를 소트하거나 그룹핑하는 과정을 살펴보자.

<br/>

## (1) 소트 수행 과정
소트는 기본적으로 PGA에 할당한 Sort Area에서 이루어진다. 메모리 공간인 Sort Area가 다 차면, 디스크 Temp 테이블스페이스를 활용한다.
Sort Area에서 작업을 완료할 수 있는지에 따라 소트를 두 가지 유형으로 나눈다.
- 메모리 소트(In-Memory Sort): 전체 데이터의 정렬 작업을 메모리 내에서 완료하는 것을 말하며, 'Internal Sort'라고도 한다.
- 디스크 소트(To-Disk Sort): 할당받은 Sort Area 내에서 정렬을 완료하지 못해 디스크 공간까지 사용하는 경우를 말하며, 'External Sort'라고도 한다.

다음은 디스크 소트 과정을 설명한 것이다.

소트할 대상 집합을 SGA 버퍼캐시를 통해 읽어들이고, 일차적으로 Sort Area에서 정렬을 시도한다.
Sort Area 내에서 정렬을 마무리하는 것이 최적이지만, 양이 많을 때는 **정렬된 중간 집합**을 Temp 테이블스페이스에 임시 세그먼트를 만들어 저장한다.
Sort Area가 찰 때마다 Temp 영역에 저장해 둔 중간 단계의 집합을 'Sort Run'이라고 부른다.

정렬된 최종 결과집합을 얻으려면 이를 다시 Merge 해야 한다. 각 Sort Run 내에서는 이미 정렬된 상태이므로 Merge 과정은 어렵지 않다.
오름차순 정렬이라면 각각에서 가장 작은 값부터 PGA로 읽어 들이다가 PGA가 찰 때마다 쿼리 수행 다음 단계로 전달하거나 클라이언트에게 전송하면 된다.

소트 연산은 메모리 집약적(Memory-intensive)일 뿐만 아니라 CPU 집약적(CPU-intensive)이기도 하다.
처리할 데이터량이 많을 때는 디스크 I/O까지 발생하므로 쿼리 성능을 좌우하는 매우 중요한 요소다. 디스크 소트가 발생하는 순간 SQL 수행 성능은 나빠질 수밖에 없다.

많은 서버 리소스를 사용하고 디스크 I/O가 발생하는 것도 문제지만, 부분범위 처리를 불가능하게 함으로써 OLTP 환경에서 애플리케이션 성능을 저하시키는 주요인이 되기도 한다.
될 수 있으면 소트가 발생하지 않도록 SQL을 작성해야 하고, 소트가 불가피하다면 메모리 내에서 수행을 완료할 수 있도록 해야 한다.

<br/>

## (2) 소트 오퍼레이션
본격적으로 소트 튜닝을 설명하기에 앞서 소트를 발생시키는 오퍼레이션에 어떤 것들이 있는지부터 살펴보자.

### [1] Sort Aggregate
Sort Aggregate는 아래처럼 전체 로우를 대상으로 집계를 수행할 때 나타난다. 'Sort'라는 표현을 사용하지만, 실제로 데이터를 정렬하진 않는다. Sort Area를 사용한다는 의미로 이해하면 된다.
```
SQL> select sum(sal), max(sal), min(sal), avg(sal) from emp;

-----------------------------------------------------------------------------
| Id  | Operation            | Name | Rows  | Bytes | Cost (%CPU)| Time     |
-----------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |      |     1 |     4 |     3   (0)| 00:00:01 |
|   1 |   SORT AGGREGATE     |      |     1 |     4 |            |          |
|   2 |     TABLE ACCESS FULL|      |    14 |    56 |     3   (0)| 00:00:01 |
-----------------------------------------------------------------------------
```
데이터를 정렬하지 않고 SUM, MAX, MIN, AVG 값 구하는 절차를 설명하면 아래와 같다.
- [1] Sort Area에 SUM, MAX, MIN, COUNT 값을 위한 변수를 각각 하나씩 할당한다.
- [2] EMP 테이블 첫 번째 레코드에서 읽은 SAL 값을 SUM, MAX, MIN 변수에 저장하고, COUNT 변수에는 1을 저장한다.
- [3] EMP 테이블에서 레코드를 하나씩 읽어 내려가면서 SUM 변수에는 값을 누적하고, MAX 변수에는 기존보다 큰 값이 나타날 때마다 값을 대체하고, MIN 변수에는 기존보다 작은 값이 나타날 때마다 값을 대체한다.
  COUNT 변수에는 SAL 값이 NULL이 아닌 레코드를 만날 때마다 1씩 증가시킨다.
- [4] EMP 레코드를 다 읽고 나면 SUM, MAX, MIN, COUNT 변수에 각각 최종값이 저장돼 있다. SUM, MAX, MIN 값은 변수에 담긴 값을 그대로 출력하고, AVG는 SUM 값을 COUNT 값으로 나눈 값을 출력하면 된다.


### [2] Sort Order By
Sort Order By는 데이터를 정렬할 때 나타난다.
```
SQL> seelct * from emp order by sal desc;

-----------------------------------------------------------------------------
| Id  | Operation            | Name | Rows  | Bytes | Cost (%CPU)| Time     |
-----------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |      |    14 |   518 |     4  (25)| 00:00:01 |
|   1 |   SORT ORDER BY      |      |    14 |   518 |     4  (25)| 00:00:01 |
|   2 |     TABLE ACCESS FULL| EMP  |    14 |   518 |     3   (0)| 00:00:01 |
-----------------------------------------------------------------------------
```

### [3] Sort Group By
Sort Group By는 소팅 알고리즘을 사용해 그룹별 집계를 수행할 때 나타난다.
```
SQL> select deptno, sum(sal), max(sal), min(sal), avg(sal)
  2  from  emp
  3  group by deptno
  4  order by deptno;

-----------------------------------------------------------------------------
| Id  | Operation            | Name | Rows  | Bytes | Cost (%CPU)| Time     |
-----------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |      |    11 |   165 |     4  (25)| 00:00:01 |
|   1 |   SORT GROUP BY      |      |    11 |   165 |     4  (25)| 00:00:01 |
|   2 |     TABLE ACCESS FULL| EMP  |    14 |   210 |     3   (0)| 00:00:01 |
-----------------------------------------------------------------------------
```
Sort Group By 처리 과정을 쉽게 설명하기 위해 수천 명의 사원(EMP)이 근무하는 회사를 가정해 보자. 부서는 네 개뿐이며, 부서코드로는 각각 10, 20, 30, 40을 사용한다.
컴퓨터의 도움을 받지 않고 부서별 급여(SAL)를 집계하려고 할 때, 어떤 방법을 사용하면 좋을까? 집계하고자 하는 항목은 급여에 대한 합계, 최대값, 최소값, 평균값이다.

급여 대장에서 전체 사원의 급여 정보를 읽어 부서번호 순으로 정렬하는 작업부터 해야 할까? 그렇지 않다. 10부터 40까지 적은 메모리 네 개만 준비하면 된다.
각 메모지에 SUM, MAX, MIN, COUNT를 적을 수 있도록 입력란을 두고, 메모리를 부서번호 순으로 정렬해 놓으면 준비 끝이다.

이제 각 사원의 급여 정보를 읽기 시작한다. 읽은 각 사원의 부서번호에 해당하는 메모지를 찾는다. 정렬돼 있으므로 메모지 찾기는 어렵지 않다.
메모지를 찾았으면 SUM, MAX, MIN, COUNT 값을 갱신한다. Sort Aggregate에서 사용했던 방식을 여기서도 똑같이 사용한다.
급여 대장을 다 읽고 나서 메모지에 기록돼 있는 정보가 우리가 원하던 부서별 급여 집계다.

쉽게 설명하려고 메모지 네 장을 미리 준비하는 방식을 사용했다. 부서 개수를 미리 안다고 전제한 것이다.
부서 개수를 미리 알 수 없다면, 급여 대장을 읽다가 새로운 부서가 나타날 때마다 새로 준비한 메모지를 정렬 순서에 맞춰 중간에 끼워 넣는 방식을 사용해야 한다.

DBMS가 Sort Group By를 처리할 때 방금 설명한 방식을 사용한다. 이 방식을 사용하면, 사원이 수억 명이어도 단 네 장의 메모지만 있으면 된다는 사실에 주목하자.
부서(그룹 개수)가 많지 않다면 Sort Area가 클 필요가 전혀 없다. 집계할 대상 레코드가 아무리 많아도 Temp 테이블스페이스를 쓰지 않는다는 뜻이다.

오라클 10gR2 버전에서 도입된 Hash Group By 방식도 알아둘 필요가 있다. Group By 절 뒤에 Order By 절을 명시하지 않으면 이제 대부분 Hash Group By 방식으로 처리하기 때문이다.
```
SQL> select deptno, sum(sal), max(sal), min(sal), avg(sal)
  2  from  emp
  3  group by deptno  ;

-----------------------------------------------------------------------------
| Id  | Operation            | Name | Rows  | Bytes | Cost (%CPU)| Time     |
-----------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |      |    11 |   165 |     4  (25)| 00:00:01 |
|   1 |   HASH GROUP BY      |      |    11 |   165 |     4  (25)| 00:00:01 |
|   2 |     TABLE ACCESS FULL| EMP  |    14 |   210 |     3   (0)| 00:00:01 |
-----------------------------------------------------------------------------
```
Sort Group By에서 메모지를 찾기 위해 소트 알고리즘을 사용했다면, Hash Group By는 해싱 알고리즘을 사용한다.

읽는 레코드마다 Group By 컬럼의 해시 값으로 해시 버킷을 찾아 그룹별로 집계항목을 갱신하는 방식이다.
부서(그룹 개수)가 많지 않다면 집계할 대상 레코드가 아무리 많아도 Temp 테이블스페이스 쓸 일이 전혀 없다.

- #### [그룹핑 결과의 정렬 순서]

  10gR2에서 Hash Group By가 도입되면서 정렬 순서를 보장하지 않게 되었다고 많은 분들이 알고 있지만, 사실 오라클은 9i부터 이미 그룹핑 결과가 정렬 순서를 보장하지 않는다고 여러 문서를 통해
  공식적으로 밝히고 있다. (심지어 그 이전에도 보장한 적은 없다고 말한다.)

  그런데 "문서 상으로만 그렇게 공표했을 뿐 Sort Group By는 정렬이 보장된다"고 믿는 분들이 많다.

  요컨대, 실행계획에 표시된 'Sort Group By'의 의미는 '소팅 알고리즘을 사용해 값을 집계한다'는 뜻일 뿐 결과의 정렬을 의미하지는 않는다. 물론 쿼리에 Order By 절을 명시하면 정렬 순서가 보장된다.
  이때도 실행계획은 똑같이 'Sort Group By'로 표시되므로, 실행계획만 보고 정렬 여부를 판단해서는 안 된다.

  같은 Sort Group By인데 Order By 유무에 따라 정렬 순서가 달라지는 이유는 무엇일까? 소팅 알고리즘을 사용해 그룹핑한 결과집합은 논리적인 정렬 순서를 갖는 **연결 리스트 구조**다.
  사용자가 Order By를 명시하면 오라클은 논리적 정렬 순서를 따라 값을 읽는다. 그래서 정렬 순서가 보장된다.

  물리적으로 저장된 순서는 논리적 순서와 다를 수 있고, Order By 절이 없으면 오라클 입장에서 반드시 정렬된 순서로 출력할 의무가 없다.
  이때는 논리적 순서를 무시하고 물리적으로 저장된 순서에 따라 값을 읽으므로 정렬을 보장하지 않는 것이다.

  결론적으로 말해 **정렬된 그룹핑 결과를 얻고자 한다면, 실행계획에 설령 'Sort Group By'라고 표시되더라도 반드시 Order By를 명시해야 한다.**

  한 가지 첨언하자면, "Group By만 기술한 기존 쿼리에 Order By를 추가하면 성능이 나빠질 텐데도 무책임하게 어느 날 갑자기 결과를 보장하지 않는다는 공식 입장을 발표했다"며 오라클을 비판하는 글을
  본 적이 있다. 그것은 오해다. 이미 설명한 것처럼 그룹핑을 위해 내부에서 사용하는 알고리즘이 바뀔 뿐이며, Order By 절을 추가한다고 해서 그룹핑과 정렬 작업을 각각 수행하지는 않는다.
  물론 알고리즘 차이 때문에 생기는 성능 차이는 있을 수 있다.


### 4. Sort Unique
옵티마이저가 서브쿼리를 풀어 일반 조인문으로 변환하는 것을 '서브쿼리 Unnesting'이라고 한다.
Unnesting된 서브쿼리가 M쪽 집합이면(1쪽 집합이더라도 조인 컬럼에 Unique 인덱스가 없으면), 메인 쿼리와 조인하기 전에 중복 레코드부터 제거해야 한다.
이때 아래와 같이 Sort Unique 오퍼레이션이 나타난다.

```
SQL> select /*+ ordered use_nl(dept)*/ * from dept
  2  where  deptno in (select /*+ unnest */ deptno
  3                    from emp where job='CLERK');

-------------------------------------------------------------------------------------
| Id  | Operation                        | Name        | Rows  | Bytes | Cost (%CPU)|
-------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                 |             |     3 |    87 |     4  (25)|
|   1 |   NESTED LOOPS                   |             |     3 |    87 |     4  (25)|
|   2 |     SORT UNIQUE                  |             |     3 |    33 |     2   (0)|
|   3 |       TABLE ACCESS BY INDEX ROWID| EMP         |     3 |    33 |     2   (0)|
|   4 |         INDEX RANGE SCAN         | EMP_JOB_IDX |     3 |       |     1   (0)|
|   5 |     TABLE ACCESS BY INDEX ROWID  | DEPT        |     1 |    18 |     1   (0)|
|   6 |       INDEX UNIQUE SCAN          | DEPT_PK     |     1 |       |     0   (0)|
-------------------------------------------------------------------------------------
```
만약 PK/Unique 제약 또는 Unique 인덱스를 통해 Unnesting된 서브쿼리의 유일성(Uniqueness)이 보장된다면, Sort Unique 오퍼레이션은 생략된다.

Union, Minus, Intersect 같은 집합(Set) 연산자를 사용할 때도 아래와 같이 Sort Unique 오퍼레이션이 나타난다.
```
SQL> select job, mgr from emp where deptno = 10
  2  union
  3  select job, mgr from emp where deptno = 20;

-------------------------------------------------------------------------------
| Id  | Operation              | Name | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------
|   0 | SELECT STATEMENT       |      |    10 |   150 |     8  (63)| 00:00:01 |
|   1 |   SORT UNIQUE          |      |    10 |   150 |     8  (63)| 00:00:01 |
|   2 |     UNION ALL          |      |       |       |            |          |
|   3 |       TABLE ACCESS FULL| EMP  |     5 |    75 |     3   (0)| 00:00:01 |
|   4 |       TABLE ACCESS FULL| EMP  |     5 |    75 |     3   (0)| 00:00:01 |
-------------------------------------------------------------------------------

SQL> select job, mgr from emp where deptno = 10
  2  minua
  3  select job, mgr from emp where deptno = 20;

-------------------------------------------------------------------------------
| Id  | Operation              | Name | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------
|   0 | SELECT STATEMENT       |      |     5 |   150 |     8  (63)| 00:00:01 |
|   1 |   MINUS                |      |       |       |            |          |
|   2 |     SORT UNIQUE        |      |     5 |    75 |     4  (25)| 00:00:01 |
|   3 |       TABLE ACCESS FULL| EMP  |     5 |    75 |     3   (0)| 00:00:01 |
|   4 |     SORT UNIQUE        |      |     5 |    75 |     4  (25)| 00:00:01 |
|   5 |       TABLE ACCESS FULL| EMP  |     5 |    75 |     3   (0)| 00:00:01 |
-------------------------------------------------------------------------------
```
Distinct 연산자를 사용해도 Sort Unique 오퍼레이션이 나타난다.
```
SQL> select distinct deptno from emp order by deptno;

-------------------------------------------------------------------------------
| Id  | Operation            | Name | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |      |     3 |     9 |     5  (40)| 00:00:01 |
|   1 |   SORT UNIQUE        |      |     3 |     9 |     4  (25)| 00:00:01 |
|   2 |     TABLE ACCESS FULL| EMP  |    14 |    42 |     3   (0)| 00:00:01 |
-------------------------------------------------------------------------------
```
오라클 10gR2부터는 Distinct 연산에도 아래와 같이 Hash Unique 방식을 사용한다. Group By 와 마찬가지로 Order By를 생략할 때 그렇다.
```
SQL> select distinct deptno from emp;

-------------------------------------------------------------------------------
| Id  | Operation            | Name | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |      |     3 |     9 |     4  (40)| 00:00:01 |
|   1 |   HASH UNIQUE        |      |     3 |     9 |     4  (25)| 00:00:01 |
|   2 |     TABLE ACCESS FULL| EMP  |    14 |    42 |     3   (0)| 00:00:01 |
-------------------------------------------------------------------------------
```

### 5. Sort Join
Sort Join 오퍼레이션은 소트 머지 조인을 수행할 때 나타난다.
```
SQL> select /*+ ordered use_merge(e) */ *
  2  from   dept d, emp e
  3  where  d.deptno = e.deptno ;

-------------------------------------------------------------------------------
| Id  | Operation              | Name | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------
|   0 | SELECT STATEMENT       |      |    14 |   770 |     8  (25)| 00:00:01 |
|   1 |   MERGE JOIN           |      |    14 |   770 |     8  (25)| 00:00:01 |
|   2 |     SORT JOIN          |      |     4 |    72 |     4  (25)| 00:00:01 |
|   3 |       TABLE ACCESS FULL| DEPT |     4 |    72 |     3   (0)| 00:00:01 |
|   4 |     SORT JOIN          |      |    14 |   518 |     4  (25)| 00:00:01 |
|   5 |       TABLE ACCESS FULL| EMP  |    14 |   518 |     3   (0)| 00:00:01 |
-------------------------------------------------------------------------------
```

### 6. Window Sort
Window Sort는 윈도우 함수(=분석 함수)를 수행할 때 나타난다.
```
SQL> select empno, ename, job, mgr, sal
2         , avg(sal) over (partition by deptno)
3    from emp ;

-------------------------------------------------------------------------------
| Id  | Operation              | Name | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------
|   0 | SELECT STATEMENT       |      |    14 |   406 |     4  (25)| 00:00:01 |
|   1 |   WINDOW SORT          |      |    14 |   406 |     4  (25)| 00:00:01 |
|   2 |     TABLE ACCESS FULL  | EMP  |    14 |   406 |     3   (0)| 00:00:01 |
-------------------------------------------------------------------------------
```

지금까지 소트를 발생시키는 오퍼레이션 종류에 대해 살펴봤고, 이제 본격적으로 소트 튜닝 방안에 대해 살펴보기로 하자.