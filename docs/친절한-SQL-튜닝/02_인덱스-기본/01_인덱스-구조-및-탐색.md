# 2.1 | 인덱스 구조 및 탐색

본 절은 인덱스 구조와 탐색 원리를 설명한다. 아주 기본적인 내용 같지만, 의외로 인덱스의 기본 구조와 탐색 원리조차 모르는 분이 많다는 사실이다.
인덱스에 대한 명확한 그림이 없는 상태에서 인덱스를 설계하고 SQL을 개발하니 성능이 좋을 리 없다.

본 절에서 강조하고 싶은 내용은 인덱스 탐색 과정이 수직적 탐색과 수평적 탐색, 두 단계로 이루어진다는 사실이다. 이것을 이해하고 나면 막연하게 생각했던 인덱스 구조에 대해 그림이 명확해진다.
그런 후에야 인덱스 사용법과 튜닝도 제대로 이해할 수 있다.

<br/>

## (1) 미리 보는 인덱스 튜닝
인덱스 튜닝은 3장에서 본격적으로 설명하지만, 인덱스 구조를 설명하는 이번 장에서 그 핵심 원리를 간단하게나마 살펴보려고 한다. 이유는, 인덱스 구조를 바라보는 시각을 SQL 튜닝에 맞추기 위해서다.

### [데이터를 찾는 두 가지 방법]
데이터베이스 테이블에서 데이터를 찾는 방법은 두 가지가 있다. 수십 년에 걸쳐 DBMS가 발전해 왔는데도 이 두 방법에서 크게 벗어나지 못하고 있다.
- 테이블 전체를 스캔한다.
- 인덱스를 이용한다.

테이블 전체 스캔과 관련해서는 튜닝 요소가 많지 않지만, 인덱스와 관련해서는 튜닝 요소가 매우 많고 기법도 다양하다. 그래서 인덱스는 SQL 튜닝을 공부할 떄 가장 먼저 다루어야 할 주제다.

### [인덱스 튜닝의 두 가지 핵심요소]
인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용한다.
**온라인 트랜잭션 처리**(Online Transaction Processing, 이하 '**OLTP**') 시스템에서는 소량 데이터를 주로 검색하므로 인덱스 튜닝이 무엇보다 중요하다.

세부적인 인덱스 튜닝 방법으로 여러 가지가 있지만, 핵심요소는 크게 두 가지로 나뉜다. 첫번째는 인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것이다. 즉, 인덱스 스캔 효율화 튜닝이다.

인덱스 튜닝의 두 번째 핵심요소는 테이블 액세스 횟수를 줄이는 것이다. 인덱스 스캔 후 테이블 레코드를 액세스할 때 랜덤 I/O 방식을 사용하므로 이를 '랜덤 액세스 최소화 튜닝'이라고 한다.

인덱스 스캔 효율화 튜닝과 랜덤 액세스 최소화 튜닝 둘 다 중요하지만, 더 중요한 하나를 고른다면 랜덤 액세스 최소화 튜닝이다. 성능에 미치는 영향이 더 크기 때문이다.

인덱스 설명을 시작하는 초반에 본서의 가장 중요한 결론부터 전달하려고 한다. **SQL 튜닝은 랜덤 I/O와의 전쟁이다.**

### [SQL 튜닝은 랜덤 I/O와의 전쟁]
데이터베이스 성능이 느린 이유는 디스크 I/O 때문이다. 읽어야 할 데이터량이 많고, 그 과정에 디스크 I/O가 많이 발생할 때 느리다.
인덱스를 많이 사용하는 OLTP 시스템이라면 디스크 I/O 중에서도 랜덤 I/O가 특히 중요하다.

성능을 위해 DBMS가 제공하는 많은 기능이 느린 랜덤 I/O를 극복하기 위해 개발됐다는 사실을 본서를 읽는 내내 확인하게 될 것이다.
IOT, 클러스터, 파티션에서부터 테이블 Prefetch, Batch I/O처럼 겉으로 잘 들어나지 않은 숨은 기능까지 모두가 그렇다. 이들 기능의 본질은 랜덤 I/O를 줄이는 데 있다.

조인 메소드 중 가장 일반적으로 사용하는 NL 조인이 대량 데이터 조인할 때 느린 이유도 랜덤 I/O 때문이다.
그래서 소트머지 조인과 해시 조인이 개발됐으므로 이들 조인 메소드도 결국 느린 랜덤 I/O를 극복하기 위해서 개발된 기능이다. 랜덤 I/O가 그만큼 중요하다.

기본적인 I/O 메커니즘과 랜덤 액세스 개념은 1장에 다뤘다. 랜덤 액세스 최소화를 포함한 인덱스 튜닝은 3장에서, 조인 튜닝은 4장에서 다룬다. 이 책의 클라이맥스다.
그에 앞서 본장은 인덱스 구조와 인덱스 사용법을 다룬다.

<br/>

## (2) 인덱스 구조
인덱스는 대용량 테이블에서 필요한 데이터만 빠르게 효율적으로 액세스하기 위해 사용하는 오브젝트다. 모든 책 뒤쪽에 있는 색인과 같은 역할을 한다.

데이터베이스에서 인덱스 없이 데이터를 검색하려면, 테이블을 처음부터 끝까지 모두 읽어야 한다. 반면, 인덱스를 이용하면 일부만 읽고 멈출 수 있다. 즉, 범위 스캔(Range Scan)이 가능하다.
범위 스캔이 가능한 이유는 인덱스가 정렬돼 있기 때문이다.

DBMS는 일반적으로 B*Tree 인덱스를 사용한다. 나무(Tree)를 거꾸로 뒤집은 모야잉어서 뿌리(루트, Root)가 위쪽에 있고, 가지(브랜치, Branch)를 거쳐 맨 아래에 잎사귀(리프, Leaf)가 있다.

루트와 브랜치 블록에 있는 각 레코드는 하위 블록에 대한 주소값을 갖는다. 키값은 하위 블록에 저장된 키값의 범위를 나타낸다.

루트와 브랜치 블록에는 키값을 갖지 않는 특별한 레코드가 하나 있다. 가장 왼쪽 첫 번째 레코드다. 이를 'LMC'라고 하며 'Leftmost Child'의 줄임말이다.
LMC는 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킨다. LMC가 가리키는 주소로 찾아간 블록에는 키값을 가진 첫 번째 레코드가 저장돼 있다.

리프 블록에 저장된 각 레코드는 키값 순으로 정렬돼 있을 뿐만 아니라 테이블 레코드를 가리키는 주소값, 즉 ROWID를 갖는다. 인덱스 키값이 같으면 ROWID 순으로 정렬된다.
앤덱스를 스캔하는 이유는, 검색 조건을 만족하는 소량의 데이터를 빨리 찾고 거기서 ROWID를 얻기 위해서다.
ROWID는 아래와 같이 데이터 블록 주소(DBA, Data Block Address)와 로우 번호로 구성되므로 이 값을 알면 테이블 레코드를 찾아갈 수 있다.
- ROWID = 데이터 블록 주소 + 로우 번호
- 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
- 블록 번호 : 데이터파일 내에서 부여한 상대적 순번
- 로우 번호 : 블록 내 순번

인덱스 탐색 과정은 수직적 탐색과 수평적 탐색으로 나눌 수 있다.
- 수직적 탐색 : 인덱스 스캔 시작지점을 찾는 과정
- 수평적 탐색 : 데이터를 찾는 과정

인덱스 탐색 과정을 알고 나면 인덱스 구조를 더 잘 이해할 수 있다. 수직적 탐색부터 살펴보자.

<br/>

## (3) 인덱스 수직적 탐색
정렬된 인덱스 레코드 중 조건을 만족하는 첫 번째 레코드를 찾는 과정이다. 즉, 인덱스 스캔 시작지점을 찾는 과정이다.

인덱스 수직적 탐색은 루트(Root) 블록에서부터 시작한다. 루트를 포함해 브랜치(Branch) 블록에 저장된 각 **인덱스 레코드는 하위 블록에 대한 주소값을 갖는다.**
루트에서 시작해 리프(Leaf) 블록까지 수직적 탐색이 가능한 이유다.

수직적 탐색 과정에 찾고자 하는 값보다 크거나 같은 값을 만나면, 바로 직전 레코드가 가리키는 하위 블록으로 이동한다.
크거나 같은 값이 없을 경우, 맨 마지막 레코드가 가리키는 하위 블록으로 이동하면 된다. 만약 정확히 일치하는 레코드가 있을 경우, 그 레코드가 가리키는 하위 블록으로 이동하면 안 된다.
바로 직전 레코드가 가리키는 하위 블록으로 이동해야 혹시 모를 다른 동일한 레코드를 놓치지 않는다.

**수직적 탐색은 '조건을 만족하는 레코드'를 찾는 과정이 아니라 '조건을 만족하는 첫 번째 레코드'를 찾는 과정임을 반드시 기억하자.**

<br/>

## (4) 인덱스 수평적 탐색
수직적 탐색을 통해 스캔 시작점을 찾았으면, 찾고자 하는 데이터가 더 안 나타날 때까지 인덱스 리프 블록을 수평적으로 탐색한다. 인덱스에서 본격적으로 데이터를 찾는 과정이다.
인덱스 리프 블록끼리는 서로 앞뒤 블록에 대한 주소값을 갖는다. 즉, 양방향 연결 리스트(double linked list) 구조다. 좌에서 우로, 또는 우에서 좌로 수평적 탐색이 가능한 이유다.

인덱스를 수평적으로 탐색하는 이유는 첫째, 조건절을 만족하는 데이터를 모두 찾기 위해서고 둘째, ROWID를 얻기 위해서다.
필요한 컬럼을 인덱스가 모두 갖고 있어 인덱스만 스캔하고 끝나는 경우도 있지만, 일반적으로 인덱스를 스캔하고서 테이블도 액세스한다. 이때 ROWID가 필요하다.

<br/>

## (5) 결합 인덱스 구조와 탐색
두 개 이상 컬럼을 결합해서 인덱스를 만들 수도 있다.

인덱스 선두 컬럼을 모두 '=' 조건으로 검색할 때는 어느 컬럼을 인덱스 앞쪽에 두든 블록 I/O 개수가 같으므로 성능도 똑같다.
DBMS가 사용하는 B*Tree 인덱스는 엑셀처럼 평면(필터) 구조가 아닌, 다단계 구조다. 따라서 어느 컬럼을 앞에 두든 일량에는 차이가 없다.

인덱스 구성에 따라 성능에 차이가 나는 것은 맞지만, 선두 컬럼을 모두 '=' 조건으로 검색할 때는 모든 경우가 성능이 같다.

- #### ['Balanced'의 의미]

  delete 작업 때문에 인덱스가 불균형(Unbalanced) 상태에 놓일 수 있다고 설명한 자료들을 볼 수 있다.
  다른 리프 노드에 비해 루트 블록과의 거리가 더 멀거나 가까운 리프 노드가 생길 수 있다는 설명인데, B*Tree 인덱스에서 이런 현상은 절대 발생하지 않는다.
  B*Tree 인덱스의 'B'가 'Balanced'의 약자임을 기억하기 바란다.

  'Balanced'는 어떤 값으로 탐색하더라도 인덱스 루트에서 리프 블록에 도달하기까지 읽는 블록 수가 같음을 의미한다. 즉, 루트로부터 모든 리프 블록까지의 높이(height)는 항상 같다.