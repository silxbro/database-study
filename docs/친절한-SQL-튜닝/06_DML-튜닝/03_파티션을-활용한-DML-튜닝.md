# 6.3 | 파티션을 활용한 DML 튜닝

파티션을 이용하면 대량 추가/변경/삭제 작업을 빠르게 처리할 수 있다. 이를 이해하려면 파티션에 대한 사전 지식이 필요한데, 파티션은 별도 챕터로 구성해야 할 정도로 다룰 내용이 많다.
따라서 이번 장을 이해하는 데 필요한 수준에서만 간단히 설명하려고 하니 파티션 개념이 익숙하다면 바로 3항(6.3.3)으로 건너뛰어도 상관없다.

<br/>

## (1) 테이블 파티션
파티셔닝(Partitioning)은 테이블 또는 인덱스 데이터를 특정 컬럼(파티션 키) 값에 따라 별도 세그먼트에 나눠서 저장하는 것을 말한다.

데이터를 월별, 분기별, 반기별, 연별로 분할해서 저장해 두면 빠르게 조회할 수 있고, 관리 하기도 쉽다.
일반적으로 시계열에 따라 Range 방식으로 분할하지만, 그 외 다른 기준(리스트 또는 해시 방식)으로 분할할 수도 있다.

파티션이 필요한 이유를 관리적 측면과 성능적 측면으로 나눠 짧게 요약하면 아래와 같다.

- 관리적 측면 : 파티션 단위 백업, 추가, 삭제, 변경 → 가용성 향상
- 성능적 측면 : 파티션 단위 조회 및 DML, 경합 또는 부하 분산

파티션에는 Range, 해시, 리스트 세 종류가 있다.

### [Range 파티션]
오라클 8 버전부터 제공된 가장 기초적인 방식으로 주로 날짜 컬럼을 기준으로 파티셔닝한다. 아래는 주문 테이블을 주문일자 기준으로 분기별 Range 파티셔닝하는 방법을 예시하고 있다.
```
create table 주문 ( 주문번호 number, 주문일자 varchar2(8), 고객ID varchar2(5)
                 , 배송일자 varchar2(8), 주문금액 number, ... )
partition by range(주문일자) (
  partition p2017_1Q values less than ('20170401')
, partition p2017_2Q values less than ('20170701')
, partition p2017_3Q values less than ('20171001')
, partition p2017_4Q values less than ('20180101')
, partition p2018_1Q values less than ('20180401')
, partition p9999_MX values less than ( MAXVALUE )  → 주문일자 >= '20180401'
) ;
```
위 스크립트에 의해 생성된 파티션 테이블에 값을 입력하면 각 레코드를 파티션 키 값에 따라 분할 저장하고, 읽을 때도 검색 조건을 만족하는 파티션만 골라 읽을 수 있어 이력성 데이터를 Full Scan
방식으로 조회할 때 성능을 크게 향상한다.
보관주기 정책에 따라 과거 데이터가 저장된 파티션만 백업하고 삭제하는 등 데이터 관리 작업을 효율적이고 빠르게 수행할 수 있는 장점도 있다.

파티션 테이블에 대한 SQL 성능 향상 원리는 파티션 Pruning(=Elimination)에 있다. 'prune'은 '쓸데없는 가지를 치다', '불필요한 부분을 제거한다'는 뜻을 가진다.
용어에서 알 수 있듯, 파티션 Pruning은 SQL 하드파싱이나 실행 시점에 조건절을 분석해서 읽지 않아도 되는 파티션 세그먼트를 액세스 대상에서 제외하는 기능이다.

예를 들어, 아래와 같은 조건절이 있다.
```
select *
from   주문
where  주문일자 >= '20120401'
and    주문일자 <= '20120630'
```
이 조건절을 만족하는 데이터는 전체 1,200만 건 중 25%에 해당하는 300만 건이다. 이 정도 데이터를 인덱스로 건건이 랜덤 액세스하면 테이블 전체를 스캔하는 것보다 오히려 성능이 더 느리다.
그렇다고 테이블 전체를 스캔하자니 사이즈가 너무 커(예를 들어, 100GB) 부담스럽다.

그럴 때 테이블을 100만 건 단위로 나눠서 저장하면, Full Scan 하더라도 전체가 아닌 일부 파티션 세그먼트만 읽고 멈출 수 있어 성능을 크게 향상한다.
파티션과 병렬 처리가 만나면 그 효과를 배가 된다. 파티션 테이블도 인덱스로 액세스할 수 있지만, 파티션 Pruning을 이용한 테이블 스캔보다 훨씬 느리다.

파티션도 클러스터, IOT와 마찬가지로 관련 있는 데이터가 흩어지지 않고 물리적으로 인접하도록 저장하는 클러스터링 기술에 속한다. 클러스터아 다른 점은 세그먼트 단위로 모아서 저장한다는 것이다.
클러스터는 데이터를 블록 단위로 모아 저장한다고 이전에 설명하였다((3.1.7)). IOT는 데이터를 정렬된 순서로 저장하는 구조라고 설명하였다.((3.1.6))

### [해시 파티션]
해시 파티션은 Range 파티션에 이어 오라클 8i 버전부터 제공하기 시작했다. 파티션 키 값을 해시 함수에 입력해서 반환받은 값이 같은 데이터를 같은 세그먼트에 저장하는 방식이다.
파티션 개수만 사용자가 결정하고 데이터를 분산하는 알고리즘은 오라클 내부 해시함수가 결정한다.

해시 파티션은 고객ID처럼 변별력이 좋고 데이터 분포가 고른 컬럼을 파티션 기준으로 선정해야 효과적이다. 아래는 고객ID 기준으로 고객 테이블을 해시 파티셔닝하는 방법을 예시한다.
```
create table 고객 ( 고객ID varchar2(5), 고객명 varchar2(10), ... )
partition by hash(고객ID) partitions 4;
```

검색할 때는 조건절 비교 값(상수 또는 변수)에 똑같은 해시 함수를 적용함으로써 읽을 파티션을 결정한다. 해시 알고리즘 특성상 등치(=) 조건 또는 IN-List 조건으로 검색할 때만 파티션 Pruning이 작동한다.

### [리스트 파티션]
오라클 9i 버전부터 제공하기 시작한 리스트 파티션은, 사용자가 정의한 그룹핑 기준에 따라 데이터를 분할 저장하는 방식이다. 아래는 지역분류 기준으로 인터넷매물 테이블을 리스트 파티셔닝하는 방법을 예시한다.
```
create table 인터넷매물 ( 물건코드 varchar2(5), 지역분류 varchar2(4), ... )
partition by list(지역분류) (
  partition P_지역1 values ('서울')
, partition P_지역2 values ('경기', '인천')
, partition P_지역3 values ('부산', '대구', '대전', '광주')
, partition P_지역4 values (DEFAULT)    → 기타 지역
);
```
Range 파티션에선 값의 순서에 따라 저장할 파티션이 결정되지만, 리스트 파티션에서는 순서와 상관없이 불연속적인 값의 목록에 의해 결정된다.

해시 파티션과 비교하면, 해시 파티션은 오라클이 정한 해시 알고리즘에 따라 임의로 분할하는 반면, 리스트 파티션은 사용자가 정의한 논리적인 그룹에 따라 분할한다.
업무적인 친화도에 따라 그룹핑 기준을 정하되, 될 수 있으면 각 파티션에 값이 고르게 분산되도록 해야 한다.

<br/>

## (2) 인덱스 파티션
테이블 파티션과 인덱스 파티션은 구분돼야 한다. 인덱스 파티션은 테이블 파티션과 맞물려 다양한 구성이 존재한다. 다양한 인덱스 파티션 구성을 설명하기 위해 우선 테이블 파티션을 다음과 같이 구분하자.
- 비파티션 테이블 (Non-Partitioned Table)
- 파티션 테이블 (Partitioned Table)

인덱스도 테이블처럼 파티션 여부에 따라 파티션 인덱스와 비파티션 인덱스로 나뉘고, 파티션 인덱스는 각 파티션이 커버하는 테이블 파티션 범위에 따라 로컬과 글로벌로 나뉜다.
- 로컬 파티션 인덱스 (Local Partitioned Index)
- 글로벌 파티션 인덱스 (Global Partitioned Index)
- qlvkxltus dlseprtm (Non-Partitioned Index)

로컬 파티션 인덱스는 각 테이블 파티션과 인덱스 파티션이 서로 1:1 대응 관계가 되도록 오라클이 자동으로 관리하는 파티션 인덱스를 말한다.
로컬이 아닌 파티션 인덱스는 '모두' 글로벌 파티션 인덱스이며, 테이블 파티션과 독립적인 구성(파티션 키, 파티션 기준값 정의)을 갖는다.

테이블과 인덱스 파티션을 조합하면, 아래와 같은 구성이 가능하다.

- 비파티션 테이블 & 비파티션 인덱스
- 비파티션 테이블 & 글로벌 파티션 인덱스
- 파티션 테이블  & 비파티션 인덱스
- 파티션 테이블 & 글로벌 파티션 인덱스
- 파티션 테이블 & 로컬 파티션 인덱스

### [로컬 파티션 인덱스]
앞서 Range 파티션을 설명하면서 예시로 만든 주문 테이블에 로컬 파티션 인덱스를 만들어 보자. 아래와 같이 CREATE INDEX 문 뒤에 'LOCAL' 옵션을 추가하면 된다.
```
create index 주문_x01 on 주문 ( 주문일자, 주문금액 ) LOCAL;

create index 주문_x02 on 주문 ( 고객ID, 주문일자 ) LOCAL;
```
각 인덱스 파티션은 테이블 파티션 속성을 그대로 상속받는다. 따라서 테이블 파티션 키가 주문일자면 인덱스 파티션 키도 주문일자가 된다. 로컬 파티션 인덱스를 '로컬 인덱스'로 줄여서 부르기도 한다.

로컬 파티션 인덱스는 테이블과 정확히 1:1 대응 관계를 갖도록 오라클이 파티션을 자동으로 관리해 준다. 테이블 파티션 구성을 변경(add, drop, exchange 등)하더라도 인덱스를 재생성할 필요가 없다.
변경작업이 순식간에 끝나므로 피크(peek) 시간대만 피하면 서비스를 중단하지 않고도 작업할 수 있다. 로컬 파티션 인덱스의 장점은 이처럼 관리 편의성에 있다.

### [글로벌 파티션 인덱스]
글로벌 파티션(Global Partitioned) 인덱스는 파티션을 테이블과 다르게 구성한 인덱스다. 구체적으로, 파티션 유형이 다르거나, 파티션 키가 다르거나, 파티션 기준값 정의가 다른 경우다.
비파티션 테이블이어도 인덱스는 파티셔닝할 수 있다.

앞서 Range 파티션을 설명하면서 만든 주문 테이블에 [주문금액 + 주문일자] 순으로 글로벌 파티션 인덱스를 만들어 보자.
아래와 같이 CREATE INDEX 문 뒤에 'GLOBAL' 키워드를 추가하고, 파티션을 정의하면 된다.
```
create index 주문_x03 on 주문 ( 주문금액, 주문일자 ) GLOBAL
partition by range(주문금액) (
  partition P_01 values less than ( 100000 )
, partition P_MX values less than ( MAXVALUE )  → 주문금액 >= 100000
) ;
```
글로벌 파티션 인덱스는 테이블 파티션 구성을 변경(drop, exchange, split 등)하는 순가나 Unusable 상태로 바뀌므로 곧바로 인덱스를 재생성해 줘야 한다.
그동안 해당 테이블을 사용하는 서비스를 중단해야 한다.

만약 테이블과 인덱스가 정확히 1:1 관계가 되도록 DB 관리자가 파티션을 직접 구성할 수도 있지만, 그렇다고 그것이 로컬 파티션은 아니다. 오라클이 인덱스 파티션을 자동으로 관리해 주지 않기 때문이다.
모양은 로컬 파티션이지만, 글로벌 파티션에 속한다.

### [비파티션 인덱스]
비파티션(Non-Partitioned) 인덱스는 말 그대로 파티셔닝하지 않은 인덱스다. 만드는 방법은 아래와 같다. 일반 CREATE INDEX 문이다.
```
create index 주문_x04 on 주문 ( 고객ID, 배송일자 );
```
비파티션 인덱스는 여러 테이블 파티션을 가리킨다. 그런 으미에서 비파티션 인덱스를 '글로벌 비파티션 인덱스'라가ㅗ 부르기도 한다.

비파티션 인덱스는 테이블 파티션 구성을 변경(drop, exchange, split 등)하는 순간 Unusable 상태로 바뀌므로 곧바로 인덱스를 재생성해 줘야 한다. 그동안 테이블을 사용하는 서비스를 중단해야 한다.

### [Prefixed vs. Nonprefixed]
파티션 인덱스를 Prefixed와 Nonprefixed로 나눌 수도 있다. 이는 인덱스 파티션 키 컬럼이 인덱스 구성상 왼쪽 선두 컬럼에 위치하는지에 따른 구분이다.
- Prefixed : 인덱스 파티션 키 컬럼이 인덱스 키 컬럼 왼쪽 선두에 위치한다.
- Nonprefixed : 인덱스 파티션 키 컬럼이 인덱스 키 컬럼 왼쪽 선두에 위치하지 않는다. 파티션 키가 인덱스 컬럼에 아예 속하지 않을 때도 여기에 속한다.

로컬과 글로벌, Prefixed와 Nonprefixed를 조합하며녀 아래 네 가지 구성이 나온다.

|구분|Prefixed|Nonprefixed|
|:---:|:---:|:---:|
|**로컬 파티션**|1|2|
|**글로벌 파티션**|3|4<br/>(Not Support)|

글로벌 파티션 인덱스는 Prefixed 파티션만 지원되므로 결과적으로 세 개의 파티션 인덱스가 있고, 비파티션 인덱스를 포함해 아래 네 가지 유형으로 최종 정리할 수 있다.

- 로컬 Prefixed 파티션 인덱스
- 로컬 Nonprefixed 파티션 인덱스
- 글로벌 Prefixed 파티션 인덱스
- 비파티션 인덱스

조금 전 '주문' 테이블에 만든 네 개 인덱스를 조회해 보자.
```
SQL> select i.index_name, i.partitioned, i.partitioning_type
  2       , p.locality, p.alignment
  3  from   user_indexes i, user_part_indexes p
  4  where  i.table_name = '주문'
  5  and    p.index_name(+) = i.index_name
  6  order by i.index_name;

INDEX_NAME     PAR PARTITION LOCALI ALIGNMENT
-------------- --- --------- ------ ------------
주문_X01        YES RANGE     LOCAL  PREFIXED      → 로컬 Prefixed 파티션 인덱스
주문_X02        YES RANGE     LOCAL  NON_PREFIXED  → 로컬 Nonprefixed 파티션 인덱스
주문_X03        YES RANGE     GLOBAL PREFIXED      → 글로벌 Prefixed 파티션 인덱스
주문_X04        NO                                 → 비파티션 인덱스
```

### [중요한 인덱스 파티션 제약]
인덱스 파티션과 관련해 반드시 기억해야 할 중요한 제약이 한 가지 있다.

> Unique 인덱스를 파티셔닝하려면, 파티션 키가 모두 인덱스 구성 컬럼이어야 한다.

만약 이 제약이 없으면 어떻게 될까? 우선 이 제약에 어긋나지 않는 경우부터 살펴보자. 예를 들어, '주문일자'로 파티셔닝한 테이블이 있다.
PK는 '주문일자 + 주문번호'이고, 인덱스는 로컬 파티션이다. 결국, PK 인덱스도 주문일자로 파티셔닝한 셈이므로 파티션 키가 인덱스 구성 컬럼이다.
- PK 인덱스 키 : 주문일자 + 주문번호
- 파티셔닝 키 : 주문일자

이 상태에서 2017년 12월 25일에 주문번호가 123456인 주문 레코드를 입력하면, 중복 값 확인을 위해 P2017_4Q 파티션 인덱스만 탐색하면 된다.
2017년 12월 주문은 P2017_4Q(2017년 4분기) 파티션에만 입력될 수 있기 때문이다.

이번에는 PK 인덱스가 '주문번호' 단일컬럼인 경우를 보자. 테이블 파티션 키인 주문일자가 인덱스 구성 컬럼이 아니다. 방금 설명한 제약 때문에 인덱스를 파티셔닝할 수 없지만, 파티셔닝을 허용했다고 가정하자.
- PK 인덱스 키 : 주문번호
- 파티셔닝 키 : 주문일자

이 상태에서 주문번호가 123456인 주문 레코드를 입력하려면, 중복 값이 있는지 확인하려고 인덱스 파티션을 모두 탐색해야 한다. 주문번호가 123456인 레코드는 어떤 파티션에든 입력될 수 있기 때문이다.
게다가, 그 레코드를 입력하고 커밋하기 전까지, 다른 트랜잭션이 같은 주문번호로 다른 파티션에 입력하는 현상까지 막으려면 추가적인 Lock 메커니즘이 필요하다.

지금 본 것처럼 Unique 인덱스를 파티셔닝할 때 파티션 키가 인덱스 컬럼에 포함돼야 한다는 조건은 DML 성능 보장을 위해 당연히 있어야 할 제약조건이다.
그리고 파티션 키 조건 없이 PK 인덱스로 액세스하는 수많은 쿼리 성능을 위해서도 필요하다.
만약 위와 같은 PK 인덱스 파티셔닝을 허용하면, 파티션 키(주문일자) 조건 없이 PK 컬럼(주문번호)만으로 조회할 때 모든 파티션 인덱스를 탐색해야 하기 때문이다.
- 각 테이블에 대한 가장 일반적인 액세스 조건은 PK 컬럼에 대한 Unique 조건이다.

문제는, 이 제약으로 인해 PK 인덱스를 로컬 파티셔닝하지 못하면 파티션 Drop, Truncate, Exchange, Split, Merge 같은 파티션 구조 변경 작업도 쉽지 않다는 데 있다.
이들 작업을 하는 순간, PK 인덱스가 Unusable 상태로 바뀌기 때문이다. 곧바로 인덱스를 Rebuild 하면 되지만, 그동안 해당 테이블을 사용하는 서비스를 중단해야 한다.
서비스 중단 없이 파티션 구조를 빠르게 변경하려면, PK를 포함한 모든 인덱스가 로컬 파티션 인덱스이어야 한다.

지금부터 설명할 '파티션을 활용한 대량 UPDATE/DELETE/INSERT'는 파티션 구조 변경 작업을 수반하며, ILM을 지원하는 매우 중요한 기능이다.
이 기능을 활용해 ILM 관리체계를 효과적으로 운영하려면 가급적 인덱스를 로컬 파티션으로 구성해야 하며, 그러기 위해 테이블을 설계할 때부터 PK를 잘 구성해 줘야 한다.
구체적으로, 대량으로 데이터를 추가/변경/삭제하는 기준 컬럼을 PK에 포함하려고 노력해야 한다. ILM 관련 프로젝트를 해 봤다면, 그 필요성을 절감할 것이다.
- 'Information Lifecycle Management'의 줄임말로서, 데이터 생성부터 소멸까지의 생명주기를 효율적으로 관리하는 체계를 말한다.
  기간계 DB에 쌓인 과거 데이터를 주기적으로 별도(운영 비용이 더 낮은) 저장소로 옮기고, 그곳에서 일정 기간이 지나면 폐기하는 프로세스와 정책 등을 포함한다.

<br/>

## (3) 파티션을 활용한 대량 UPDATE 튜닝
인덱스가 DML 성능에 큰 영향을 미치므로 대량 데이터를 입력/수정/삭제할 때는 인덱스를 Drop 하거나 Unusable 상태로 변경하고서 작업하는 방법을 많이 활용한다.
손익분기점은 5% 정도로 본다. 즉, 입력/수정/삭제하는 데이터 비중이 5%를 넘는다면, 인덱스를 그대로 둔 상태에서 작업하기보다 인덱스 없이 작업한 후에 재생성하는 게 더 빠르다는 뜻이다.
- 실제로는 5% 이하 지점에서 결정될 때가 많다. 테이블이 클수록 손익분기점은 더 낮아진다.

예를 들어, 아래 거래 테이블에 10억 건이 저장돼 있다.
- 거래_X2: 상태코드 + 거래일자

아래 UPDATE 문을 이용해 2015년 1월 1일 전에 발생한 거래 데이터를 수정하려는데, 거래일자 조건을 만족하면서 상태코드 <> 'ZZZ'인 데이터가 5,000만 건(5%)이다.
테이블 레코드 5,000만 건을 변경하면서 거래_X02 인덱스(상태코드 컬럼 포함)까지 실시간으로 관리하려면 어마어마한 시간이 소요된다.
```
update  거래 set 상태코드 = 'ZZZ'
where   상태코드 <> 'ZZZ'
and     거래일자 < '20150101' ;
```
그렇다면 과연 5,000만 건 데이터를 수정하기 위해 10억 건짜리 인덱스를 Drop 했다가 재생성할 것인가. 10억 건 인덱스를 재생성하는 데 걸리는 시간도 만만치 않다. 이 지점에서 고민이 생긴다.

어느 쪽이 더 빠를지는 상황에 따라 다르므로 테스트해 봐야 알 수 있지만, 어느 쪽이 더 빠르건 간에, 실무적으로 이 정도 대용량 테이블이라면 인덱스를 그대로 둔 상태에서 작업하는 경우가 많다.
인덱스 전체를 재생성해야 하는 부담이 그만큼 크기 때문이다.

### [파티션 Exchange를 이용한 대량 데이터 변경]
테이블에 파티셔닝돼 있고 인덱스도 다행히 로컬 파티션이라면, 좋은 해법이 있다. 수정된 값을 갖는 임시 세그먼트를 만들어 원본 파티션과 바꿔치기하는 방식이다. 작업 순서는 다음과 같다.
(스크립트를 단순화하기 위해 2015년 1월 1일 전에 발생한 거래 데이터는 모두 '201412' 파티션에 저장돼 있다고 가정하자. 즉, '201412' 파티션이 첫 번째 파티션이다.)

- [1] 임시 테이블(거래_t)을 생성한다. 할 수 있다면 nologging 모드로 생성한다.

  ```
  create table 거래_t
  nologging
  as
  select * from 거래 where 1 = 2;
  ```

- [2] 거래 데이터를 읽어 임시 테이블에 입력하면서 상태코드 값을 수정한다.

  ```
  insert /*+ append */ into 거래_t
  select 고객번호, 거래일자, 거래순번, ...
       ,(case when 상태코드 <> 'ZZZ' then 'ZZZ' else 상태코드 end) 상태코드
  from   거래
  where  거래일자 < '20150101';
  ```

- [3] 임시 테이블에 원본 테이블과 같은 구조로 인덱스를 생성한다. 할 수 있다면 nologging 모드로 생성한다.

  ```
  create unique index 거래_t_pk on 거래_t (고객번호, 거래일자, 거래순번) nologging;
  create index 거래_t_x1 on 거래_t (거래일자, 고객번호) nologging;
  create index 거래_t_x2 on 거래_t (상태코드, 거래일자) nologging;
  ```

- [4] 2014년 12월 파티션과 임시 테이블을 Exchange 한다.

  ```
  alter table 거래
  exchange partition p201412 with table 거래_t
  including indexes without validation;
  ```

- [5] 임시 테이블을 Drop 한다.

  ```
  drop table 거래_t;
  ```

- [6] (nologging 모드로 작업했다면) 파티션을 logging 모드로 전환한다.

  ```
  alter table 거래 modify partition p201412 logging;
  alter index 거래_pk modify partition p201412 logging;
  alter index 거래_x1 modify partition p201412 logging;
  alter index 거래_x2 modify partition p201412 logging;
  ```

<br/>

## (4) 파티션을 활용한 대량 DELETE 튜닝
아래와 같은 조건절로 수천만 건 데이터를 삭제할 때도, 인덱스를 실시간으로 관리하려면 어마어마한 시간이 소요된다.
```
delete from 거래
where  거래일자 < '20150101' ;
```
그렇다고 초대용량 테이블 인덱스를 모두 Drop 했다가 다시 생성하기도 만만치 않다. UPDATE는 변경 대상 컬럼을 포함하는 인덱스만 재생성하면 되지만, DELETE는 모든 인덱스를 재생성해야 한다.
- #### [DELETE가 느린 이유]

  DELETE는 아래와 같이 여러 부수적인 작업을 수반하므로 느리다.
    - [1] 테이블 레코드 삭제
    - [2] 테이블 레코드 삭제에 대한 Undo Logging
    - [3] 테이블 레코드 삭제에 대한 Redo Logging
    - [4] 인덱스 레코드 삭제
    - [5] 인덱스 레코드 삭제에 대한 Undo Logging
    - [6] 인덱스 레코드 삭제에 대한 Redo Logging
    - [7] Undo([2], [5])에 대한 Redo Logging

  특히, 각 인덱스 레코드를 찾아서 삭제해 주는 작업에 대한 부담이 크다. 건건이 수직적 탐색 과정을 거쳐 대상 레코드를 찾아야 하기 때문이다.
  다시 강조하지만, 인덱스 개수는 DML 성능에 미치는 영향이 매우 크다.

### [파티션 Drop을 이용한 대량 데이터 삭제]
테이블이 삭제 조건절(거래일자 < '20150101') 컬럼 기준으로 파티셔닝돼 있고 인덱스도 다행히 로컬 파티션이라면, 아래와 같이 간단한 문장 하나로 대량 데이터를 순식간에 삭제할 수 있다.
```
alter table 거래 drop partition p201412;
```
오라클 11g부터 아래와 같이 값을 이용해 대상 파티션을 지정할 수도 있다.
```
alter table 거래 drop partition for('201412');
```

### [파티션 Truncate를 이용한 대량 데이터 삭제]
거래일자 조건에 해당하는 데이터를 일괄 삭제하지 않고 아래와 같이 또 다른 삭제 조건이 있는 경우가 있다.
(상태코드 <> 'ZZZ' or 상태코드 is null) 조건을 만족하는 데이터가 소수이면, 아래 DELETE 문을 그대로 사용하면 된다.
```
delete from 거래
where  거래일자 < '20150101'
and    (상태코드 <> 'ZZZ' or 상태코드 is null);
```
(상태코드 <> 'ZZZ' or 상태코드 is null) 조건을 만족하는 데이터가 대다수이면, 대량 데이터를 지울 게 아니라 남길 데이터만 백업했다가 재입력하는 방식이 빠르다. 아래와 같은 순서로 처리하면 된다.

- [1] 임시 테이블(거래_t)을 생성하고, 남길 데이터만 복제한다.

  ```
  create table 거래_t
  as
  select *
  from   거래
  where  거래일자 < '20150101'
  and    상태코드 = 'ZZZ';      -- 남길 데이터만 임시 세그먼트로 복제
  ```

- [2] 삭제 대상 테이블 파티션을 Truncate 한다.

  ```
  alter table 거래 truncate partition p201412;
  ```
  오라클 11g부터 아래와 같이 값을 이용해 대상 파티션을 지정할 수 있다.
  ```
  alter table 거래 truncate partition for('201412');
  ```

- [3] 임시 테이블에 복제해 둔 데이터를 원본 테이블에 입력한다.

  ```
  insert into 거래
  select * from 거래_t;  -- 남길 데이터만 입력
  ```

- [4] 임시 테이블을 Drop 한다.

  ```
  drop table 거래_t;
  ```

서비스 중단없이 파티션을 Drop 또는 Truncate 하려면 아래 조건을 모두 만족해야 한다.

- [1] 파티션 키와 커팅 기준 컬럼이 일치해야 함
    - 예를 들어, 파티션 키와 커팅 기준 컬럼이 모두 '신청일자'

- [2] 파티션 단위와 커팅 주기가 일치해야 함
    - 예를 들어, 월 단위 파티션을 월 주기로 커팅

- [3] 모든 인덱스가 로컬 파티션 인덱스이어야 함
    - 예를 들어, 파티션 키는 '신청일자', PK는 '신청일자 + 신청순번'
    - PK 인덱스는 지금처럼 삭제 기준(파티션 키) 컬럼이 인덱스 구성 컬럼이어야 로컬 파티셔닝 가능

<br/>

## (5) 파티션을 활용한 대량 INSERT 튜닝
### [비파티션 테이블일 때]
비파티션 테이블에 손익분기점을 넘는 대량 데이터를 INSERT 하려면, 아래와 같이 인덱스를 Unusable 시켰다가 재생성하는 방식이 더 빠를 수 있다.

- [1] (할 수 있다면) 테이블을 nologging 모드로 전환한다.

  ```
  alter table target_t nologging;
  ```

- [2] 인덱스를 Unusable 상태로 전환한다.

  ```
  alter index target_t_x01 unusable;
  ```

- [3] (할 수 있다면 Direct Path Insert 방식으로) 대량 데이터를 입력한다.

  ```
  insert /*+ append */ into target_t
  select * from source_t;
  ```

- [4] (할 수 있다면, nologging 모드로) 인덱스를 재생성한다.

  ```
  alter index target_t_x01 rebuild nologging;
  ```

- [5] (nologging 모드로 작업했다면) logging 모드로 전환한다.

  ```
  alter table target_t logging;
  alter index target_t_x01 logging;
  ```

### [파티션 테이블일 때]
초대용량 인덱스를 재생성하는 부담이 만만치 않기 때문에 시간이 더 오래 걸리더라도 실무에서 웬만하면 인덱스를 그대루 둔(Unusable 전환하지 않은) 상태로 INSERT 한다.
하지만, 테이블이 파티셔닝돼 있고, 인덱스도 다행히 로컬 파티션이라면 고민 해결이다. 파티션 단위로 인덱스를 재생성할 수 있기 때문이다.

- [1] (할 수 있다면) 작업 대상 테이블 파티션을 nologging 모드로 전환한다.

  ```
  alter table target_t modify partition p_201712 nologging;
  ```

- [2] 작업 대상 테이블 파티션과 매칭되는 인덱스 파티션을 Unusable 상태로 전환한다.

  ```
  alter index target_t_x01 modify partition p_201712 unusable;
  ```

- [3] (할 수 있다면 Direct Path Insert 방식으로) 대량 데이터를 입력한다.

  ```
  insert /*+ append */ into target_t
  select * from source_t where dt between '20171201' and '20171231';
  ```

- [4] (할 수 있다면, nologging 모드로) 인덱스 파티션을 재생성한다.

  ```
  alter index target_t_x01 rebuild partition p_201712 nologging;
  ```

- [5] (nologging 모드로 작업했다면) 작업 파티션을 logging 모드로 전환한다.

  ```
  alter table target_t modify partition p_201712 logging;
  alter index target_t_x01 modify partition logging;
  ```