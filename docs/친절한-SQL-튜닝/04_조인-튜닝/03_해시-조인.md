# 4.3 | 해시 조인
NL 조인은 인덱스를 이용한 조인 방식이므로 인덱스 구성에 따른 성능 차이가 심하다.
인덱스를 아무리 완벽하게 구성해도 랜덤 I/O 때문에 대량 데이터 처리에 불리하고, 버퍼캐시 히트율에 따라 들쭉날쭉한 성능을 보인다.
소트 머지 조인과 해시 조인은 조인 과정에 인덱스를 이용하지 않기 떄문에 대량 데이터 조인할 때 NL 조인보다 훨씬 빠르고, 일정한 성능을 보인다.

소트 머지 조인은 항상 양쪽 테이블을 정렬하는 부담이 있는데, 해시 조인은 그런 부담도 없다. 그렇다고 모든 조인을 해시 조인으로 처리할 수는 없다.
각 조인 방식의 특성을 정확히 이해함으로써 상황에 맞게 선택하는 것이 중요한데, 해시 조인의 기본 메커니즘과 실행계획 제어하는 방법 등을 설명하고, 마지막으로 조인 메소드 선택 기준도 제시한다.

<br/>

## (1) 기본 메커니즘
해시 조인(Hash Join)도 소트 머지 조인처럼 두 단계로 진행된다.
> 1. Build 단계 : 작은 쪽 테이블(Build Input)을 읽어 해시 테이블(해시 맵)을 생성한다.
> 2. Probe 단계 : 큰 쪽 테이블(Probe Input)을 읽어 해시 테이블을 탐색하면서 조인한다.

NL 조인과 소트 머지 조인에서 사용했던 아래 SQL로 해시 조인 과정을 설명해 보자. 해시 조인은 use_hash 힌트로 유도한다.
아래 SQL에 사용한 힌트는, 사원 테이블 기준으로(ordered) 고객 테이블과 조인할 때 해시 조인 방식을 사용하라(use_hash)고 지시하고 있다.

```
select /*+ ordered use_hash(c) */
       e.사원번호, e.사우너명, e.입사일자
     , c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from   사원 e, 고객 c
where  c.관리사원번호  = e.사원번호
and    e.입사일자    >= '19960101'
and    e.부서코드     = 'Z123'
and    c.최종주문금액 >= 20000
```

위 SQL 수행 과정을 설명하면 아래와 같다.

- **[1] Build 단계** : 아래 조건에 해당하는 사원 데이터를 읽어 해시 테이블을 생성한다. 이때, 조인컬럼인 사원번호를 해시 테이블 키 값으로 사용한다.
  즉, 사원번호를 해시 함수에 입력해서 반환된 값으로 해시 체인을 찾고, 그 해시 체인에 데이터를 연결한다. 해시 테이블은 PGA 영역에 할당된 Hash Area에 저장한다.
  해시 테이블이 너무 커 PGA에 담을 수 없으면, Temp 테이블스페이스에 저장한다.

  ```
  select 사원번호, 사원명, 입사일자
  from   사원
  where  입사일자 >= '19960101'
  and    부서코드 = 'Z123'
  ```
- **[2] Probe 단계** : 아래 조건에 해당하는 고객 데이터를 하나씩 읽어 앞서 생성한 해시 테이블을 탐색한다.
  즉, 관리사원번호를 해시 함수에 입력해서 반환된 값으로 해시 체인을 찾고, 그 해시 체인을 스캔해서 값이 같은 사원번호를 찾는다. 찾으면 조인에 성공한 것이고, 못 찾으면 실패한 것이다.

  ```
  select 고객번호, 고객명, 전화번호, 최종주문금액, 관리사원번호
  from   고객
  where  최종주문금액 >= 20000
  ```

Build 단계에서 사용한 해시 함수를 Probe 단계에서도 사용하므로 같은 사원번호를 입력하면 같은 해시 값을 반환한다. 따라서 해시 함수가 반환한 값에 해당하는 해시 체인만 스캔하면 된다.

Probe 단계에서 조인하는 과정을 PL/SQL 코드로 표현하면 아래와 같다.
```
begin
  for outer in (select 고객번호, 고객명, 전화번호, 최종주문금액, 관리사원번호
                from   고객
                where  최종주문금액 >= 20000)
    loop    -- outer 루프
      for inner in (select 사원번호, 사원명, 입사일자
                    from   PGA에_생성한_사원_해시맵
                    where  사원번호 = outer.관리사원번호)
      loop  -- inner 루프
        dbms_output.put_line( ... );
      end loop;
    end loop;
end;
```

실제 조인을 수행하는 [2]번 Probe 단계는 NL 조인과 다르지 않다는 사실을 위 Pseudo 코드를 통해 알 수 있다.

<br/>

## (2) 해시 조인이 빠른 이유
Hash Area에 생성한 해시 테이블(=해시 맵)을 이용한다는 점만 다를 뿐 해시 조인도 조인 프로세싱 자체는 NL 조인과 같다.
그런데도 해시 조인이 인덱스 기반의 NL 조인보다 빠른 결정적인 이유는, 소트 머지 조인이 빠른 이유와 같다. 즉, 해시 테이블을 PGA 영역에 할당하기 때문이다.
NL 조인은 Outer 테이블 레코드마다 Inner 쪽 테이브 레코드를 읽기 위해 래치 획득 및 캐시버퍼 체인 스캔 과정을 반복하지만, 해시 조인은 래치 획득 과정 없이 PGA에서 빠르게 데이터를 탐색하고 조인한다.

해시 조인도 Build Input과 Probe Input 각 테이블을 읽을 때는 DB 버퍼캐시를 경유한다. 이때 인덱스를 이용하기도 한다. 이 과정에서 생기는 버퍼캐시 탐색 비용과 랜덤 액세스 부하는 해시 조인이라도 피할 수 없다.

- #### [해시 테이블에 담기는 정보]

  해시 테이블에 조인 키값만 저장한다고 알고 있는 분이 많다. 즉, 사원 테이블 '사원번호'를 말한다.
  만약 해시 테이블을 그렇게 생성한다면, 래치 획득 과정 없이 PGA에서 조인한다는 해시 조인의 장점이 사라진다.
  조인에 성공한 사원번호에 대한 나머지 정보(사원명, 입사일자)를 읽으려면 ROWID로 다시 테이블 블록을 액세스해야 하기 때문이다.

  인덱스 ROWID로 테이블을 랜덤 액세스하는 NL 조인의 단점 때문에 소트 머지 조인과 해시 조인이 탄생했다는 사실을 상기하기 바란다.
  해시 테이블에는 조인 키값뿐만 아니라 **SQL에 사용한 컬럼을 모두 저장**한다.

해시 조인과 소트 머지 조인, 둘 다 조인 오퍼레이션을 PGA에서 처리한다는 공통점을 갖는다. 그런데 대량 데이터를 조인할 때 일반적으로 해시 조인이 더 빠르다. 이유가 무엇일까?
PGA에서 데이터를 탐색하는 알고리즘 차이도 있지만, 그 효과는 미미하다. 두 조인 메소드의 성능 차이는 조인 오퍼레이션을 시작하기 전, **사전 준비작업**에 기인한다.

소트 머지 조인에서 사전 준비작업은 '양쪽' 집합을 모두 정렬해서 PGA에 담는 작업이다.
PGA는 그리 큰 메모리 공간이 아니므로 두 집합 중 어느 하나가 중대형 이상이면, Temp 테이블스페이스, 즉 디스크에 쓰는 작업을 반드시 수반한다.

해시 조인에서 사전 준비작업은 양쪽 집합 중 어느 '한쪽'을 읽어 해시 맵을 만드는 작업이다.
해시 조인은 둘 중 작은 집합을 해시 맵 Build Input으로 선택하므로 두 집합 **모두** Hash Area에 담을 수 없을 정도로 큰 경우가 아니면, Temp 테이블스페이스, 즉 디스크에 쓰는 작업은
전혀 일어나지 않는다.

정리하면 해시 조인은, NL 조인처럼 조인 과정에서 발생하는 랜덤 액세스 부하가 없고, 소트 머지 조인처럼 양쪽 집합을 미리 정렬하는 부하도 없다.
해시 테이블을 생성하는 비용이 수반되지만, 둘 중 작은 집합을 Build Input으로 선택하므로 대개는 부담이 크지 않다.
Build Input이 PGA 메모리에 담길 때, 즉 인메모리(In-Memory) 해시 조인일 때 가장 효과적인 이유가 바로 여기에 있다.

그렇다고 Build Input이 Hash Area 크기를 초과하면 다른 조인 메소드를 선택하라는 뜻은 아니다. 설령 Temp 테이블스페이스를 쓰게 되더라도 대량 데이터 조인할 떄는 일반적으로 해시 조인이 가장 빠르다.

<br/>

## (3) 대용량 Build Input 처리
두 테이블 모두 대용량 테이블이어서 인메모리 해시 조인이 불가능한 상황일 때 DBMS는 어떤 방식으로 해시 조인을 처리할까? 복잡할 것 같지만, 의외로 간단하다.
아래 두 단계로 나눠서 진행한다. **분할・정복(Divide & Conquer)** 방식이다. (아래 내용을 이해하려면 파티션에 대한 사전 지식이 필요하다.)

- **[1] 파티션 단계**

  조인하는 양쪽 집합(→ 조인 이외 조건절을 만족하는 레코드)의 조인 컬럼에 해시 함수를 적용하고, 반환된 해시 값에 따라 동적으로 파티셔닝한다.
  독립적으로 처리할 수 있는 여러 개의 작은 서브 집합으로 분할함으로써 파티션 짝(pair)을 생성하는 단계다.

  양쪽 집합을 읽어 디스크 Temp 공간에 저장해야 하므로 인메모리 해시 조인보다 성능이 많이 떨어진다.

- **[2] 조인 단계**

  파티션 단계를 완료하면 각 파티션 짝(pair)에 대해 하나씩 조인을 수행한다. 이때, 각각에 대한 Build Input과 Probe Input은 독립적으로 결정된다.
  즉, 파티션하기 전 어느 쪽이 작은 테이블이었는지에 상관없이 각 파티션 짝(pair)별로 작은 쪽을 Build Input으로 선택하고 해시 테이블을 생성한다.

  해시 테이블을 생성하고 나면 반대쪽 파티션 로우를 하나씩 읽으면서 해시 테이블을 탐색한다. 모든 파티션 짝에 대한 처리를 마칠 때까지 이 과정을 반복한다.


<br/>

## (4) 해시 조인 실행계획 제어
아래는 해시 조인 실행계획이다.
'위쪽(HASH JOIN 바로 아래) 사원 데이터(Build Input)로 해시 테이블을 생성한 후 ,아래쪽 고객 테이블(Probe Input)에서 읽은 조인 키값으로 해시 테이블을 탐색하면서 조인한다'고 해석하면 된다.
(위쪽 Build Input과 아래쪽 Probe Input을 읽을 때 인덱스를 이용한 사실도 실행계획에서 확인할 수 있다. 물론 인덱스를 이용하지 않고 Table Full Scan 으로 처리할 수도 있다.)
```
Execution Plan
-----------------------------------------------------------------
0      SELECT STATEMENT Optimizer=ALL_ROWS
1   0    HASH JOIN
2   1      TABLE ACCESS (BY INDEX ROWID) OF '사원' (TABLE)
3   2        INDEX (RANGE SCAN) OF '사원_X1' (INDEX)
4   1      TABLE ACCESS (BY INDEX ROWID) OF '고객' (TABLE)
5   2        INDEX (RANGE SCAN) OF '고객_N1' (INDEX)
```
해시 조인 실행계획을 제어할 때 아래와 같이 use_hash 힌트를 사용한다.
```
select /*+ use_hash(e c) */
       e.사원번호, e.사우너명, e.입사일자
     , c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from   사원 e, 고객 c
where  c.관리사원번호  = e.사원번호
and    e.입사일자    >= '19960101'
and    e.부서코드     = 'Z123'
and    c.최종주문금액 >= 20000
```
여기서는 use_hash 힌트만 사용했으므로 Build Input을 옵티마이저가 선택하는데, 일반적으로 둘 중 카디널리티가 작은 테이블을 선택한다.
- 테이블 전체 카디널리티가 아니라 각 테이블 조건절에 대한 카디널리티를 말한다.

Build Input을 사용자가 직접 선택하고 싶다면 어떻게 할까? 조인 대상 테이블이 두 개뿐이라면 아래와 같이 leading이나 ordered 힌트를 사용하면 된다.
오라클은 기본적으로 이들 힌트로 지시한 순서에 따라 가장 먼저 읽는 테이블을 Build Input으로 선택한다.
```
select /*+ leading(e) use_hash(c) */  -- 또는 ordered use_hash(c)
       e.사원번호, e.사우너명, e.입사일자
     , c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from   사원 e, 고객 c
where  c.관리사원번호  = e.사원번호
and    e.입사일자    >= '19960101'
and    e.부서코드     = 'Z123'
and    c.최종주문금액 >= 20000
```
아래와 같이 swap_join_inputs 힌트로 Build Input을 명시적으로 선택할 수도 있다.
```
select /*+ leading(e) use_hash(c) swap_join_inputs(c) */
       e.사원번호, e.사우너명, e.입사일자
     , c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from   사원 e, 고객 c
where  c.관리사원번호  = e.사원번호
and    e.입사일자    >= '19960101'
and    e.부서코드     = 'Z123'
and    c.최종주문금액 >= 20000
```

### [세 개 이상 테이블 해시 조인]
조인 대상 테이블이 세 개 이상이면 어렵다고 느낄 수 있는데, 원리를 제대로 이해하면 의외로 간단하다.

예를 들어, A, B, C 세 개 테이블이 있다. 이 세 개 테이블을 조인하는 경로는 [A - B - C], [A - B] & [A - C] 두 가지다.

경로 1은 조인절이 아래와 같은 경우이다. 즉, A와 B를 조인하고, B와 C를 조인한다.
```
select *
from   A, B, C
where  A.key = B.key
and    B.key = C.key
```
경로 2는 조인절이 아래와 같은 경우이다. 즉, A와 B를 조인하고, A와 C를 조인한다.
```
select *
from   A, B, C
where  A.key = B.key
and    A.key = C.key
```
경로 1과 경로 2를 다른 케이스로 보면, 힌트 지정하는 방법도 다양해지므로 어렵게 느끼게 마련이다. 하지만 결국 세 테이블을 조인하는 경로는 단 한가지다.
(경로1에서는 A, B, C를 각각 T1, T2, T3에 대입했고, 경로2에서는 B, A, C를 각각 T1, T2, T3에 대입했다.)

이제 문제가 단순해졌다. 세 테이블에 대한 해시 조인을 제어할 때, 다음과 같이 leading 힌트를 지정해 주면 된다.
```
select /*+ leading(T1, T2, T3) use_hash(T2) use_hash(T3) */ *
from   T1, T2, T3
where  T1.key = T2.key
and    T2.key = T3.key
```
해시 조인에서 leading 힌트 첫 번째 파라미터로 지정한 테이블은 무조건 Build Input으로 선택된다. 첫 번째 파라미터로 T1 테이블을 지정했으므로 T2 테이블과 조인할 때는 T1이 Build Input이다.
따라서 위와 같이 힌트를 지정했을 때 나올 수 있는 실행계획 패턴은 아래 두 가지뿐이다.
```
< 패턴 1 >

Execution Plan
-----------------------------------------------------------------
0      SELECT STATEMENT Optimizer=ALL_ROWS
1   0    HASH JOIN
2   1      HASH JOIN
3   2        TABLE ACCESS (FULL) OF 'T1' (TABLE)
4   2        TABLE ACCESS (FULL) OF 'T2' (TABLE)
5   1      TABLE ACCESS (FULL) OF 'T3' (TABLE)


<패턴 2>

Execution Plan
-----------------------------------------------------------------
0      SELECT STATEMENT Optimizer=ALL_ROWS
1   0    HASH JOIN
2   1      TABLE ACCESS (FULL) OF 'T3' (TABLE)
3   1      HASH JOIN
4   3        TABLE ACCESS (FULL) OF 'T1' (TABLE)
5   3        TABLE ACCESS (FULL) OF 'T2' (TABLE)
```

패턴 1과 패턴 2처럼 T1이 Build Input으로 선택된 상황에서 T2를 Build Input으로 선택하고 싶다면, 아래와 같이 swap_join_inputs 힌트를 사용하면 된다.
```
select /*+ leading(T1, T2, T3) swap_join_inputs(T2) */ ...
```
그러면 실행계획은 각각 아래와 같이 바뀐다.
```
< 패턴 1 >

Execution Plan
-----------------------------------------------------------------
0      SELECT STATEMENT Optimizer=ALL_ROWS
1   0    HASH JOIN
2   1      HASH JOIN
3   2        TABLE ACCESS (FULL) OF 'T2' (TABLE)
4   2        TABLE ACCESS (FULL) OF 'T1' (TABLE)
5   1      TABLE ACCESS (FULL) OF 'T3' (TABLE)


<패턴 2>

Execution Plan
-----------------------------------------------------------------
0      SELECT STATEMENT Optimizer=ALL_ROWS
1   0    HASH JOIN
2   1      TABLE ACCESS (FULL) OF 'T3' (TABLE)
3   1      HASH JOIN
4   3        TABLE ACCESS (FULL) OF 'T2' (TABLE)
5   3        TABLE ACCESS (FULL) OF 'T1' (TABLE)
```
패턴 1을 패턴 2로 바꾸고 싶다면 어떻게 해야 할까? T3를 Build Input으로 선택하려는 것이므로 아래와 같이 swap_join_inputs 힌트를 사용하면 된다. 아주 간단하다.
```
select /*+ leading(T1, T2, T3) swap_join_inputs(T3) */  ...
select /*+ leading(T1, T2, T3) swap_join_inputs(T2) swap_join_inputs(T3) */  ...
```
가장 제어하기 어려운 것은 패턴 2를 패턴 1로 바꾸고 싶을 때다. T1과 T2 조인한 결과집합을 Build Input으로 선택하고 싶은데, 조인한 결과집합을 swap_join_inputs 힌트에 지정할 방법이 없다.
어떻게 해야 할까?

이럴 때 사용할 수 있는 힌트가 no_swap_join_inputs이다. 아래와 같이 하면 된다. 즉, T1과 T2 조인한 결과집합을 Build Input으로 선택해 주는 것이 아니라 T3를 Probe Input으로 선택해 주는 방식이다.
```
select /*+ leading(T1, T2, T3) no_swap_join_inputs(T3) */  ...
```
no_swap_join_inputs 힌트는 오라클 10.1.0.3 버전부터 제공하기 시작했다. 참고로, 이 힌트가 없을 떄는 SQL을 아래와 같이 변환하고 인라인 뷰 Alias로 제어해야만 했다.
```
select /*+ leading(T4) use_hash(T3)*/ *
from   (select * from T1, T2 where T1.key = T2.key) T4, T3
where  T4.key = T3.key

또는

select /*+ use_hash(T3 T4) swap_join_inputs(T4) */ *
from   (select * from T1, T2 where T1.key = T2.key) T4, T3
where  T4.key = T3.key
```
T1, T2, T3 세 테이블을 조인할 떄, 순서를 바꿔 T3를 먼저 읽는 경로도 있지 않냐고 반문할 수도 있다. 위의 예시와 다르게 볼 이유가 있을까?
테이블명 또는 Alias만 다를 뿐, 결국 실행계획 제어하는 방법은 똑같다. leading 힌트를 아래와 같이 기술하고, Build Input을 선택해 주면 된다.
```
select /*+ leading(T3, T2, T1) */ *
from   T1, T2, T3
where  T1.key = T2.key
and    T2.key = T3.key
```
조인하는 테이블이 네 개일 때는? 다섯 개일 때는? 일일이 다 설명할 필요가 없다. 조인하는 테이블에 몇 개든, 원리는 똑같다.
조인 연결고리를 따라 순방향 또는 역방향으로 leading 힌트에 기술한 후, Build Input으로 선택하고 싶은 테이블을 swap_join_inputs 힌트에 지정해 주면 된다.
Build Input으로 선택하고 싶은 테이블이 조인된 결과 집합이어서 swap_join_inputs 힌트로 지정하기 어렵다면, no_swap_join_inputs 힌트로 반대쪽 Probe Input을 선택해 주면 된다.

<br/>

## (5) 조인 메소드 선택 기준
지금까지 설명한 해시 조인이 워낙 빠르다 보니 내부 수행원리를 잘 모르는 개발자는 웬만하면 해시 조인으로 처리하려는 유혹에 빠지기 쉽다.
인덱스 설계에 공들이지 않아도 되니 편하기까지 하다. 그런데 이는 매우 위험한 생각이다. 수행빈도가 매우 높은 쿼리에 대해선 특히 그렇다.

왜 위험한지는 잠시 뒤에 살펴보기로 하고, 일반적인 조인 메소드 선택 기준부터 알아보자.

- [1] 소량 데이터 조인할 때 → **NL 조인**
- [2] 대량 데이터 조인할 때 → **해시 조인**
- [3] 대량 데이터 조인인데 해시 조인으로 처리할 수 없을 때, 즉 조인 조건식이 등치(=) 조건이 아닐 때(조인 조건식이 아예 없는 카테시안 곱 포함) → **소트 머지 조인**

여기서 소량과 대량의 기준은 무엇일까? 이는 단순히 데이터량의 많고 적음에 있지 않다.
NL 조인 기준으로 '최적화했는데도' 랜덤 액세스가 많아 만족할만한 성능을 낼 수 없다면, 대량 데이터 조인에 해당한다.

수행빈도가 매우 높은 쿼리에 대해선 아래와 같은 기준도 제시하고 싶다.
- [1] (최적화된) NL 조인과 해시 조인 성능이 같으면, NL 조인
- [2] 해시 조인이 약간 더 빨라도 NL 조인
- [3] NL 조인보다 해시 조인이 매우 빠른 경우, 해시 조인

[3]번 'NL 조인보다 해시 조인이 매우 빠른 경우'는 아마 대량 데이터 조인일 것이므로 '대량 데이터 조인할 때 해시 조인하라(앞서 제시한 [2]번)'는 의미는 같다.
(사실, 수행빈도가 높은 대량 데이터 조인은 거의 보기 어렵다.)
[1]번과 [2]번은 앞서 제시한 [1]번과 결국 같은 의미이므로, '수행빈도가 높은 소량 데이터 조인은 설령 해시 조인이 약간 더 빠르더라도 NL 조인을 선택하라'는 기준([2]번)을 하나 더 제시한 셈이다.
SQL 최적화할 때 옵티마이저가 수행빈도까지 고려하지 않으므로 이는 매우 중요한 선택 기준이다.

그럼 왜, 조인 메소드를 선택할 때 NL 조인을 가장 먼저 고려해야 할까? NL 조인 위주로 처리하려면 인덱스를 세심하게 설계해야 하는 부담도 있는데 말이다.
심지어, 해시 조인이 약간 더 빠른데도 왜 NL 조인을 선택해야 할까?

NL 조인에 사용하는 인덱스는 (DBA가 Drop하지 않는 한) 영구적으로 유지하면서 다양한 쿼리를 위해 공유 및 재사용하는 자료구조다.
반면, 해시 테이블은 단 하나의 쿼리를 위해 생성하고 조인이 끝나면 곧바로 소멸하는 자료구조다. 같은 쿼리를 100개 프로세스가 동시에 수행하면, 해시 테이블도 100개가 만들어진다.
따라서 수행시간이 짧으면서 수행빈도가 매우 높은 쿼리(→ OLTP성 쿼리의 특징이기도 함)를 해시 조인으로 처리하면 CPU와 메모리 사용률이 크게 증가한다.
해시 맵을 만드는 과정에 여러 가지 래치 경합도 발생한다. 결론적으로 해시 조인은 아래 세 가지 조건을 만족하는 SQL 문에 주로 사용한다.

- [1] 수행 빈도가 낮고
- [2] 쿼리 수행 시간이 오래 걸리는
- [3] 대량 데이터 조인할 때

이 세 가지 조건은 배치 프로그램, DW, OLAP성 쿼리의 특징이기도 하다. OLTP 환경에서도 해시 조인을 쓸 수 있지만, 이 세 가지 기준을 만족하는지 점검해 봐야 한다.

쉽게 말하면, OLTP 환경에서 최적화된(비효율이 없는) NL 조인으로 0.1초 걸리는 쿼리를 0.01초로 단축할 목적으로 해시 조인을 쓰는 것은 가급적 자제하라는 뜻이다.
0.1초 걸리는 쿼리를 0.01초 단축해 달라는 시스템 운영자의 요청이 있었다면, 더 그렇다. 이는 수행 빈도가 아주 높은 쿼리임이 분명하므로 해시 조인보다 약간 더 느리더라도 NL 조인이 더 적합하다.