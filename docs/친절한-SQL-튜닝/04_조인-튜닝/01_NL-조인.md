# 4.1 | NL 조인

조인의 기본은 NL 조인이다. 지금까지 설명한 인덱스 원리를 어느 정도 이해했다면 NL 조인은 절대 어렵지 않다. NL 조인은 인덱스를 이용한 조인이기 때문이다. 튜닝 원리도 그대로 적용할 수 있다.

또한, NL 조인을 정확히 이해하고 나면 다른 조인 방식도 쉽게 이해할 수 있다. 뒤에서 설명할 소트 머지 조인과 해시 조인도 프로세싱 과정은 NL 조인과 다르지 않기 때문이다.
조인할 때 어떤 자료구조를 사용하느냐의 차이일 뿐이다.

그럼, 지금부터 NL 조인의 기본 메커니즘, 실행계획 제어 및 튜닝 방법 등을 살펴보자.

<br/>

## (1) 기본 메커니즘
사원과 고객 테이블이 있을 때, 이 두 테이블에서 1996년 1월 1일 이후 입사한 사원이 관리하는 고객 데이터를 추출하는 프로그램을 작성해 보자.

아래 SQL문을 사용하면 원하는 결과집합을 쉽게 추출할 수 있지만, SQL이 탄생하기 전에는 두 테이블을 조인하는 프로그램을 개발자가 직접 작성해야만 했다. 어떤 알고리즘을 사용하면 좋을까?
```
select e.사원명, c.고객명, c.전화번호
from  사원 e, 고객 c
where e.입사일자 >= '19960101'
and   c.관리사원번호 = e.사원번호
```
가장 쉽게 생각할 수 있는 방식은, 사원 테이블로부터 1996년 1월 1일 이후 입사한 사원을 찾아 '건건이' 고객 테이블에서 사원번호가 일치(사원.사원번호 = 고객.관리사원번호)하는 레코드를 찾는 것이다.
이것이 바로 Nested Loop 조인이 사용하는 알고리즘이다.

프로그래밍을 해 본 독자라면 누구나 아래 중첩 루프문(Nested Loop)의 수행 구조를 이해할 것이다. 그렇다면 Nested Loops 조인(이하 'NL 조인')도 어렵지 않게 이해할 수 있다.
```
< C, JAVA >
for (i = 0; i < 100; i++) {      -- outer loop
  for (j = 0; j < 100; j++) {    -- inner loop
    // Do Anything ...
  }
}

< PL/SQL >
for outer int 1..100 loop
  for inner in 1..100 loop
    dbms_output.put_line(outer || ' : ' || inner);
  end loop;
end loop;
```
NL 조인은 위 중첩 루프문과 같은 수행 구조를 사용한다. 중첩 루프문을 사용하는 아래 PL/SQL 코드는 NL 조인이 어떤 순서로 데이터를 액세스하는지 잘 설명해 준다.
- NL 조인의 수행 구조, 즉 데이터 액세스 순서를 보여주기 위한 Pseudo 코드일 뿐, 실제로 이런 PL/SQL 코드를 만들어 Inner 루프쪽 SQL을 Recursive하게 반복 수행하지는 않는다.

```
begin
  for outer in (select 사원번호, 사원명 from 사원 where 입사일자 >= '19960101')
  loop    -- outer 루프
    for inner in (select 고객명, 전화번호 from 고객
                  where  관리사원번호 = outer.사원번호)
    loop  -- inner 루프
      dbms_output.put_line(
        outer.사원명 || ' : ' || inner.고객명 || ' : ' || inner.전화번호);
    end loop;
  end loop;
end;
```
일반적으로 NL 조인은 Outer와 Inner 양쪽 테이블 모두 인덱스를 이용한다. Outer 쪽 테이블(위 PL/SQL에서 사원)은 사이즈가 크지 않으면 인덱스를 이용하지 않을 수 있다.
Table Full Scan 하더라도 그것은 한 번에 그치기 때문이다. 반면, Innter 쪽 테이블(위 PL/SQL에서 고객)은 인덱스를 사용해야 한다.
위 PL/SQL을 예로 들어, Inner 루프에서 관리사원번호로 고객 데이터를 검색할 때 인덱스를 이용하지 않으면, Outer 루프에서 읽은 건수만큼 Table Full Scan을 반복하기 때문이다.

결국, NL 조인은 '인덱스를 이용한 조인 방식'이라고 할 수 있다. 인덱스를 이용해 NL 조인하는 과정을 좀 더 자세히 살펴보자.

- [1] 사원_X1 인덱스에서 입사일자 >= '19960101'인 첫 번째 레코드를 찾는다.
- [2] 인덱스에서 읽은 ROWID로 사원 테이블 레코드를 찾아간다.
- [3] 사원 테이블에서 읽은 사원번호 '0006'으로 고객_X1 인덱스를 탐색한다.
- [4] 고객_X1 인덱스에서 읽은 ROWID로 고객 테이블 레코드를 찾아간다.
- [5] 고객_X1 인덱스에서 한 건 더 스캔하고 관리사원번호가 '0006'임을 확인한다.
- [6] 고객_X1 인덱스에서 읽은 ROWID로 고객 테이블 레코드를 찾아간다. (고객_X1 인덱스에서 한 건 더 스캔하고는 관리사원번호가 '0006'보다 크므로 거기서 인덱스 스캔을 멈춘다.)
- [7] 사원_X1 인덱스에서 한 건 더 스캔해서 입사일자가 '19960712'인 레코드를 읽는다.
- [8] 인덱스에서 읽은 ROWID로 사원 테이블 레코드를 찾아간다.
- [9] 사원 테이블에서 읽은 사원번호 '0003'으로 고객_X1 인덱스를 탐색한다.
- [10] 고객_X1 인덱스에서 읽은 ROWID로 고객 테이블 레코드를 찾아간다.
- [11] 고객_X1 인덱스에서 한 건 더 스캔하고 관리사원번호가 '0003'임을 확인한다.
- [12] 고객_X1 인덱스에서 읽은 ROWID로 고객 테이블 레코드를 찾아간다. (고객_X1 인덱스에서 한 건 더 스캔하고는 관리사원번호가 '0003'보다 크므로 인덱스 스캔을 멈춘다.)

사원_X1 인덱스에서 입사일자 >= '19960101'인 모든 레코드에 대해 같은 과정을 반복한다.
사실 뒤에서 설명하는 소트 머지 조인과 해시 조인도 각각 Sort Area와 Hash Area에 가공해 둔 데이터를 이용한다는 점만 다를 뿐, 기본적인 조인 프로세싱은 다르지 않다.

<br/>

## (2) NL 조인 실행계획 제어
아래는 NL 조인 실행계획이다. '위쪽 사원 테이블 기준으로 아래쪽 고객 테이블과 NL 조인한다'고 해석하면 된다. 각 테이블을 액세스할 때 인덱스를 이용한다는 사실도 실행계획에서 확인할 수 있다.
```
Execution Plan
--------------------------------------------------------
0      SELECT STATEMENT Optimizer=ALL_ROWS
1  0     NESTED LOOPS
2  1       TABLE ACCESS (BY INDEX ROWID) OF '사원' (TABLE)
3  2         INDEX (RANGE SCAN) OF '사원_X1' (INDEX)
4  1       TABLE ACCESS (BY INDEX ROWID) OF '고객' (TABLE)
5  4         INDEX (RANGE SCAN) OF '고객_X1' (INDEX)
```
NL 조인을 제어할 때는 아래와 같이 use_nl 힌트를 사용한다.
```
select /*+ ordered use_nl(c) */
       e.사원명, c.고객명, c.전화번호
from   사원 e, 고객 c
where  e.입사일자 >= '19960101'
and    c.관리사원번호 = e.사원번호
```
ordered 힌트는 FROM 절에 기술한 순서대로 조인하라고 옵티마이저에 지시할 때 사용한다. use_nl 힌트는 NL 방식으로 조인하라고 지시할 때 사용한다.
위에서는 ordered와 use_nl(c) 힌트를 같이 사용했으므로 사원 테이블(→ Driving 또는 Outer Table) 기준으로 고객 테이블(→ Inner 테이블)과 NL 방식응로 조인하라는 뜻이다.

세 개 이상 테이블을 조인할 때는 힌트를 아래처럼 사용한다.
```
select /*+ ordered use_nl(B) use_nl(C) use_hash(D) */ *
from   A, B, C, D
where ......
```
해석해 보면, A → B → C → D 순으로 조인하되, B와 조인할 때 그리고 이어서 C와 조인할 때는 NL 방식으로 조인하고, D와 조인할 때는 해시 방식으로 조인하라는 뜻이다.

ordered 대신 아래와 같이 leading 힌트를 사용할 수도 있다. 이 힌트를 사용하면 FROM 절을 바꾸지 않고도 마음껏 순서를 제어할 수 있어 편리하다.
```
select /*+ leading(C, A, D, B) use_nl(A) use_nl(D) use_hash(B) */ *
from   A, B, C, D
where ......
```
아래는 ordered나 leading 힌트를 기술하지 않았다. 네 개 테이블을 NL 방식으로 조인하되 순서는 옵티마이저가 스스로 정하도록 맡긴 것이다.
```
select /*+ use_nl(A, B, C, D) */ *
from   A, B, C, D
where ......
```

<br/>

## (3) NL 조인 수행 과정 분석
간단한 조인문을 통해 NL 조인의 기본 알고리즘과 이를 제어하는 힌트 사용법까지 배웠다. 좀 더 자세한 NL 조인 수행 과정을 분석하기 위해 아래와 같이 조건절을 추가해 보자.
힌트에 지시한 대로 수행할 때, 조건절 비교 순서는 어떻게 될까? 조건절 우측에 표시한 번호로 순서를 나열해 보자.
```
select /*+ ordered use_nl(c) index(e) index(c) */
       e.사원번호, e.사원명, e.입사일자
     , c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from   사원 e, 고객 c
where  c.관리사원번호  = e.사원번호       --------------- [1]
and    e.입사일자    >= '19960101'     --------------- [2]
and    e.부서코드     = 'Z123'         --------------- [3]
and    c.최종주문금액 >= 20000          --------------- [4]
```
인덱스 구성은 다음과 같다.
```
* 사원_PK : 사원번호
* 사원_X1 : 입사일자
* 고객_PK : 고객번호
* 고객_X1 : 관리사원번호
* 고객_X2 : 최종주문금액
```
두 테이블에 index 힌트를 명시했으므로 둘 다 인덱스를 이용해서 액세스한다. 인덱스명은 명시하지 않았으므로 어떤 인덱스를 사용할지는 옵티마이저가 결정한다.
조건절 비교 순서와 함께 위 다섯 개 인덱스 중 어떤 것이 사용될지도 고민해 보기 바란다.

조건절 비교 순서와 인덱스를 찾았는가? 힌트에 지시한 대로 SQL 문을 수행했을 때 실행계획은 아래와 같다. 사용되는 인덱스는 사원_X1과 고객_X1인 것을 알 수 있다.
```
---------------------------------------------------------------------------
| Id  | Operation                        | Name    | Rows  | Bytes | Cost |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT                 |         |     5 |    58 |    5 |
|   1 |   NESTED LOOPS                   |         |     5 |    58 |    5 |
|   2 |     TABLE ACCESS BY INDEX ROWID  | 사원     |     3 |    20 |    2 |
|   3 |       INDEX RANGE SCAN           | 사원_X1  |     5 |       |    1 |
|   4 |     TABLE ACCESS BY INDEX ROWID  | 고객     |     5 |    76 |    2 |
|   5 |       INDEX RANGE SCAN           | 고객_X1  |     8 |       |    1 |
---------------------------------------------------------------------------
```
SQL 조건절 우측에 표시한 번호로 조건절 비교 순서를 나열하면, [2] → [3] → [1] → [4] 순이다.

- 조건절 번호 [2] : 입사일자 >= '19960101' 조건을 만족하는 레코드를 찾으려고 사원_X1 인덱스를 Rage 스캔한다. (실행계획 ID = 3)
- 조건절 번호 [3] : 사원_X1 인덱스에서 읽은 ROWID로 사원 테이블을 액세스해서 부서코드 = 'Z123' 필터 조건을 만족하는지 확인한다. (실행계획 ID = 2)
- 조건절 번호 [1] : 사원 테이블에서 읽은 사원번호 값으로 조인 조건(c.관리사원번호 = e.사원번호)을 만족하는 고객 쪽 레코드를 찾으려고 고객_X1 인덱스를 Range 스캔한다. (실행계획 ID = 5)
- 조건절 번호 [4] : 고객_X1 인덱스에서 읽은 ROWID로 고객 테이블을 액세스해서 최종주문금액 >= 20000 필터 조건을 만족하는지 확인한다. (실행계획 ID = 4)

여기서 기억할 것은, 각 단계를 모두 완료하고 다음 단계로 넘어가는 게 아니라 한 레코드씩 순차적으로 진행한다는 사실이다.

#### ■ [그림 4-7] 참조
표시한 숫자를 따라 진행해 보면 NL 조인 수행 절차를 정확히 이해할 수 있다.
- 11, 19, 31, 32는 스캔할 데이터가 더 있는지 확인하는 one-plus 스캔을 표시한 것이다.
- (○)는 테이블 필터 조건에 의해 레코드가 걸러지지 않은 것을 의미하고, 반대로 (✕)는 테이블 필터 조건에 의해 걸러진 것을 의미한다.

<br/>

## (4) NL 조인 튜닝 포인트
위 예시에서 첫 번째 튜닝 포인트는 사원_X1 인덱스를 읽고 나서 사원 테이블을 액세스하는 부분이다.
여기서는 단일 컬럼 인덱스를 '>=' 조건으로 스캔했으므로 비효율 없이 6(=5+1)건을 읽었고, 그만큼의 테이블 랜덤 액세스가 발생했다.
만약 사원 테이블로 아주 많은 양의 랜덤 액세스가 발생했고, 테이블에서 부서코드 = 'Z123' 조건에 의해 필터링되는 비율이 높다면 어떻게 해야 할까?
사원_X1 인덱스에 부서코드 컬럼을 추가하는 방안을 고려해야 한다.

두 번째 튜닝 포인트는 고객_X1 인덱스를 탐색하는 부분이다. 고객_X1 인덱스를 탐색하는 횟수, 즉 조인 액세스 횟수가 많을수록 성능이 느려진다.
조인 액세스 횟수는 Outer 테이블인 사원을 읽고 필터링한 결과 건수에 의해 결정된다. 부서코드 = 'Z123' 조건을 만족하는 건수만큼 세 번의 조인시도가 있었다.
만약 부서코드 조건을 만족하는 레코드가 10만 건이고 고객_X1 인덱스 Depth가 3이라면, 인덱스 수직적 탐색 과정에서만 30만(=10만✕3)개 블록을 읽어야 하고, 리프 블록을 수평적으로 스캔하는 과정에서
추가적인 블록 I/O가 더해진다.

세 번째 튜닝 포인트는 고객_X1 인덱스를 읽고 나서 고객 테이블을 액세스하는 부분이다.
여기서도 최종주문금액 >= 20000 조건에 의해 필터링되는 비율이 높다면 고객_X1 인덱스에 최종주문금액 컬럼을 추가하는 방안을 고려해야 한다.

마지막으로, 맨 처음 액세스하는 사원_X1 인덱스에서 얻은 결과 건수에 의해 전체 일량이 좌우된다는 사실도 기억하기 바란다.
사원_X1 인덱스를 스캔하면서 추출한 레코드가 많으면, 사원 테이블로 랜덤 액세스하는 횟수, 고객_X1 인덱스를 탐색하는 횟수, 고객 테이블로 랜덤 액세스하는 횟수가 전반적으로 많아진다.

### [올바른 조인 메소드 선택]
온라인 트랜잭션 처리(OLTP) 시스템에서 튜닝할 때는 일차적으로 NL 조인부터 고려하는 것이 올바른 순서다.

성능이 느리다면, 방금 설명한 NL 조인 튜닝 포인트에 따라 각 단계의 수행 일량을 분석해서 과도한 랜덤 액세스가 발생하는 지점을 우선 파악한다.
조인 순서를 변경해서 랜덤 액세스 발생량을 줄일 수 있는지, 더 효과적인 다른 인덱스가 있는지 등을 검토한다. 필요하다면, 인덱스 추가 또는 구성 변경도 고려해 본다.

여러 방안을 검토한 결과 NL 조인으로 결코 좋은 성능을 내기 어렵다고 판단될 때, 소트 머지 조인이나 해시 조인을 검토한다.

<br/>

## (5) NL 조인 특징 요약
NL 조인의 첫 번째 특징은 **랜덤 액세스 위주의 조인 방식**이라는 점이다. 레코드 하나를 읽으려고 블록을 통째로 읽는 랜덤 액세스 방식은 설령 메모리 버퍼에서 빠르게 읽더라도 비효율이 존재한다.
인덱스 구성이 아무리 완벽해도 대량 데이터 조인할 때 NL 조인이 불리한 이유다.

두 번째 특징은 **조인을 한 레코드씩 순차적으로 진행**한다는 점이다.
첫 번째 특징 때문에 대량 데이터 처리 시 매우 치명적인 한계를 드러내지만, 반대로 이 두 번째 특징 때문에 아무리 큰 테이블을 조인하더라도 매우 빠른 응답 속도를 낼 수 있다.
부분범위 처리가 가능한 상황에서 그렇다. 부분범위 처리를 활용하면, 아래 쿼리는 사용자가 조회 버튼을 누르자마자 결과 집합을 출력하기 시작한다.
```
select /*+ ordered use_nl(b) index_desc(a (게시판구분, 등록일시)) */
       a.게시글ID, a.제목, b.작성자명, a.등록일시
from   게시판 a, 사용자 b
where  a.게시판구분 = 'NEWS'        -- 게시판IDX : 게시판구분 + 등록일시
and    b.사용자ID = a.작성자ID      -- 사용자IDX : 사용자ID
order by a.등록일시 desc
```
순차적으로 진행하므로 먼저 액세스되는 테이블 처리 범위에 의해 전체 일량이 결정되는 특징도 나타난다.

마지막으로, 다른 조인 방식과 비교할 때 **인덱스 구성 전략이 특히 중요**하다는 것도 NL 조인의 중요한 특징이다.
조인 컬럼에 대한 인덱스가 있느냐 없느냐, 있다면 컬럼이 어떻게 구성됐느냐에 따라 조인 효율이 크게 달라진다.

이런 여러 가지 특징을 종합할 때, NL 조인은 소량 데이터를 주로 처리하거나 부분범위 처리가 가능한 온라인 트랜잭션 처리(OLTP) 시스템에 적합한 조인 방식이라고 할 수 있다.

<br/>

## (6) NL 조인 튜닝 실습
지금부터 SQL 트레이스 분석을 통해 NL 조인 튜닝 과정을 실습해 보자.
```
select /*+ ordered use_nl(c) index(e) index(c) */
       e.사원번호, e.사원명, e.입사일자
     , c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from   사원 e, 고객 c
where  c.관리사원번호  = e.사원번호
and    e.입사일자    >= '19960101'
and    e.부서코드     = 'Z123'
and    c.최종주문금액 >= 20000
```
아래는 위 쿼리에 대한 SQL 트레이스인데, 블록 I/O가 아홉 개밖에 안 되므로 튜닝할 필요가 없어 보인다.
```
call     count   cpu  elapsed  disk  query  current  rows
------- ------ ----- -------- ----- ------ -------- -----
Parse        1  0.00     0.00     0      0        0     0
Execute      1  0.00     0.00     0      0        0     0
Fetch        2  0.00     0.01     1      9        0     5
------- ------ ----- -------- ----- ------ -------- -----
total        4  0.00     0.01     1      9        0     5

Rows   Row Source Operation
-----  -------------------------------------------
    5  NESTED LOOPS
    3    TABLE ACCESS BY INDEX ROWID OF 사원
    5      INDEX RANGE SCAN OF 사원_X1
    5    TABLE ACCESS BY INDEX ROWID OF 고객
    8      INDEX RANGE SCAN OF 고객_X1
```
만약 트레이스 결과가 아래와 같았다고 하자. 어디에 문제가 있다고 생각하는가?

```
Rows   Row Source Operation
-----  -------------------------------------------
    5  NESTED LOOPS
    3    TABLE ACCESS BY INDEX ROWID OF 사원
 2780      INDEX RANGE SCAN OF 사원_X1
    5    TABLE ACCESS BY INDEX ROWID OF 고객
    8      INDEX RANGE SCAN OF 고객_X1
```
사원_X1 인덱스를 스캔하고서 사원 테이블을 액세스한 횟수가 2,780인데, 테이블에서 부서코드 = 'Z123' 조건을 필터링한 결과는 세 건에 그친다.
불필요한 테이블 액세스를 많이 한 셈이고, 이처럼 테이블을 액세스한 후에 필터링되는 비율이 높다면 인덱스에 테이블 필터 조건 컬럼을 추가하는 것을 고려할 필요가 있다.

사원_X1 인덱스에 부서코드 컬럼을 추가하고서 트레이스를 다시 확인해보니 아래와 같이 불필요한 테이블 액세스가 사라졌다. 이제 튜닝이 더 필요없는 상태일까?
```
Rows   Row Source Operation
-----  -------------------------------------------
    5  NESTED LOOPS
    3    TABLE ACCESS BY INDEX ROWID OF 사원
    3      INDEX RANGE SCAN OF 사원_X1
    5    TABLE ACCESS BY INDEX ROWID OF 고객
    8      INDEX RANGE SCAN OF 고객_X1
```
Rows 열에 표시된 숫자를 보면 비효율적인 테이블 액세스는 이제 거의 사라졌지만, 테이블을 액세스하기 전 인덱스 스캔 단계에서의 일량은 확인하지 않았으므로 튜닝이 끝났다고 볼 수 없다.

앞서 부서코드 컬럼을 추가했으므로 사원_X1 인덱스는 현재 [입사일자 + 부서코드] 순이고, 조건절을 보면 입사일자가 부등호 조건이다.
입사일자 >= '19960101' 조건에 해당하는 레코드가 아주 많다면, 그만큼 인덱스 블록을 스캔하면서 부서코드 = 'Z123' 조건을 필터링했을 것이다.

오라클 7 버전에서는 Rows 부분에 각 단계의 처리 건수(processing count)를 보여 주었으므로 실제 스캔량을 쉽게 확인할 수 있었다.
8i부터 조금씩 바뀌기 시작해 9i에서 스캔 후 출력 건수를 보여주는 방식으로 완전히 바뀌다 보니 각 단계의 처리 건수를 따로 분석해야 하는 불편함이 생겼다.
(반대로, 7 버전에서는 스캔 후 출력 건수를 따로 분석해야 했다.)

그래서 오라클은 9iR2부터 아래와 같이 각 처리 단계별 논리적인 블록 요청 횟수(cr)와 디스크에서 읽은 블록 수(pr) 그리고 디스크에 쓴 블록 수(pw) 등을 표시하기 시작했다.
```
Rows   Row Source Operation
-----  -------------------------------------------
    5  NESTED LOOPS (cr=112 pr=34 pw=0 time=122 us)
    3    TABLE ACCESS BY INDEX ROWID OF 사원 (cr=105 pr=32 pw=0 time=118 us)
    3      INDEX RANGE SCAN OF 사원_X1 (cr=102 pr=31 pw=0 time=16)
    5    TABLE ACCESS BY INDEX ROWID OF 고객 (cr=7 pr=2 pw=0 time=4)
    8      INDEX RANGE SCAN OF 고객_X1 (cr=5 pr=1 pw=0 time=0 us)
```
여기서 사원_X1 인덱스로부터 읽은 블록이 102개임을 알 수 있다. 한 블록에 평균 500개 레코드가 저장돼 있다고 가정하면, 인덱스에서 세 건을 얻기 위해 50,000개 레코드를 읽은 셈이다.

튜닝 방법은? 사원_X1 인덱스 컬럼 순서를 조정해 [부서코드 + 입사일자] 순으로 구성해 주면 된다.
(물론 다른 쿼리에 미치는 '영향도 분석'이 선행되어야 하므로 쉽지 않은 문제다. 전체적인 액세스 유형을 분석해서 처음부터 인덱스를 잘 설계해야 하는 이유가 바로 여기에 있다.)

이번에는 트레이스 결과가 아래와 같았다고 하자. 부하지점이 어디인가?
```
Rows   Row Source Operation
-----  -------------------------------------------
    5  NESTED LOOPS (cr=2732 pr=286 pw=0 time=...)
 2780    TABLE ACCESS BY INDEX ROWID OF 사원 (cr=166 pr=2 pw=0 time=...)
 2780      INDEX RANGE SCAN OF 사원_X1 (cr=4 pr=31 pw=0 time=...)
    5    TABLE ACCESS BY INDEX ROWID OF 고객 (cr=2566 pr=384 pw=0 time=...)
    8      INDEX RANGE SCAN OF 고객_X1 (cr=2558 pr=383 pw=0 time=...)
```
사원 테이블을 읽는 부분에서는 비효율이 없다. 인덱스에서 스캔한 블록이 네 개뿐이고 테이블을 액세스하고서 필터링되는 레코드도 전혀 없다. 일량은 많지만, 비효율은 없는 상태다.

문제는 사원 테이블을 읽고 나서 고객 테이블과 조인하는 횟수다. 2,780번 조인 시도를 했지만 조인에 성공하고 필터링까지 마친 최종 결과집합은 다섯 건뿐이다.
이럴 때는 조인 순서 변경을 고려해 볼 수 있다. 만약 최종주문금액 조건절에 부합하는 레코드가 별로 없다면 튜닝에 성공할 가능성이 있다.

하지만, 그 반대의 결과가 나타날 수 있다. 위에서 고객과 조인 후에 다섯 건으로 줄어든 이유는 사원으로부터 넘겨받은 사원번호와 최종주문금액 조건절을 조합했기 때문이다.
만약 조인 순서를 바꿔 최종주문금액 단독으로 조회하면, 데이터량이 2,780보다 훨씬 많을 수도 있다.

조인 순서를 바꿔도 별 소득이 없다면, 소트 머지 조인과 해시 조인을 검토해야 한다.

<br/>

## (7) NL 조인 확장 메커니즘
버전이 올라가면서 오라클은 NL 조인 성능을 높이기 위해 테이블 Prefetch, 배치 I/O 기능을 도입했다.
'테이블 Prefetch'는 인덱스를 이용해 테이블을 액세스하다가 디스크 I/O가 필요해지면, 이어서 곧 읽게 될 블록까지 미리 읽어서 버퍼캐시에 적재하는 기능이다.
'배치 I/O'는 디스크 I/O Call을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리하는 기능이다. 두 기능 모두, 읽는 블록마다 건건이 I/O Call을 발생시키는 비효율을 줄이기 위해 고안되었다.

내부 원리까지 자세히 알 필요는 없지만, 튜닝하는 과정에 이들 기능을 표현한 실행계획을 자주 보게 되므로 표현 방식은 익혀둘 필요가 있다.

#### [1] 전통적인 실행계획
오라클이 NL 조인을 표현하기 위해 전통적으로 사용해 온 방식은 아래와 같다.
```
Rows   Row Source Operation
-----  -------------------------------------------
    5  NESTED LOOPS
    3    TABLE ACCESS BY INDEX ROWID OF 사원
    3      INDEX RANGE SCAN OF 사원_X1
    5    TABLE ACCESS BY INDEX ROWID OF 고객
    8      INDEX RANGE SCAN OF 고객_X1
```

#### [2] 테이블 Prefetch 실행계획
오라클 9i부터 아래와 같은 표현방식도 같이 나타나기 시작했다.
```
Rows   Row Source Operation
-----  -------------------------------------------
    5  TABLE ACCESS BY INDEX ROWID OF 고객
   12    NESTED LOOPS
    3      TABLE ACCESS BY INDEX ROWID OF 사원
    3        INDEX RAGNE SCAN OF 사원_X1
    8      INDEX RANGE SCAN OF 고객_X1
```
이는 Inner 쪽 테이블에 대한 디스크 I/O 과정에 테이블 Prefetch 기능이 작동할 수 있음을 표시하기 위함이다.
nlj_prefetch, no_nlj_prefetch 힌트를 이용해 이 실행계획이 나오게 할 수도 있고, 안 나오게 할 수도 있다.

#### [3] 배치 I/O 실행계획
오라클 11g부터 아래와 같은 표현방식도 같이 나타나기 시작했다.
```
Rows   Row Source Operation
-----  -------------------------------------------
    5  NESTED LOOPS
    8    NESTED LOOPS
    3      TABLE ACCESS BY INDEX ROWID OF 사원
    3        INDEX RAGNE SCAN OF 사원_X1
    8      INDEX RANGE SCAN OF 고객_X1
    5    TABLE ACCESS BY INDEX ROWID OF 고객
```
이는 Inner 쪽 테이블에 대한 디스크 I/O 과정에 배치 I/O 기능이 작동할 수 있음을 표시하기 위함이다.
nlj_batching, no_nlj_batching 힌트를 이용해 이 실행계획이 나오게 할 수도 있고, 안 나오게 할 수도 있다.

오라클 11g에서는 위 세 가지 실행계획이 모두 나타나는데, Inner쪽 테이블 블록을 모두 버퍼캐시에서 읽는다면 어떤 방식으로 수행하든 성능에 차이가 없다. 데이터 출력 순서도 100% 같다.

다만, '일부를 디스크에서 읽게 되면' 성능에 차이가 나타날 수 있고, 배치 I/O 실행계획이 나타날 때는 결과집합의 정렬 순서도 다를 수 있어 특별한 주의가 필요하다.
12c에 도입된 일반 배치 I/O가 데이터 정렬 순서를 보장하지 않아서 생기는 이슈는 이전에 자세히 설명하였다.
11g부터 NL 조인 Inner 쪽 테이블에 작동하는 배치 I/O 기능도 결과집합의 정렬 순서를 보장하지 않는다.

예를 들어, 아래 쿼리는 안쪽 인라인 뷰에서 이미 등록일시 역순으로 정렬하였고, 회원 테이블과는 한 건씩 순차적으로 진행하는 NL 방식으로 조인하도록 힌트를 명시했으므로 데이터 정렬 순서를 그대로 유지한다.
따라서 배치 I/O 작동하지 않는 10g까지는 맨 바깥쪽 ORDER BY 절이 없어도 상관없었다. (물론, 혹시라도 조인 메소드가 바뀌면 정렬 순서도 흩어지므로 ORDER BY를 명시하는 것이 좋은 코딩 습관이다.)
```
SELECT /**/
       A.등록일시, A.번호, A.제목, B.회원명, A.게시판유형, A.질문유형
FROM (
      SELECT A.*, ROWNUM NO
      FROM (
            SELECT 등록일시, 번호, 제목, 작성자번호, 게시판유형, 질문유형
            FROM   게시판
            WHERE  게시판유형 = :TYPE
            ORDER BY 등록일시 DESC    -- 인덱스 구성 : 게시판유형 + 등록일시
           ) A
      WHERE ROWNUM <= (:page * 10)
     ) A, 회원 B
WHERE A.NO >= (:page-1)*10 + 1
AND   B.회원번호 = A.작성자번호
ORDER BY A.등록일시 DESC    -- 11g부터 여기에 ORDER BY를 명시해야 정렬 순서 보장
```
하지만, 11g부터 NL 조인 결과집합이 항상 일정한 순서로 출력되기를 원한다면, 배치 I/O 기능이 작동하지 못하도록 no_nlj_batching(b) 힌트를 추가하거나 아래와 같이 맨 바깥쪽 ORDER BY 절에
정렬 기준을 명시해야 한다.

주의할 것은, 11g에서 바깥쪽 메인 쿼리에 ORDER BY를 추가했어도 안쪽 ORDER BY를 함부로 제거해선 안 된다는 사실이다. 이는 Top N 쿼리를 구현하기 위한 것이기 때문이다.

- #### [NL 조인 자가 진단]

  개발팀으로부터 아래와 같이 인덱스를 생성해 달라는 요청을 받은 적이 있다.

  PRA_HST_STC_N1 : SALE_ORG_ID + STRD_GRP_ID + STRD_ID + STC_DT

  타당성 검토를 위해 관련 SQL을 요청했더니 아래 SQL을 보내왔다.

  ```
  select *
  from   PRA_HST_STC a, ODM_TRMS b
  where  a.SALE_ORG_ID = :sale_org_id
  and    a.STRD_GRP_ID = b.STRD_GRP_ID
  and    a.STRD_ID     = b.STRD_ID
  order by a.STC_DT desc
  ```
  원리를 제대로 아는 개발자라면 인덱스를 이렇게 신청할 리 없다. 대부분 개발현장에서 이런 식으로 인덱스를 만든다고 생각하면 씁쓸하다.

  지금까지 설명한 NL 조인을 제대로 이해했는지, 자가 진단해 볼 수 있는 좋은 사례다. 왜 잘못 신청한 인덱스인지, 어떻게 재구성해야 하는지, 스스로 진단해 보기 바란다.

  어느 것이 맞고 틀리고의 문제는 아니지만, NL 조인 메커니즘을 정확히 이해하는 개발자라면 조인문을 아래와 같이(inner 테이블 alias를 왼쪽에) 기술하는 습관이 자연스레 생긴다.
  이 습관이 방금 제시한 문제를 푸는 힌트다.

  ```
  select *
  from   PRA_HST_STC a, ODM_TRMS b
  where  a.SALE_ORG_ID = :sale_org_id
  and    b.STRD_GRP_ID = a.STRD_GRP_ID
  and    b.STRD_ID = a.STRD_ID
  order by a.STC_DT desc
  ```